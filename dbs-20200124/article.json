{"_id":{"$oid":"5cd43ca4dca5b94454963cb6"},"meta":{"views":51,"likes":0,"comments":0},"keyword":["react-hooks"],"desc":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook","numbers":"23358","img_url":"http://img.golderbrother.cn/react-hooks.jpg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5cd447d79865305588453109"}],"comments":[],"category":[{"$oid":"5cd44852986530558845310a"}],"title":"react-hooks","author":"james","content":"# React Hooks 相关 API 总结\n\n## 1. React Hooks\n\n- `Hook` 是 `React 16.8` 的新增特性。它可以让你在不编写 `class` 的情况下使用 `state` 以及其他的 React 特性\n- 如果你在编写函数组件并意识到需要向其添加一些 `state`，以前的做法是必须将其它转化为`class`。现在你可以在现有的函数组件中使用 `Hook`\n\n## 2. 解决的问题\n\n- 在组件之间复用状态逻辑很难,可能要用到 `render props` 和**高阶组件**，`React` 需要为共享状态逻辑提供更好的原生途径，`Hook` 使你在无需修改组件结构的情况下复用状态逻辑\n- 复杂组件变得难以理解，`Hook` 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）\n- 难以理解的 `class`,包括难以捉摸的 `this`\n\n## 3. 注意事项\n\n- 只能在函数最外层调用 `Hook`。不要在循环、条件判断或者子函数中调用。\n- 只能在 `React` 的函数组件中调用 `Hook`。不要在其他 `JavaScript` 函数中调用\n\n## 4. useState\n\n- useState 就是一个 `Hook`\n- 通过在函数组件里调用它来给组件添加一些内部 state,React 会在重复渲染时保留这个 `state`\n- use`State` 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.set`State`，但是它不会把新的 `state` 和旧的`state` 进行合并\n- use`State` 唯一的参数就是初始 `state`\n- 返回一个 `state`，以及更新 `state` 的函数\n  - 在初始渲染期间，返回的状态 (`state`) 与传入的第一个参数 (`initialState`) 值相同\n  - `setState` 函数用于更新 `state`。它接收一个新的 `state` 值并将组件的一次重新渲染加入队列\n\n```js\nconst [state, setState] = useState(initialState);\n```\n\n### 4.1 计数器\n\n```JavaScript\nimport React,{useState} from 'react';\nclass Counter extends React.Component {\n  constructor(props) {\n      super(props);\n      this.state = {\n          number: 0\n      };\n  }\n  render() {\n      return (\n          \u003cdiv\u003e\n              \u003cp\u003e{this.state.number}\u003c/p\u003e\n              \u003cbutton onClick={() =\u003e this.setState({ number: this.state.number + 1 })}\u003e\n                  +\n        \u003c/button\u003e\n          \u003c/div\u003e\n      );\n  }\n}\nfunction Counter2(){\n  const [number,setNumber] = useState(0);\n  return (\n      \u003c\u003e\n          \u003cp\u003e{number}\u003c/p\u003e\n          \u003cbutton onClick={()=\u003esetNumber(number+1)}\u003e+\u003c/button\u003e\n      \u003c/\u003e\n  )\n}\nexport default Counter2;\n```\n\n### 4.2 每次渲染都是独立的闭包\n\n- 每一次渲染都有它自己的 `Props` and `State`\n- 每一次渲染都有它自己的事件处理函数\n- alert 会“捕获”我点击按钮时候的状态。\n- 我们的组件函数每次渲染都会被调用，但是每一次调用中 `number` 值都是常量，并且它被赋予了\n- 当前渲染中的状态值\n- 在单次渲染的范围内，`props` 和 `state` 始终保持不变\n- [making-setinterval-declarative-with-react-hooks](https://overreacted.io/making-setinterval-declarative-with-react-hooks/)\n\n```js\nimport React, { useState, useRef } from 'react';\nfunction Counter() {\n  const [number, setNumber] = useState(0);\n  function alertNumber() {\n    setTimeout(() =\u003e {\n      alert(number);\n    }, 3000);\n  }\n  return (\n    \u003c\u003e\n      \u003cp\u003e{number}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setNumber(number + 1)}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={alertNumber}\u003ealertNumber\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n\nfunction Counter2() {\n  const [number, setNumber] = useState(0);\n  const savedCallback = useRef();\n  function alertNumber() {\n    setTimeout(() =\u003e {\n      alert(savedCallback.current);\n    }, 3000);\n  }\n  return (\n    \u003c\u003e\n      \u003cp\u003e{number}\u003c/p\u003e\n      \u003cbutton\n        onClick={() =\u003e {\n          setNumber(number + 1);\n          savedCallback.current = number + 1;\n        }}\n      \u003e\n        +\n      \u003c/button\u003e\n      \u003cbutton onClick={alertNumber}\u003ealertNumber\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n### 4.3 函数式更新\n\n如果新的 `state` 需要通过使用先前的 `state` 计算得出，那么可以将函数传递给 `setState`。该函数将接收先前的 `state`，并返回一个更新后的值\n\n```js\nimport React, { useState } from 'react';\nfunction Counter2() {\n  const [number, setNumber] = useState(0);\n  let numberRef = useRef(number);\n  numberRef.current = number;\n  function alertNumber() {\n    setTimeout(() =\u003e {\n      alert(numberRef.current);\n    }, 3000);\n  }\n  function lazy() {\n    setTimeout(() =\u003e {\n      setNumber(number + 1);\n    }, 3000);\n  }\n  function lazyFunc() {\n    setTimeout(() =\u003e {\n      setNumber(number =\u003e number + 1);\n    }, 3000);\n  }\n  return (\n    \u003c\u003e\n      \u003cp\u003e{number}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setNumber(number + 1)}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={lazy}\u003elazy+\u003c/button\u003e\n      \u003cbutton onClick={lazyFunc}\u003elazyFunc+\u003c/button\u003e\n      \u003cbutton onClick={alertNumber}\u003ealertNumber\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nexport default Counter2;\n```\n\n### 4.4 惰性初始 state\n\n- `initialState` 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略\n- 如果初始 `state` 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 `state`，此函数只在初始渲染时被调用\n- 与 `class` 组件中的 `setState` 方法不同，`useState` 不会自动合并更新对象。你可以用函数式的 `setState` 结合展开运算符来达到合并更新对象的效果\n\n```js\nimport React, { useState } from 'react';\nfunction Counter3() {\n  const [{ name, number }, setValue] = useState(() =\u003e {\n    return { name: '计数器', number: 0 };\n  });\n  return (\n    \u003c\u003e\n      \u003cp\u003e\n        {name}:{number}\n      \u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setValue({ number: number + 1 })}\u003e+\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n### 4.5 性能优化\n\n#### 4.5.1 Object.is\n\n- 调用 `State Hook` 的更新函数并传入当前的 `state` 时，`React` 将跳过子组件的渲染及 `effect` 的执行。（React 使用 `Object.is` 比较算法 来比较 `state`。）\n\n```js\nimport React, { useState } from 'react';\nfunction Counter4() {\n  const [counter, setCounter] = useState({ name: '计数器', number: 0 });\n  console.log('render Counter');\n  return (\n    \u003c\u003e\n      \u003cp\u003e\n        {counter.name}:{counter.number}\n      \u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setCounter({ ...counter, number: counter.number + 1 })}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setCounter(counter)}\u003e-\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n#### 4.5.2 减少渲染次数\n\n- 把内联回调函数及依赖项数组作为参数传入 `useCallback` ，它将返回该回调函数的\n  `memoized` 版本，该回调函数仅在某个依赖项改变时才会更新\n\n- 把创建函数和依赖项数组作为参数传入 `useMemo` ，它仅会在某个依赖项改变时才重新计算\n  `memoized` 值。这种优化有助于避免在每次渲染时都进行高开销的计算\n\n```js\nimport React, { useState, useMemo, memo } from 'react';\nfunction Child({ onButtonClick, data }) {\n  console.log('Child render');\n  return \u003cbutton onClick={onButtonClick}\u003e{data.number}\u003c/button\u003e;\n}\nChild = memo(Child);\nfunction App() {\n  const [number, setNumber] = useState(0);\n  const [name, setName] = useState('zhufeng');\n  const addClick = useCallback(() =\u003e setNumber(number + 1), [number]);\n  const data = useMemo(() =\u003e ({ number }), [number]);\n  return (\n    \u003cdiv\u003e\n      \u003cinput type=\"text\" value={name} onChange={e =\u003e setName(e.target.value)} /\u003e\n      \u003cChild onButtonClick={addClick} data={data} /\u003e\n    \u003c/div\u003e\n  );\n}\nexport default App;\n```\n\n### 4.6 注意事项\n\n- 只能在函数最外层调用 `Hook`。不要在**循环、条件判断或者子函数**中调用，因为这种逻辑会让 `hooks`的顺序错乱掉 。\n\n```js\nimport React, { useEffect, useState, useReducer } from 'react';\nimport ReactDOM from 'react-dom';\nfunction App() {\n  const [number, setNumber] = useState(0);\n  const [visible, setVisible] = useState(false);\n  if (number % 2 == 0) {\n    useEffect(() =\u003e {\n      setVisible(true);\n    }, [number]);\n  } else {\n    useEffect(() =\u003e {\n      setVisible(false);\n    }, [number]);\n  }\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e{number}\u003c/p\u003e\n      \u003cp\u003e{visible \u0026\u0026 \u003cdiv\u003evisible\u003c/div\u003e}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setNumber(number + 1)}\u003e+\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n## 5. useReducer\n\n- `useState` 的替代方案。它接收一个形如 `(state, action) =\u003e newState` 的 `reducer`，并返回当前的 `state` 以及与其配套的 `dispatch` 方法\n- 在某些场景下，`useReducer` 会比 `useState` 更适用，例如 `state` 逻辑较复杂且包含多个子值，或者下一个 `state` 依赖于之前的 `state` 等\n\n```js\nconst [state, dispatch] = useReducer(reducer, initialArg, init);\n```\n\n```js\nimport React, { useState, useReducer } from 'react';\nconst initialState = 0;\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { number: state.number + 1 };\n    case 'decrement':\n      return { number: state.number - 1 };\n    default:\n      throw new Error();\n  }\n}\nfunction init(initialState) {\n  return { number: initialState };\n}\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState, init);\n  return (\n    \u003c\u003e\n      Count: {state.number}\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e-\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n## 6. useContext\n\n- 接收一个 `context` 对象（`React.createContext` 的返回值）并返回该 `context` 的当前值\n- 当前的 `context` 值由上层组件中距离当前组件最近的 \u003cMyContext.Provider\u003e 的 `value prop` 决定\n- 当组件上层最近的 \u003cMyContext.Provider\u003e 更新时，该 Hook 会触发重渲染，并使用最新传递\n  给 `MyContext provider` 的 `context value` 值\n- `useContext(MyContext)` 相当于 `class` 组件中的 `static contextType = MyContext` 或者 `\u003cMyContext.Consumer\u003e`\n- `useContext(MyContext)` 只是让你能够读取 `context` 的值以及订阅 `context` 的变化。你仍然需要在上层组件树中使用 `\u003cMyContext.Provider\u003e` 来为下层组件提供 `context`\n\n```js\nimport React, { useState, useReducer } from 'react';\nconst CounterContext = React.createContext();\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { number: state.number + 1 };\n    case 'decrement':\n      return { number: state.number - 1 };\n    default:\n      throw new Error();\n  }\n}\nfunction Counter() {\n  let { state, dispatch } = useContext(CounterContext);\n  return (\n    \u003c\u003e\n      \u003cp\u003e{state.number}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e-\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nfunction App() {\n  const [state, dispatch] = useReducer(reducer, { number: 0 });\n  return (\n    \u003cCounterContext.Provider value={{ state, dispatch }}\u003e\n      \u003cCounter /\u003e\n    \u003c/CounterContext.Provider\u003e\n  );\n}\n```\n\n## 7. effect\n\n- 在函数组件主体内（这里指在 `React` 渲染阶段）改变 `DOM`、添加订阅、设置定时器、记录日\n  志以及执行其他包含**副作用**的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏\n  UI 的一致性\n\n- 使用 `useEffect` 完成**副作用**操作。赋值给 `useEffect` 的函数会在组件渲染到屏幕之后执行。你\n  可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道\n  `useEffect` 就是一个 `Effect Hook`，给函数组件增加了操作**副作用**的能力。它跟 `class` 组件中的\n  `componentDidMount` 、 `componentDidUpdate` 和 `componentWillUnmount` 具有相同的用\n  途，只不过被合并成了一个 `API`\n  该 Hook 接收一个包含命令式、且可能有副作用代码的函数\n\n```js\nuseEffect(didUpdate);\n```\n\n### 7.1 通过 class 实现修标题\n\n```js\nclass Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      number: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `你点击了${this.state.number}次`;\n  }\n\n  componentDidUpdate() {\n    document.title = `你点击了${this.state.number}次`;\n  }\n\n  render() {\n    return (\n      \u003cdiv\u003e\n        \u003cp\u003e{this.state.number}\u003c/p\u003e\n        \u003cbutton onClick={() =\u003e this.setState({ number: this.state.number + 1 })}\u003e+\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n\u003e 在这个 class 中，我们需要在两个生命周期函数中编写重复的代码,这是因为很多情况下，\n\u003e 我们希望在**组件加载和更新时执行同样的操作**。我们希望它在每次渲染之后执行，但\n\u003e `React` 的 `class` 组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地\n\u003e 方调用它。`useEffect` 会在**第一次渲染之后**和**每次更新之后**都会执行\n\n### 7.2 通过 effect 实现\n\n```js\nimport React, { Component, useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nfunction Counter() {\n  const [number, setNumber] = useState(0);\n  // 相当于 componentDidMount 和 componentDidUpdate:\n  useEffect(() =\u003e {\n    // 使用浏览器的 API 更新页面标题\n    document.title = `你点击了${number}次`;\n  });\n  return (\n    \u003c\u003e\n      \u003cp\u003e{number}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e setNumber(number + 1)}\u003e+\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nReactDOM.render(\u003cCounter /\u003e, document.getElementById('root'));\n```\n\n\u003e 每次我们重新渲染，都会生成新的 `effect`，替换掉之前的。某种意义上讲，`effect` 更像是渲\n\u003e 染结果的一部分 —— 每个 `effect` 属于一次特定的渲染。\n\n### 7.3 跳过 Effect 进行性能优化\n\n- 如果某些特定值在两次重渲染之间没有发生变化，你可以通知 `React` **跳过**对 `effect` 的调用，只要传递**数组**作为 `useEffect` 的第二个可选参数即可\n- 如果想执行只运行一次的 `effect`（仅在`组件挂载和卸载`时执行），可以传递一个**空数组**（`[]`）作为第二个参数。这就告诉 `React` 你的 `effect` 不依赖于 `props` 或 `state` 中的任何值，所以它**永远都不需要重复执行**\n\n```js\nfunction Counter() {\n  const [number, setNumber] = useState(0);\n  // 相当于componentDidMount 和 componentDidUpdate\n  useEffect(() =\u003e {\n    console.log('开启一个新的定时器');\n    const $timer = setInterval(() =\u003e {\n      setNumber(number =\u003e number + 1);\n    }, 1000);\n  }, []);\n  return (\n    \u003c\u003e\n      \u003cp\u003e{number}\u003c/p\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n### 7.4 清除副作用\n\n- 副作用函数还可以通过**返回一个函数**来指定如何清除副作用\n- 为防止**内存泄漏**，清除函数会在**组件卸载前**执行。另外，如果组件多次渲染，则在执行**下一个**\n  `effect` **之前**，上一个 `effect` 就已被清除, 所以就是会先执行 `return` 的`清除副作用函数`，再执行`effect`里面的逻辑。\n\n```js\nimport React, { useEffect, useState, useReducer } from 'react';\nimport ReactDOM from 'react-dom';\nfunction Counter() {\n  const [number, setNumber] = useState(0);\n  useEffect(() =\u003e {\n    console.log('开启一个新的定时器');\n    const $timer = setInterval(() =\u003e {\n      setNumber(number =\u003e number + 1);\n    }, 1000);\n    return () =\u003e {\n      console.log('销毁老的定时器');\n      clearInterval($timer);\n    };\n  });\n  return (\n    \u003c\u003e\n      \u003cp\u003e{number}\u003c/p\u003e\n    \u003c/\u003e\n  );\n}\nfunction App() {\n  let [visible, setVisible] = useState(true);\n  return (\n    \u003cdiv\u003e\n      {visible \u0026\u0026 \u003cCounter /\u003e}\n      \u003cbutton onClick={() =\u003e setVisible(false)}\u003estop\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n### 7.5 useRef\n\n- `useRef` 返回一个可变的 `ref` 对象，其 `.current` **属性值**被初始化为传入的参数（`initialValue`）\n- 返回的 `ref` 对象在组件的整个生命周期内保持不变\n\n```js\nconst refContainer = useRef(initialValue);\n```\n\n#### 7.5.1 useRef\n\n```js\nimport React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nfunction Parent() {\n  let [number, setNumber] = useState(0);\n  return (\n    \u003c\u003e\n      \u003cChild /\u003e\n      \u003cbutton onClick={() =\u003e setNumber({ number: number + 1 })}\u003e+\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nlet input;\nfunction Child() {\n  const inputRef = useRef();\n  console.log('input===inputRef', input === inputRef);\n  input = inputRef;\n  function getFocus() {\n    inputRef.current.focus();\n  }\n  return (\n    \u003c\u003e\n      \u003cinput type=\"text\" ref={inputRef} /\u003e\n      \u003cbutton onClick={getFocus}\u003e获得焦点\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nReactDOM.render(\u003cParent /\u003e, document.getElementById('root'));\n```\n\n#### 7.5.2 forwardRef\n\n= 将 `ref` 从父组件中转发到子组件中的 `dom` 元素上\n= 子组件接受 `props` 和 `ref` 作为参数\n\n```js\nfunction Child(props, ref) {\n  return \u003cinput type=\"text\" ref={ref} /\u003e;\n}\nChild = forwardRef(Child);\nfunction Parent() {\n  let [number, setNumber] = useState(0);\n  const inputRef = useRef();\n  function getFocus() {\n    inputRef.current.value = 'focus';\n    inputRef.current.focus();\n  }\n  return (\n    \u003c\u003e\n      \u003cChild ref={inputRef} /\u003e\n      \u003cbutton onClick={() =\u003e setNumber({ number: number + 1 })}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={getFocus}\u003e获得焦点\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n#### 7.5.3 useImperativeHandle\n\n- `useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值\n- 在大多数情况下，应当避免使用 `ref` 这样的命令式代码。`useImperativeHandle` 应当与 `forwardRef` 一起使用\n\n```js\nfunction Child(props, ref) {\n  const inputRef = useRef();\n  useImperativeHandle(ref, () =\u003e ({\n    focus() {\n      inputRef.current.focus();\n    }\n  }));\n  return \u003cinput type=\"text\" ref={inputRef} /\u003e;\n}\nChild = forwardRef(Child);\nfunction Parent() {\n  let [number, setNumber] = useState(0);\n  const inputRef = useRef();\n  function getFocus() {\n    console.log(inputRef.current);\n    inputRef.current.value = 'focus';\n    inputRef.current.focus();\n  }\n  return (\n    \u003c\u003e\n      \u003cChild ref={inputRef} /\u003e\n      \u003cbutton onClick={() =\u003e setNumber({ number: number + 1 })}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={getFocus}\u003e获得焦点\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n## 8. useLayoutEffect\n\n- 其函数签名与 `useEffect` 相同，但它会在所有的 `DOM` 变更之后同步调用 `effect`\n- 可以使用它来读取 `DOM` 布局并同步触发重渲染\n- 在浏览器执行绘制之前 `useLayoutEffect` 内部的更新计划将被同步刷新\n- 尽可能使用标准的 `useEffect` 以避免阻塞视图更新\n\n来看一张简单的**页面渲染**流程\n\n![domrender](./images/domrender.jpg)\n\n```js\nfunction LayoutEffect() {\n  const [color, setColor] = useState('red');\n  useLayoutEffect(() =\u003e {\n    alert(color);\n  });\n  useEffect(() =\u003e {\n    console.log('color', color);\n  });\n  return (\n    \u003c\u003e\n      \u003cdiv id=\"myDiv\" style={{ background: color }}\u003e\n        颜色\n      \u003c/div\u003e\n      \u003cbutton onClick={() =\u003e setColor('red')}\u003e红\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setColor('yellow')}\u003e黄\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setColor('blue')}\u003e蓝\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n## 9. 自定义 Hook\n\n- 有时候我们会想要在组件之间重用一些状态逻辑\n- 自定义 `Hook` 可以让你在不增加组件的情况下达到同样的目的\n- `Hook` 是一种复用状态逻辑的方式，它不复用 `state` 本身\n- 事实上 `Hook` 的每次调用都有一个完全独立的 `state`\n\n### 9.1.自定义计数器\n\n```js\nfunction useNumber() {\n  const [number, setNumber] = useState(0);\n  useEffect(() =\u003e {\n    console.log('开启一个新的定时器');\n    const $timer = setInterval(() =\u003e {\n      setNumber(number + 1);\n    }, 1000);\n    return () =\u003e {\n      console.log('销毁老的定时器');\n      clearInterval($timer);\n    };\n  });\n  return number;\n}\nfunction Counter1() {\n  let number1 = useNumber();\n  return (\n    \u003c\u003e\n      \u003cp\u003e{number1}\u003c/p\u003e\n    \u003c/\u003e\n  );\n}\nfunction Counter2() {\n  let number = useNumber();\n  return (\n    \u003c\u003e\n      \u003cp\u003e{number}\u003c/p\u003e\n    \u003c/\u003e\n  );\n}\nfunction App() {\n  return (\n    \u003c\u003e\n      \u003cCounter1 /\u003e\n      \u003cCounter2 /\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n### 9.2 中间件\n\n#### 9.2.1 logger\n\n实现**埋点日志**功能\n\n```js\nimport React, { useEffect, useState, useReducer } from 'react';\nimport ReactDOM from 'react-dom';\nconst initialState = 0;\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { number: state.number + 1 };\n    case 'decrement':\n      return { number: state.number - 1 };\n    default:\n      throw new Error();\n  }\n}\nfunction init(initialState) {\n  return { number: initialState };\n}\nfunction useLogger(reducer, initialState, init) {\n  const [state, dispatch] = useReducer(reducer, initialState, init);\n  let dispatchWithLogger = action =\u003e {\n    console.log('老状态', state);\n    dispatch(action);\n  };\n  useEffect(\n    function() {\n      console.log('新状态', state);\n    },\n    [state]\n  );\n  return [state, dispatchWithLogger];\n}\nfunction Counter() {\n  const [state, dispatch] = useLogger(reducer, initialState, init);\n  return (\n    \u003c\u003e\n      Count: {state.number}\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e-\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nReactDOM.render(\u003cCounter /\u003e, document.getElementById('root'));\n```\n\n#### 9.2.2 promise\n\n支持 promise\n\n```js\nimport React, { useEffect, useState, useReducer } from 'react';\nimport ReactDOM from 'react-dom';\nconst initialState = 0;\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { number: state.number + 1 };\n    case 'decrement':\n      return { number: state.number - 1 };\n    default:\n      throw new Error();\n  }\n}\nfunction init(initialState) {\n  return { number: initialState };\n}\nfunction useLogger(reducer, initialState, init) {\n  const [state, dispatch] = useReducer(reducer, initialState, init);\n  let dispatchWithLogger = action =\u003e {\n    console.log('老状态', state);\n    dispatch(action);\n  };\n  useEffect(\n    function() {\n      console.log('新状态', state);\n    },\n    [state]\n  );\n  return [state, dispatchWithLogger];\n}\nfunction usePromise(reducer, initialState, init) {\n  const [state, dispatch] = useReducer(reducer, initialState, init);\n  let dispatchPromise = action =\u003e {\n    if (action.payload \u0026\u0026 action.payload.then) {\n      action.payload.then(payload =\u003e dispatch({ ...action, payload }));\n    } else {\n      dispatch(action);\n    }\n  };\n  return [state, dispatchPromise];\n}\nfunction Counter() {\n  const [state, dispatch] = usePromise(reducer, initialState, init);\n  return (\n    \u003c\u003e\n      Count: {state.number}\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+\u003c/button\u003e\n      \u003cbutton\n        onClick={() =\u003e\n          dispatch({\n            type: 'increment',\n            payload: new Promise(resolve =\u003e {\n              setTimeout(resolve, 1000);\n            })\n          })\n        }\n      \u003e\n        delay\n      \u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nReactDOM.render(\u003cCounter /\u003e, document.getElementById('root'));\n```\n\n#### 9.2.3 thunk\n\n```js\nimport React, { useEffect, useState, useReducer } from 'react';\nimport ReactDOM from 'react-dom';\nconst initialState = 0;\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { number: state.number + 1 };\n    case 'decrement':\n      return { number: state.number - 1 };\n    default:\n      throw new Error();\n  }\n}\nfunction init(initialState) {\n  return { number: initialState };\n}\nfunction useLogger(reducer, initialState, init) {\n  const [state, dispatch] = useReducer(reducer, initialState, init);\n  let dispatchWithLogger = action =\u003e {\n    console.log('老状态', state);\n    dispatch(action);\n  };\n  useEffect(\n    function() {\n      console.log('新状态', state);\n    },\n    [state]\n  );\n  return [state, dispatchWithLogger];\n}\nfunction usePromise(reducer, initialState, init) {\n  const [state, dispatch] = useReducer(reducer, initialState, init);\n  let dispatchPromise = action =\u003e {\n    if (action.payload \u0026\u0026 action.payload.then) {\n      action.payload.then(payload =\u003e dispatch({ ...action, payload }));\n    } else {\n      dispatch(action);\n    }\n  };\n  return [state, dispatchPromise];\n}\nfunction useThunk(reducer, initialState, init) {\n  const [state, dispatch] = useReducer(reducer, initialState, init);\n  let dispatchPromise = action =\u003e {\n    if (typeof action === 'function') {\n      action(dispatchPromise, () =\u003e state);\n    } else {\n      dispatch(action);\n    }\n  };\n  return [state, dispatchPromise];\n}\nfunction Counter() {\n  const [state, dispatch] = useThunk(reducer, initialState, init);\n  return (\n    \u003c\u003e\n      Count: {state.number}\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+\u003c/button\u003e\n      \u003cbutton\n        onClick={() =\u003e\n          dispatch(function(dispatch, getState) {\n            setTimeout(function() {\n              dispatch({ type: 'increment' });\n            }, 1000);\n          })\n        }\n      \u003e\n        delay\n      \u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nReactDOM.render(\u003cCounter /\u003e, document.getElementById('root'));\n```\n\n##### async+await\n\nclient\n\n```js\nimport React, { useState, useEffect, useLayoutEffect } from 'react';\nimport ReactDOM from 'react-dom';\nfunction useRequest(url) {\n  let limit = 5;\n  let [offset, setOffset] = useState(0);\n  let [data, setData] = useState([]);\n  async function loadMore() {\n    setData(null);\n    let pageData = await fetch(`${url}?offset=${offset}\u0026limit=${limit}`).then(response =\u003e\n      response.json()\n    );\n    setData([...data, ...pageData]);\n    setOffset(offset + pageData.length);\n  }\n  useEffect(() =\u003e {\n    loadMore();\n  }, []);\n  return [data, loadMore];\n}\n\nfunction App() {\n  const [users, loadMore] = useRequest('http://localhost:8000/api/users');\n  if (users === null) {\n    return \u003cdiv\u003e正在加载中....\u003c/div\u003e;\n  }\n  return (\n    \u003c\u003e\n      \u003cul\u003e\n        {users.map((item, index) =\u003e (\n          \u003cli key={index}\u003e\n            {item.id}:{item.name}\n          \u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n      \u003cbutton onClick={loadMore}\u003e加载更多\u003c/button\u003e\n    \u003c/\u003e\n  );\n}\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\nserver\n\n```js\nlet express = require('express');\nlet app = express();\napp.use(function(req, res, next) {\n  res.header('Access-Control-Allow-Origin', 'http://localhost:3000');\n  next();\n});\napp.get('/api/users', function(req, res) {\n  let offset = parseInt(req.query.offset);\n  let limit = parseInt(req.query.limit);\n  let result = [];\n  for (let i = offset; i \u003c offset + limit; i++) {\n    result.push({ id: i + 1, name: 'name' + (i + 1) });\n  }\n  res.json(result);\n});\napp.listen(8000);\n```\n\n### 9.4 动画\n\n```js\nimport React, { useState, useEffect, useLayoutEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nfunction useMove(initialClassName) {\n  const [className, setClassName] = useState(initialClassName);\n  const [state, setState] = useState('');\n  function start() {\n    setState('bigger');\n  }\n  useEffect(() =\u003e {\n    if (state === 'bigger') {\n      setClassName(`${initialClassName} ${initialClassName}-bigger`);\n    }\n  }, [state]);\n  return [className, start];\n}\n\nfunction App() {\n  const [className, start] = useMove('circle');\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={start}\u003estart\u003c/button\u003e\n      \u003cdiv className={className}\u003e\u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n```css\n.circle {\n  width: 50px;\n  height: 50px;\n  border-radius: 50%;\n  background: red;\n  transition: all 0.5s;\n}\n.circle-bigger {\n  width: 200px;\n  height: 200px;\n}\n```\n\n## 10.附录\n\n### 10.1 浏览器是如何呈现一张页面的\n\n1. 解析 HTML，并生成一棵 DOM tree\n2. 解析各种样式并结合 DOM tree 生成一棵 Render tree\n3. 对 Render tree 的各个节点计算布局信息，比如 box 的位置与尺寸\n4. 根据并利用浏览器的 UI 层进行绘制\n\n继续引用上面那张页面渲染流程图\n\n![domrender](./images/domrender.jpg)\n\n## 最后\n\n文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下[Github](https://github.com/GolderBrother)~\n","like_users":[],"create_time":{"$date":"2019-05-09T14:43:48.988Z"},"update_time":{"$date":"2019-05-09T14:43:48.988Z"},"id":1,"__v":0}
{"_id":{"$oid":"5ce6ba3f1dddd92f8c79baee"},"meta":{"views":28,"likes":0,"comments":0},"keyword":["james"],"desc":"交互专家","numbers":"860","img_url":"http://img.golderbrother.cn/favicon.png","type":1,"state":1,"origin":0,"tags":[{"$oid":"5cd447d79865305588453109"}],"comments":[],"category":[{"$oid":"5ce15a8ce5f4657c14c9805c"}],"title":"关于我","author":"golderBrother","content":"\u003cdiv class=\"content\"\u003e\u003cdiv id=\"content\" class=\"article-detail\"\u003e\u003ch1 id=\"#toc11\"\u003e网站简介\u003c/h1\u003e\n\u003cp\u003e我的个人技术博客地址，不定期更新有价值的内容 \u003ca href=\"https://golderBrother.cn\"\u003egolderBrother 的个人博客网站(还在开发当中哈~)\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-af8dcbb956319a4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch1 id=\"#toc12\"\u003e活跃Github\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/GolderBrother\"\u003egithub\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"#toc13\"\u003e关于我\u003c/h1\u003e\n\u003cp\u003e本人姓名： 张耀煌 ，常用昵称是：神哥(来源于英雄联盟的疯狂时期emm~~~)，然后英文名有两个就是 GolderBrother或者jamesZhang，现在从事 前端开发，一枚软件开发攻城狮～\u003c/p\u003e\n\n\n\u003cp\u003e技术栈相关：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e前端：javaScript、vue.js、react.js、angular.js；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e后端：对 node.js、 java、MySql、MongoDB 等也略有接触 ；\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e业余爱折腾：跑步、健身、电影，音乐、写字；\u003c/p\u003e\n\n\u003cp\u003e邮箱：\u003cstrong\u003e1204788939#qq.com\u003c/strong\u003e ，将 \u003cstrong\u003e#\u003c/strong\u003e 号换成 \u003cstrong\u003e@\u003c/strong\u003e 即可。\u003c/p\u003e\n\n\u003c/div\u003e\u003c/div\u003e","like_users":[],"create_time":{"$date":"2019-05-23T15:20:31.821Z"},"update_time":{"$date":"2019-05-23T15:20:31.821Z"},"id":2,"__v":0}
{"_id":{"$oid":"5cf9393bb1911633f44b374a"},"meta":{"views":45,"likes":0,"comments":0},"keyword":["网站的性能优化"],"desc":"一次网站的性能优化之路 -- 天下武功，唯快不破","numbers":"18739","img_url":"http://img.golderbrother.cn/perfect.jpg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5cd447d79865305588453109"}],"comments":[],"category":[{"$oid":"5cd44852986530558845310a"}],"title":"一次网站的性能优化之路 -- 天下武功，唯快不破","author":"golderBrother","content":"\u003cdiv class=\"content\"\u003e\u003cdiv id=\"content\" class=\"article-detail\"\u003e\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-c6ef743c696cd696.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e首屏作为直面用户的第一屏，其重要性不言而喻，如何加快加载的速度是非常重要的一课。\u003c/p\u003e\n\u003cp\u003e本文讲解的是：笔者对自己搭建的个人博客网站的速度优化的经历。\u003c/p\u003e\n\u003cp\u003e效果体验地址：\u003ca href=\"http://localhost:3001\"\u003e http://localhost:3001\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"#toc11\"\u003e1. 用户期待的速度体验\u003c/h1\u003e\n\u003cp\u003e2018 年 8 月，百度搜索资源平台发布的《百度移动搜索落地页体验白皮书 4.0 》中提到：\u003cstrong\u003e页面的首屏内容应在 1.5 秒内加载完成\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e也许有人有疑惑：为什么是 1.5 秒内？哪些方式可加快加载速度？以下将为您解答这些疑问！\u003c/p\u003e\n\u003cp\u003e移动互联网时代，用户对于网页的打开速度要求越来越高。百度用户体验部研究表明，页面放弃率和页面的打开时间关系如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-6fc8794f8694acfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"页面放弃率和页面的打开时间关系\"\u003e\u003c/p\u003e\n\u003cp\u003e根据百度用户体验部的研究结果来看，普通用户期望且能够接受的页面加载时间在 3 秒以内。若页面的加载时间过慢，用户就会失去耐心而选择离开，这对用户和站长来说都是一大损失。\u003c/p\u003e\n\u003cp\u003e百度搜索资源平台有 “闪电算法” 的支持，为了能够保障用户体验，给予优秀站点更多面向用户的机会，“闪电算法”在 2017 年 10 月初上线。\u003c/p\u003e\n\u003cp\u003e闪电算法 的具体内容如下：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e移动网页首屏在 2 秒之内完成打开的，在移动搜索下将获得提升页面评价优待，获得流量倾斜；同时，在移动搜索页面首屏加载非常慢（3 秒及以上）的网页将会被打压。\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"#toc12\"\u003e2. 分析问题\u003c/h1\u003e\n\u003cp\u003e未优化之前，首屏时间居然大概要 7 - 10 秒，简直不要太闹心。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-6b4894c8ee6020a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-e9cb985bca8efcd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e开始分析问题，先来看下 network ：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-d6730f25f400cc7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e主要问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e第一个文章列表接口用了 4.42 秒\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e其他的后端接口速度也不快\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e另外 js css 等静态的文件也很大，请求的时间也很长\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我还用了 Lighthouse 来测试和分析我的网站。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为 Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e未优化之前：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-c427ff2fd6c23bec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上栏内容分别是页面性能、PWA（渐进式 Web 应用）、可访问性（无障碍）、最佳实践、SEO 五项指标的跑分。\u003c/p\u003e\n\u003cp\u003e下栏是每一个指标的细化性能评估。\u003c/p\u003e\n\u003cp\u003e再看下 Lighthouse 对性能问题给出了可行的建议、以及每一项优化操作预期会帮我们节省的时间：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-f7a9eb3526a755b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e从上面可以看出，主要问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e图片太大\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e一开始图片就加载了太多\u003c/strong\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e知道问题所在就已经成功了一半了，接下来便开始优化之路。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-badeaef63e605bfb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch1 id=\"#toc13\"\u003e2. 优化之路\u003c/h1\u003e\n\u003cp\u003e网页速度优化的方法实在太多，本文只说本次优化用到的方法。\u003c/p\u003e\n\u003ch2 id=\"#toc24\"\u003e2.1 前端优化\u003c/h2\u003e\n\u003cp\u003e本项目前端部分是用了 react 和 antd，但是 webpack 用的还是 3.8.X 。\u003c/p\u003e\n\u003ch4 id=\"#toc45\"\u003e2.1.1 webpack 打包优化\u003c/h4\u003e\n\u003cp\u003e因为 webpack4 对打包做了很多优化，比如 Tree-Shaking ，所以我用最新的 react-create-app 重构了一次项目，把项目升级了一遍，所有的依赖包都是目前最新的稳定版了，webpack 也升级到了 4.28.3 。\u003c/p\u003e\n\u003cp\u003e用最新 react-create-app 创建的项目，很多配置已经是很好了的，笔者只修改了两处地方。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003col\u003e\n\u003cli\u003e打包配置修改了 webpack.config.js 的这一行代码：\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003e// Source maps are resource heavy \u003cspan class=\"hljs-keyword\"\u003eand\u003c/span\u003e can cause \u003cspan class=\"hljs-keyword\"\u003eout\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e memory issue \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e large source files.\nconst shouldUseSourceMap = \u003cspan class=\"hljs-keyword\"\u003eprocess\u003c/span\u003e.env.GENERATE_SOURCEMAP !== \u003cspan class=\"hljs-symbol\"\u003e'false\u003c/span\u003e';\n\n// 把上面的代码修改为： \nconst shouldUseSourceMap = \u003cspan class=\"hljs-keyword\"\u003eprocess\u003c/span\u003e.env.NODE_ENV === \u003cspan class=\"hljs-symbol\"\u003e'production\u003c/span\u003e' ? \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e : \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e生产环境下，打包去掉 SourceMap，静态文件就很小了，从 13M 变成了 3M 。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003col start=\"2\"\u003e\n\u003cli\u003e还修改了图片打包大小的限制，这样子小于 40K 的图片都会变成 base64 的图片格式。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003e{\n      \u003cspan class=\"hljs-symbol\"\u003etest:\u003c/span\u003e [\u003cspan class=\"hljs-regexp\"\u003e/\\.bmp$/\u003c/span\u003e, \u003cspan class=\"hljs-regexp\"\u003e/\\.gif$/\u003c/span\u003e, \u003cspan class=\"hljs-regexp\"\u003e/\\.jpe?g$/\u003c/span\u003e, \u003cspan class=\"hljs-regexp\"\u003e/\\.png$/\u003c/span\u003e,\u003cspan class=\"hljs-regexp\"\u003e/\\.jpg$/\u003c/span\u003e,\u003cspan class=\"hljs-regexp\"\u003e/\\.svg$/\u003c/span\u003e],\n      \u003cspan class=\"hljs-symbol\"\u003eloader:\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e'url-loader'\u003c/span\u003e),\n      \u003cspan class=\"hljs-symbol\"\u003eoptions:\u003c/span\u003e {\n            \u003cspan class=\"hljs-symbol\"\u003elimit:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e40000\u003c/span\u003e, \u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e 把默认的 \u003cspan class=\"hljs-number\"\u003e10000\u003c/span\u003e 修改为 \u003cspan class=\"hljs-number\"\u003e40000\u003c/span\u003e\n            \u003cspan class=\"hljs-symbol\"\u003ename:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'static/media/[name].[hash:8].[ext]'\u003c/span\u003e,\n      },\n }\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"#toc46\"\u003e2.1.2 去掉没用的文件\u003c/h4\u003e\n\u003cp\u003e比如之前可能觉得会有用的文件，后面发现用不到了，注释或者删除，比如 reducers 里面的 home 模块。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { combineReducers } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'redux'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { connectRouter } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'connected-react-router'\u003c/span\u003e\n\u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { home } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./module/home'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { user } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./module/user'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { articles } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./module/articles'\u003c/span\u003e\n\nconst rootReducer = \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e(history)\u003c/span\u003e =\u0026gt;\u003c/span\u003e combineReducers({\n \u003cspan class=\"hljs-regexp\"\u003e//\u003c/span\u003e home, \n  user,\n  articles,\n  router: connectRouter(history)\n})\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"#toc47\"\u003e2.1.3 图片处理\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e把一些静态文件再用 photoshop 换一种格式或者压缩了一下， 比如 logo 图片，原本 111k，压缩后是 23K。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e首页的文章列表图片，修改为懒加载的方式加载。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e之前因为不想为了个懒加载功能而引用一个插件，所以想自己实现，看了网上关于图片懒加载的一些代码，再结合本项目，实现了一个图片懒加载功能，加入了 \u003cstrong\u003e事件的节流（throttle）与防抖（debounce）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003e\u003cspan class=\"hljs-comment\"\u003e// fn 是事件回调, delay 是时间间隔的阈值\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efn, delay\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// last 为上一次触发回调的时间, timer 是定时器\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e last = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    timer = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// 将throttle处理结果当作函数返回\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// 保留调用时的 this 上下文\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e context = \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 保留调用时传入的参数\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e args = \u003cspan class=\"hljs-built_in\"\u003earguments\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 记录本次触发回调的时间\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e now = +\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-comment\"\u003e// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (now - last \u0026lt; delay) {\n      \u003cspan class=\"hljs-comment\"\u003e// 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器\u003c/span\u003e\n      clearTimeout(timer);\n      timer = setTimeout(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n        last = now;\n        fn.apply(context, args);\n      }, delay);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应\u003c/span\u003e\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 获取可视区域的高度\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e viewHeight = \u003cspan class=\"hljs-built_in\"\u003ewindow\u003c/span\u003e.innerHeight || \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.documentElement.clientHeight;\n\u003cspan class=\"hljs-comment\"\u003e// 用新的 throttle 包装 scroll 的回调\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e lazyload = throttle(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 获取所有的图片标签\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imgs = \u003cspan class=\"hljs-built_in\"\u003edocument\u003c/span\u003e.querySelectorAll(\u003cspan class=\"hljs-string\"\u003e'#list .wrap-img img'\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// num 用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e num = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = num; i \u0026lt; imgs.length; i++) {\n    \u003cspan class=\"hljs-comment\"\u003e// 用可视区域高度减去元素顶部距离可视区域顶部的高度\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e distance = viewHeight - imgs[i].getBoundingClientRect().top;\n    \u003cspan class=\"hljs-comment\"\u003e// 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (distance \u0026gt;= \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 给元素写入真实的 src，展示图片\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e hasLaySrc = imgs[i].getAttribute(\u003cspan class=\"hljs-string\"\u003e'data-has-lazy-src'\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (hasLaySrc === \u003cspan class=\"hljs-string\"\u003e'false'\u003c/span\u003e) {\n        imgs[i].src = imgs[i].getAttribute(\u003cspan class=\"hljs-string\"\u003e'data-src'\u003c/span\u003e);\n        imgs[i].setAttribute(\u003cspan class=\"hljs-string\"\u003e'data-has-lazy-src'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \u003c/span\u003e\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 前 i 张图片已经加载完毕，下次从第 i+1 张开始检查是否露出\u003c/span\u003e\n      num = i + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n    }\n  }\n}, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\n\u003cp\u003e注意：给元素写入真实的 src 了之后，把 data-has-lazy-src 设置为 true ，是为了避免回滚的时候再设置真实的 src 时，浏览器会再请求这个图片一次，白白浪费服务器带宽。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-f5e314cd7ba66cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e具体细节请看文件 \u003ca href=\"https://github.com/GolderBrother/blog-react/blob/master/src/components/articles/articles.js\"\u003e文章列表\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"#toc28\"\u003e2.2 后端优化\u003c/h2\u003e\n\u003cp\u003e后端用到的技术是 node、express 和 mongodb。\u003c/p\u003e\n\u003cp\u003e后端主要问题是接口速度很慢，特别是文章列表的接口，已经是分页请求数据了，为什么还那么慢呢 ？\u003c/p\u003e\n\u003cp\u003e所以查看了接口返回内容之后，发现返回了很多列表不展示的字段内容，\u003cstrong\u003e特别是文章内容都返回了，而文章内容是很大的，占用了很多资源与带宽，从而使接口消耗的时间加长\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-f4d6c258b69e9ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"列表\"\u003e\u003c/p\u003e\n\u003cp\u003e从上图可以看出文章列表接口只要返回文章的 标题、描述、封面、查看数，评论数、点赞数和时间即可。\u003c/p\u003e\n\u003cp\u003e所以把不需要给前端展示的字段注释掉或者删除。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 待返回的字段\u003c/span\u003e\n      let fields = {\n        title: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"hljs-comment\"\u003e// author: 1,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// keyword: 1,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// content: 1,\u003c/span\u003e\n        desc: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        img_url: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        tags: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        category: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"hljs-comment\"\u003e// state: 1,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// type: 1,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// origin: 1,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// comments: 1,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// like_User_id: 1,\u003c/span\u003e\n        meta: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        create_time: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"hljs-comment\"\u003e// update_time: 1,\u003c/span\u003e\n      };\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e同样对其他的接口都做了这个处理。\u003c/p\u003e\n\u003cp\u003e后端做了处理之后，所有的接口速度都加快了，\u003cstrong\u003e特别是文章列表接口，只用了 0.04 - 0.05 秒左右，相比之前的 4.3 秒，速度提高了 100 倍\u003c/strong\u003e，简直不要太爽， 效果如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-915be88fbe9ec915.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此刻心情如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-d474954d87feabcf.gif?imageMogr2/auto-orient/strip\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch2 id=\"#toc29\"\u003e2.3 服务器优化\u003c/h2\u003e\n\u003cp\u003e你以为前后端都优化一下，本文就完了 ？小兄弟，你太天真了，\u003cstrong\u003e重头戏在后头 ！\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-b78c783751e5cb31.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e笔者服务器用了 nginx 代理。\u003c/p\u003e\n\u003cp\u003e做的优化如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e隐藏 nginx 版本号\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e一般来说，软件的漏洞都和版本相关，所以我们要隐藏或消除 web 服务对访问用户显示的各种敏感信息。\u003c/p\u003e\n\u003cp\u003e如何查看 nginx 版本号？ 直接看 network 的接口或者静态文件请求的 Response Headers \u0008即可。\u003c/p\u003e\n\u003cp\u003e没有设置之前，可以看到版本号，比如我网站的版本号如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003eServer: nginx/\u003cspan class=\"hljs-number\"\u003e1.6\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e设置之后，直接显示 nginx 了，没有了版本号，如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003e\u003cspan class=\"hljs-built_in\"\u003eServer\u003c/span\u003e: nginx\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e开启 gzip 压缩\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003enginx 对于处理静态文件的效率要远高于 Web 框架，因为可以使用 gzip 压缩协议，减小静态文件的体积加快静态文件的加载速度、开启缓存和超时时间减少请求静态文件次数。\u003c/p\u003e\n\u003cp\u003e笔者开启 gzip 压缩之后，请求的静态文件大小大约减少了 2 / 3 呢。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003egzip \u003cspan class=\"hljs-keyword\"\u003eon\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e#该指令用于开启或关闭gzip模块(on/off)\u003c/span\u003e\n\ngzip_buffers \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003ek;\n\u003cspan class=\"hljs-comment\"\u003e#设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。16 8k代表以8k为单位，安装原始数据大小以8k为单位的16倍申请内存\u003c/span\u003e\n\ngzip_comp_level \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e#gzip压缩比，数值范围是1-9，1压缩比最小但处理速度最快，9压缩比最大但处理速度最慢\u003c/span\u003e\n\ngzip_http_version \u003cspan class=\"hljs-number\"\u003e1.1\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e#识别http的协议版本\u003c/span\u003e\n\ngzip_min_length \u003cspan class=\"hljs-number\"\u003e256\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e#设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是0，不管页面多大都压缩。这里我设置了为256\u003c/span\u003e\n\ngzip_proxied any;\n\u003cspan class=\"hljs-comment\"\u003e#这里设置无论header头是怎么样，都是无条件启用压缩\u003c/span\u003e\n\ngzip_vary \u003cspan class=\"hljs-keyword\"\u003eon\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e#在http header中添加Vary: Accept-Encoding ,给代理服务器用的\u003c/span\u003e\n\ngzip_types\n    \u003cspan class=\"hljs-built_in\"\u003etext\u003c/span\u003e/xml \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/xml \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/atom+xml \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/rss+xml \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/xhtml+xml image/svg+xml\n    \u003cspan class=\"hljs-built_in\"\u003etext\u003c/span\u003e/javascript \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/javascript \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/x-javascript\n    \u003cspan class=\"hljs-built_in\"\u003etext\u003c/span\u003e/x-json \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/json \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/x-web-app-manifest+json\n    \u003cspan class=\"hljs-built_in\"\u003etext\u003c/span\u003e/css \u003cspan class=\"hljs-built_in\"\u003etext\u003c/span\u003e/plain \u003cspan class=\"hljs-built_in\"\u003etext\u003c/span\u003e/x-component\n    font/opentype font/ttf \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/x-font-ttf \u003cspan class=\"hljs-built_in\"\u003eapplication\u003c/span\u003e/vnd.ms-fontobject\n    image/x-icon;\n\u003cspan class=\"hljs-comment\"\u003e#进行压缩的文件类型,这里特别添加了对字体的文件类型\u003c/span\u003e\n\ngzip_disable \u003cspan class=\"hljs-string\"\u003e\"MSIE [1-6]\\.(?!.*SV1)\"\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e#禁用IE 6 gzip\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e把上面的内容加在 nginx 的配置文件 ngixn.conf 里面的 http 模块里面即可。\u003c/p\u003e\n\u003cp\u003e是否设置成功，看文件请求的 Content-Encoding 是不是 gzip 即可。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-092240d63c0f469e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e设置 expires，设置缓存\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"code\"\u003e \u003cspan class=\"hljs-section\"\u003eserver\u003c/span\u003e {\n        \u003cspan class=\"hljs-attribute\"\u003elisten\u003c/span\u003e       \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003eserver_name\u003c/span\u003e  localhost;\n        \u003cspan class=\"hljs-attribute\"\u003elocation\u003c/span\u003e  / {\n            \u003cspan class=\"hljs-attribute\"\u003eroot\u003c/span\u003e   /home/blog/blog-react/build/;\n            \u003cspan class=\"hljs-attribute\"\u003eindex\u003c/span\u003e  index.html;\n            \u003cspan class=\"hljs-attribute\"\u003etry_files\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e$uri\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e$uri\u003c/span\u003e/ \u003cspan class=\"hljs-variable\"\u003e@router\u003c/span\u003e;\n            \u003cspan class=\"hljs-attribute\"\u003eautoindex\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eon\u003c/span\u003e;\n            \u003cspan class=\"hljs-attribute\"\u003eexpires\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e7d\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e# 缓存 7 天\u003c/span\u003e\n        }\n    }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我重新刷新请求的时候是 2019 年 3 月 16 号，是否设置成功看如下几个字段就知道了：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-324f8229ee54440c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eStaus Code 里面的 form memory cache 看出，文件是直接从本地浏览器本地请求到的，没有请求服务器。\u003c/li\u003e\n\u003cli\u003eCache-Control 的 max-age= 604800 看出，过期时间为 7 天。\u003c/li\u003e\n\u003cli\u003eExpress 是 2019 年 3 月 23 号过期，也是 7 天过期。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注意：上面最上面的用红色圈中的 Disable cache 是否是打上了勾，打了勾表示：浏览器每次的请求都是请求服务器，无论本地的文件是否过期。所以要把这个勾去掉才能看到缓存的效果。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e终极大招：\u003cstrong\u003e服务端渲染 SSR\u003c/strong\u003e，也是笔者接下来的方向。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"#toc410\"\u003e3.1 测试场景\u003c/h4\u003e\n\u003cp\u003e一切优化测试的结果脱离了实际的场景都是在耍流氓，而且不同时间的网速对测试结果的影响也是很大的。\u003c/p\u003e\n\u003cp\u003e所以笔者的测试场景如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea. 笔者的服务器是阿里的，配置是入门级的学生套餐配置，如下：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-bde4a529183ff1f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"服务器配置\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eb. 测试网络为 10 M 光纤宽带。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"#toc411\"\u003e3.2 优化结果\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e优化之后的首屏速度是 2.07 秒。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-befa6b7c01219e5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e最后加了缓存的结果为 0.388 秒\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-7ae2673d65cd6a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e再来看下 Lighthouse 的测试结果：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/12890819-c89d85fe22d27f8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e比起优化之前，各项指标都提升了很大的空间。\u003c/p\u003e\n\u003ch1 id=\"#toc112\"\u003e4. 最后\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e优化之路漫漫，永无止境，天下武功，唯快不破。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e本次优化的前端与后端项目，都已经开源在 github 上了，欢迎围观。\u003c/p\u003e\n\u003cp\u003e前端：\u003ca href=\"https://github.com/GolderBrother/blog-react\"\u003ehttps://github.com/GolderBrother/blog-react\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e后端：\u003ca href=\"https://github.com/GolderBrother/blog-node-egg\"\u003ehttps://github.com/GolderBrother/blog-node-egg\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003egithub 地址：\u003ca href=\"https://github.com/GolderBrother\"\u003ehttps://github.com/GolderBrother\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e如果您觉得这篇文章不错或者对你有所帮助，请给个赞或者星呗，你的点赞就是我继续创作的最大动力。\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e","like_users":[],"create_time":{"$date":"2019-06-06T16:03:07.587Z"},"update_time":{"$date":"2019-06-06T16:03:07.587Z"},"id":3,"__v":0}
{"_id":{"$oid":"5d95fecd8320730030b5078a"},"meta":{"views":84,"likes":0,"comments":0},"keyword":["react"],"desc":"React性能优化","numbers":"28766","img_url":"http://img.golderbrother.cn/react-logo.svg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5cd447d79865305588453109"}],"comments":[],"category":[],"title":"React性能优化","author":"golderBrother","content":"## 1. 使用Fragment\n- Fragment 可以让你聚合一个子元素列表,并且不在DOM中增加额外节点\n- Fragment 看起来像空的 JSX 标签\n\u003e Fragment 有个语法糖，那就是空标签 ```\u003c\u003e\u003c/\u003e```，相当于 ```\u003cFragment\u003e\u003c/Fragment\u003e =\u003e \u003c\u003e\u003c/\u003e```\n\n### 1.1 index.js\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Table from './components/Table';\nlet data = [{ id: 1, name: 'golderBrother', age: 18 }, { id: 2, name: 'robin', age: 20 }];\nReactDOM.render(\u003cTable data={data} /\u003e, document.getElementById('ro以在加载组件时显示后备内容ot'));\n```\n### 1.2 Table.js\n```\nimport React from 'react';\nclass Columns extends React.Component {\n  render() {\n    let data = this.props.data;\n    //Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a\n    // JSX fragment \u003c\u003e...\u003c/\u003e\n    return (\n      \u003c\u003e\n        \u003ctd\u003e{data.id}\u003c/td\u003e\n        \u003ctd\u003e{data.name}\u003c/td\u003e\n        \u003ctd\u003e{data.age}\u003c/td\u003e\n      \u003c/\u003e\n    );\n  }\n}\nexport default class Table extends React.Component {\n  render() {\n    return (\n      \u003ctable\u003e\n        \u003cthead\u003e\n          \u003ctr\u003e\n            \u003ctd\u003eID\u003c/td\u003e\n            \u003ctd\u003eName\u003c/td\u003e\n            \u003ctd\u003eAge\u003c/td\u003e\n          \u003c/tr\u003e\n        \u003c/thead\u003e\n        \u003ctbody\u003e\n          {this.props.data.map((item, index) =\u003e (\n            \u003ctr key={index}\u003e\n              \u003cColumns data={item} /\u003e\n            \u003c/tr\u003e\n          ))}\n        \u003c/tbody\u003e\n      \u003c/table\u003e\n    );\n  }\n}\n```\n\n## 2. PureComponent\n- 当一个组件的 ```props``` 或 ```state``` 变更， React 会将最新返回的元素与之前渲染的元素进行对比，以\n此决定是否有必要更新真实的 DOM，当它们不相同时 React 会更新该 DOM\n- 如果渲染的组件非常多时可以通过覆盖生命周期方法 shouldComponentUpdate 来进行优化\n- ```shouldComponentUpdate``` 方法会在重新渲染前被触发。其默认实现是返回 true,如果组件不需要\n更新，可以在 shouldComponentUpdate 中返回 false 来跳过整个渲染过程。其包括该组件的\nrender 调用以及之后的操作\n### 2.1 重复渲染\n```\nimport React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nclass App extends Component {\n  state = { counter: { number: 0 } };\n  add = () =\u003e {\n    let oldState = this.state;\n    let amount = parseInt(this.amount.value);\n    let newState = {\n      ...oldState,\n      counter:\n        amount == 0\n          ? oldState.counter\n          : { number: oldState.counter.number + amount }\n    };\n    this.setState(newState);\n  };\n  render() {\n    console.log(\"App render\");\n    return (\n      \u003cdiv\u003e\n        \u003cCounter counter={this.state.counter} /\u003e\n        \u003cinput ref={inst =\u003e (this.amount = inst)} /\u003e\n        \u003cbutton onClick={this.add}\u003e+\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\nclass Counter extends React.Component {\n  render() {\n    console.log(\"Counter render\");\n    return \u003cp\u003e{this.props.counter.number}\u003c/p\u003e;\n  }\n}\nReactDOM.render(\u003cApp /\u003e, document.getElementById(\"root\"));\n```\n\n### 2.2 PureComponent\n- React15.3 中新加了一个类 PureComponent ,它会在 render 之前帮组件自动执行一次\nshallowEqual （浅比较），来决定是否更新组件\n- PureComponent 通过 prop 和 state 的浅比较来实现 shouldComponentUpdate\n\n```\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n+class PureComponent extends Component {\n+ shouldComponentUpdate(newProps) {\n+ return !shallowEqual(this.props, newProps);\n+ }\n+}\n+function shallowEqual(obj1, obj2) {\n+ if (obj1 === obj2) {\n+ return true;\n+ }\n+ if (typeof obj1 != \"object\" ||obj1 === null ||typeof obj2 != \"object\" ||obj2\n=== null) {\n+ return false;\n+ }\n+ let keys1 = Object.keys(obj1);\n+ let keys2 = Object.keys(obj2);\n+ if (keys1.length != keys2.length) {\n+ return false;\n+ }\n+ for (let key of keys1) {\n+ if (!obj2.hasOwnProperty(key) || obj1[key] !== obj2[key]) {\n+ return false;\n+ }\n+ }\n+ return true;\n+}\nclass App extends Component {\n  state = { counter: { number: 0 } };\n  add = () =\u003e {\n    let oldState = this.state;\n    let amount = parseInt(this.amount.value);\n    let newState = {\n      ...oldState,\n      counter: amount == 0 ? oldState.counter : { number: oldState.counter.number + amount },\n    };\n    this.setState(newState);\n  };\n  render() {\n    console.log('App render');\n    return (\n      \u003cdiv\u003e\n        \u003cCounter counter={this.state.counter} /\u003e\n        \u003cinput ref={inst =\u003e (this.amount = inst)} /\u003e\n        \u003cbutton onClick={this.add}\u003e+\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n+class Counter extends PureComponent {\n  render() {\n    console.log('Counter render');\n    return \u003cp\u003e{this.props.counter.number}\u003c/p\u003e;\n  }\n};\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n### 2.3 PureComponent+Immutable.js\n- [immutable.js](https://immutable-js.github.io/immutable-js/) 是 Facebook 在 2014 年出的持久性数据结构的库\n- ```Immutable Data``` 就是一旦创建，就不能再被更改的数据。对 ```Immutable``` 对象的任何修改或添加\n删除操作都会返回一个新的 ```Immutable``` 对象\n- ```Immutable``` 实现的原理是 ```Persistent Data Structure``` （持久化数据结构），也就是使用旧数\n据创建新数据时，要保证旧数据同时可用且不变,同时为了避免 deepCopy 把所有节点都复制一遍\n带来的性能损耗\n- Immutable 使用了 ```Structural Sharing```（结构共享），即如果对象树中一个节点发生变化，只修改\n这个节点和受它影响的父节点，其它节点则进行共享\n\n### 2.4 immutable\n[immutable.js](https://immutable-js.github.io/immutable-js/) 内部实现了一套完整的 ```Persistent Data Structure```,还有很多易用的数据类型。像\n```Collection 、 List 、 Map 、 Set 、 Record 、 Seq```\n##### 2.4.1 安装\n```\ncnpm install immutable -S\n```\n##### 2.4.2 使用\n```\nlet { Map } = require(\"immutable\");\nconst map1 = Map({ a: { aa: 1 }, b: 2, c: 3 });\nconst map2 = map1.set('b', 50);\nconsole.log(map1 !== map2); // true\nconsole.log(map1.get('b')); // 2\nconsole.log(map2.get('b')); // 50\nconsole.log(map1.get('a') === map2.get('a')); // true\n```\n##### 2.4.3 重构\n```\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n+ import { Map,is } from \"immutable\";\nclass PureComponent extends Component {\n  shouldComponentUpdate(newProps) {\n    return !shallowEqual(this.props, newProps);\n  }\n}\nfunction shallowEqual(obj1, obj2) {\n    if (obj1 === obj2) {\n        return true;\n    }\n    if (typeof obj1 != \"object\" ||obj1 === null ||typeof obj2 != \"object\" ||obj2\n    === null) {\n        return false;\n    }\n    let keys1 = Object.keys(obj1);\n    let keys2 = Object.keys(obj2);\n    if (keys1.length != keys2.length) {\n        return false;\n    }\n    for (let key of keys1) {\n    + if (!obj2.hasOwnProperty(key) || !is(obj1[key],obj2[key])) {\n            return false;\n        }\n    }\n}\nreturn true;\n}\nclass App extends Component {\n  + state = { counter: Map({ number: 0 }) };\n  add = () =\u003e {\n    /**\n        let oldState = this.state;\n        let amount = parseInt(this.amount.value);\n        this.setState({counter:{ number: oldState.counter.number + amount }});\n    */\n    + this.state.counter =\n    this.state.counter.set(\n      'number',\n      this.state.counter.get('number') + parseInt(this.amount.value)\n    );\n    + this.setState(this.state);\n  };\n  render() {\n    console.log('App render');\n    return (\n      \u003cdiv\u003e\n        \u003cCounter counter={this.state.counter} /\u003e\n        \u003cinput ref={inst =\u003e (this.amount = inst)} /\u003e\n        \u003cbutton onClick={this.add}\u003e+\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\nclass Counter extends PureComponent {\n  render() {\n    console.log('Counter render');\n    return \u003cp\u003e{this.props.counter.number}\u003c/p\u003e;\n  }\n}\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n## 3. memo\n```React.memo()``` 是一个高阶函数，它与 ```React.PureComponent``` 类似，但是一个函数组件而非一个\n类\n### 3.1 memoization (memorization)方案\nmemoization (memorization)方案是一种将函数执行结果用变量缓存起来的方法\n当函数进行计算之前，先看缓存对象中是否有次计算结果，如果有，就直接从缓存对象中获取结果；如果没有，就进行计算，并将结果保存到缓存对象中\n\n### 3.2 优化\n```\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport { Map, is } from 'immutable';\nclass PureComponent extends Component {\n  isPureReactComponent = true;\n  shouldComponentUpdate(newProps, newState) {\n    return !shallowEqual(this.props, newProps);\n  }\n}\nclass App extends Component {\n  state = { title: '计数器', counter: Map({ number: 0 }) };\n  add = () =\u003e {\n    this.state.counter = this.state.counter.set(\n      'number',\n      this.state.counter.get('number') + parseInt(this.amount.value)\n    );\n    this.setState(this.state);\n  };\n  render() {\n    console.log('App render');\n    return (\n      \u003cdiv\u003e\n        {/* + \u003cTitle title={this.props.title}/\u003e */}\n        \u003cCounter counter={this.state.counter} /\u003e\n        \u003cinput ref={inst =\u003e (this.amount = inst)} /\u003e\n        \u003cbutton onClick={this.add}\u003e+\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n+function memo(Func){\n+ class Proxy extends PureComponent{\n+ render(){\n+ return \u003cFunc {...this.props}/\u003e\n+ }\n+ }\n+ return Proxy;\n+}\n+const Title = memo(props=\u003e{\n+ console.log('Title render');\n+ return \u003cp\u003e{props.title}\u003c/p\u003e;\n+});\nclass Counter extends PureComponent {\n  render() {\n    console.log('Counter render');\n    return \u003cp\u003e{this.props.counter.get('number')}\u003c/p\u003e;\n  }\n}\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\nfunction shallowEqual(obj1, obj2) {\n  if (obj1 === obj2) {\n    return true;\n  }\n  if (typeof obj1 != 'object' || obj1 === null || typeof obj2 != 'object' || obj2 === null) {\n    return false;\n  }\n  let keys1 = Object.keys(obj1);\n  let keys2 = Object.keys(obj2);\n  if (keys1.length != keys2.length) {\n    return false;\n  }\n  for (let key of keys1) {\n    if (!obj2.hasOwnProperty(key) || !is(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n```\n\n## 4. Lazy+Error Boundaries\n### 4.1 React.Lazy\n``` React.Lazy```帮助我们按需加载组件，从而减少我们应用程序的加载时间，因为只加载我们所需的组件。\n- ```React.lazy``` 接受一个函数，这个函数内部调用 ```import()``` 动态导入。它必须返回一个 ```Promise```，该```Promise``` 需要 ```resolve``` 一个 ```export default ``` 的 ```React``` 组件\n- ```React.Suspense``` 用于包装延迟组件以在加载组件时显示后备内容\n\n```\nimport React, { Component, Suspense } from 'react';\nimport ReactDOM from 'react-dom';\nimport Loading from './components/Loading';\nfunction lazy(loadFunction) {\n  return class LazyComponent extends React.Component {\n    state = { Comp: null };\n    componentDidMount() {\n      loadFunction().then(result =\u003e {\n        this.setState({ Comp: result.default });\n      });\n    }\n    render() {\n      let Comp = this.state.Comp;\n      return Comp ? \u003cComp {...this.props} /\u003e : null;\n    }\n  };\n}\nconst AppTitle = React.lazy(() =\u003e import(/* webpackChunkName: \"title\"\n*/ './components/Title'));\nclass App extends Component {\n  state = { visible: false };\n  show = () =\u003e {\n    this.setState({ visible: true });\n  };\n  render() {\n    return (\n      \u003c\u003e\n        {this.state.visible \u0026\u0026 (\n          \u003cSuspense fallback={\u003cLoading /\u003e}\u003e\n            \u003cAppTitle /\u003e\n          \u003c/Suspense\u003e\n        )}\n        \u003cbutton onClick={this.show}\u003e加载\u003c/button\u003e\n      \u003c/\u003e\n    );\n  }\n}\nReactDOM.render(\u003cApp /\u003e, document.querySelector('#root'));\n```\n\n### 4.2 错误边界(Error Boundaries)\n```\nimport React, { Component, Suspense } from 'react';\nimport ReactDOM from 'react-dom';\nimport Loading from './components/Loading';\n+ const AppTitle = React.lazy(()=\u003eimport(/* webpackChunkName: \"title\"\n*/'./components/Title'))\nclass App extends Component {\n  // + state = {visible:false,isError: false}\n  show = () =\u003e {\n    this.setState({ visible: true });\n  };\n  + static getDerivedStateFromError(error) {\n  + return { isError: true };\n  + }\n  + componentDidCatch (err, info) {\n  + console.log(err, info)\n  + }\n  render() {\n    if (this.state.isError) {\n      return \u003cdiv\u003eerror\u003c/div\u003e;\n    }\n    return (\n      \u003c\u003e\n        {this.state.visible \u0026\u0026 (\n          \u003cSuspense fallback={\u003cLoading /\u003e}\u003e\n            \u003cAppTitle /\u003e\n          \u003c/Suspense\u003e\n        )}\n        \u003cbutton onClick={this.show}\u003e加载\u003c/button\u003e\n      \u003c/\u003e\n    );\n  }\n}\nReactDOM.render(\u003cApp /\u003e, document.querySelector('#root'));\n```\n\n## 5. 骨架屏\nSkeleton Screen(骨架屏)就是在页面数据尚未加载前先给用户展示出页面的大致结构，直到请求数据返回后再渲染页面，补充进需要显示的数据内容。常用于文章列表、动态列表页。\n[react-content-loader](https://www.npmjs.com/package/react-content-loader) SVG-Powered component to easily create placeholder loadings\n[create-content-loader](http://danilowoz.com/create-content-loader/)\n[react-skeleton-webpack-plugin](https://github.com/lavas-project/react-skeleton-webpack-plugin) is a Webpack plugin based on React which generates\nSkeleton Screen for SPA\n\n```\ncnpm i @babel/core @babel/plugin-proposal-class-properties @babel/pluginproposal-decorators\n@babel/preset-env @babel/preset-react babel-loader html-webpack-plugin\nwebpack webpack-cli webpack-dev-server webpack-merge webpack-node-externals\nmemory-fs require-from-string react-content-loader react-router-dom\nprerender-spa-plugin react-lazyload react-window immutable -D\n\nnpx webpack --config webpack.skeleton.js\nnpx webpack\n```\n\n### 5.1 skeleton.js\nsrc\\skeleton.js\n```\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactDOMServer from 'react-dom/server';\nimport ContentLoader from 'react-content-loader';\nexport default ReactDOMServer.renderToStaticMarkup(\u003cContentLoade/\u003e)\n```\n### 5.2 index.js\nsrc\\index.js\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nlet style = { width: \"100%\", height: \"300px\", backgroundColor: \"orange\" };\nsetTimeout(() =\u003e {\nReactDOM.render(\u003cdiv style={style}\u003e\u003c/div\u003e, document.getElementById(\"root\"));\n}, 2000);\n```\n### 5.3 index.html\nsrc\\index.html\n```\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"UTF-8\"\u003e\n\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n\u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e\n\u003ctitle\u003eDocument\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv id=\"root\"\u003e\u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n### 5.4 webpack.base.js\n```\nconst path = require('path');\nmodule.exports = {\n  mode: 'development',\n  devtool: 'none',\n  context: process.cwd(),\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react'],\n            plugins: [\n              // @babel/plugin-proposal-decorators需要在@babel/plugin-proposal-class-properties之前  //  legacy: true -\u003e 推荐\n              ['@babel/plugin-proposal-decorators', { legacy: true }],\n              // babel编译时，对class的属性采用赋值表达式，而不是Object.defineProperty（更简洁）\n              ['@babel/plugin-proposal-class-properties', { loose: true }],\n            ],\n          },\n        },\n        include: path.join(__dirname, 'src'),\n        exclude: /node_modules/,\n      },\n    ],\n  },\n};\n```\n\n### 5.5 webpack.skeleton.js\n```\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nmemory-fs is a simple in-memory filesystem\nrequire-from-string Load module from string in Node.\nhtml - webpack - plugin;\nconst { smart } = require('webpack-merge');\nconst base = require('./webpack.base');\nconst nodeExternals = require('webpack-node-externals');\nmodule.exports = smart(base, {\n  target: 'node',\n  mode: 'development',\n  context: process.cwd(),\n  entry: './src/skeleton.js',\n  output: {\n    filename: 'skeleton.js',\n    libraryTarget: 'commonjs2',\n  },\n  // 这样做的目的就是将不怎么需要更新的第三方库脱离webpack打包，不被打入bundle中，从而减少打包时间，但又不影响运用第三方库的方式，例如import方式等。\n  externals: nodeExternals(),\n});\n```\n### 5.6 webpack.config.js\nwebpack.config.js\n[targets](https://webpack.docschina.org/concepts/targets/)\n\n```\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst { smart } = require('webpack-merge');\nconst base = require('./webpack.base');\nconst SkeletonWebpackPlugin = require('./SkeletonWebpackPlugin');\nmodule.exports = smart(base, {\n  mode: 'development',\n  context: process.cwd(),\n  entry: { main: './src/index.js' },\n  output: {\n    filename: 'main.js',\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './src/index.html', //指定模板文件\n      filename: 'index.html', //产出后的文件名\n    }),\n    new SkeletonWebpackPlugin({\n      webpackConfig: require('./webpack.skeleton'),\n    }),\n  ],\n});\n```\n### 5.7 SkeletonWebpackPlugin.js\nSkeletonWebpackPlugin.js\n\n- [memory-fs](https://www.npmjs.com/package/memory-fs) is a simple ```in-memory``` filesystem\n- [require-from-string](https://www.npmjs.com/package/require-from-string) Load module from string in Node.\n- [html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)\n\n```\nlet requireFromString = require('require-from-string');\nlet result = requireFromString('module.exports = \"hello\"');\nconsole.log(result); // hello\nlet webpack = require('webpack');\nlet path = require('path');\nlet MFS = require('memory-fs');\nvar requireFromString = require('require-from-string');\nlet mfs = new MFS();\nclass SkeletonPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n  apply(compiler) {\n    let { webpackConfig } = this.options;\n    compiler.hooks.compilation.tap('SkeletonPlugin', compilation =\u003e {\n      compilation.hooks.htmlWebpackPluginBeforeHtmlProcessing.tapAsync(\n        'SkeletonPlugin',\n        (htmlPluginData, callback) =\u003e {\n          let outputPath = path.join(webpackConfig.output.path, webpackConfig.output.filename);\n          let childCompiler = webpack(webpackConfig);\n          childCompiler.outputFileSystem = mfs;\n          childCompiler.run((err, stats) =\u003e {\n            let skeleton = mfs.readFileSync(outputPath, 'utf8');\n            let skeletonHtml = requireFromString(skeleton);\n            if (skeletonHtml.default) {\n              skeletonHtml = skeletonHtml.default;\n            }\n            htmlPluginData.html = htmlPluginData.html.replace(\n              `\u003cdiv id=\"root\"\u003e\u003c/div\u003e`,\n              `\u003cdiv id=\"root\"\u003e${skeletonHtml}\u003c/div\u003e`\n            );\n            callback(null, htmlPluginData);\n          });\n        }\n      );\n    });\n  }\n}\nmodule.exports = SkeletonPlugin;\n```\n\n## 6. 预渲染\n- 由于SPA项目普通的爬虫无法爬取项目的静态文本的内容，通过预渲染插件\n- [prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin)解决SPA项目的SEO问题\n```prerender-spa-plugin``` 利用了 Puppeteer 的爬取页面的功能。\n- ```Puppeteer``` 是一个 Chrome官方出品的 ```headless Chrome node``` 库。它提供了一系列的 API, 可\n以在无 UI 的情况下调用 Chrome 的功能, 适用于爬虫、自动化处理等各种场景\n- 原理是在 ```Webpack``` 构建阶段的最后，在本地启动一个 ```Puppeteer``` 的服务，访问配置了预渲染的\n路由，然后将 ```Puppeteer``` 中渲染的页面输出到 HTML 文件中，并建立路由对应的目录\n\n### 6.1 src\\index.js\nsrc\\index.js\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nlet Home = props =\u003e \u003cdiv\u003eHome\u003c/div\u003e;\nlet User = props =\u003e \u003cdiv\u003eUser\u003c/div\u003e;\nlet Profile = props =\u003e \u003cdiv\u003eProfile\u003c/div\u003e;\nReactDOM.render(\n  \u003cRouter\u003e\n    \u003c\u003e\n      \u003cLink to=\"/\"\u003ehome\u003c/Link\u003e\n      \u003cLink to=\"/user\"\u003euser\u003c/Link\u003e\n      \u003cLink to=\"/profile\"\u003eprofile\u003c/Link\u003e\n      \u003cRoute path=\"/\" exact={true} component={Home} /\u003e\n      \u003cRoute path=\"/user\" component={User} /\u003e\n      \u003cRoute path=\"/profile\" component={Profile} /\u003e\n    \u003c/\u003e\n  \u003c/Router\u003e,\n  document.getElementById(\"root\")\n);\n\n```\n\n### 6.2 src\\index.html\nsrc\\index.html\n\n```\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e\n    \u003ctitle\u003eDocument\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cdiv id=\"root\"\u003e\u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n### 6.3 webpack.config.js\nwebpack.config.js\n\n```\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst PrerenderSPAPlugin = require(\"./prerender-spa-plugin\");\nmodule.exports = {\n  mode: \"development\",\n  context: process.cwd(),\n  entry: \"./src/index.js\",\n  output: {\n    path: path.resolve(__dirname, \"dist\"),\n    filename: \"bundle.js\"\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?$/,\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\n            plugins: [\n              [\"@babel/plugin-proposal-decorators\", { legacy: true }],\n              [\"@babel/plugin-proposal-class-properties\", { loose: true }]\n            ]\n          }\n        },\n        include: path.join(__dirname, \"src\"),\n        exclude: /node_modules/\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"./src/index.html\", //指定模板文件\n      filename: \"index.html\" //产出后的文件名\n    }),\n    new PrerenderSPAPlugin({\n      staticDir: path.join(__dirname, \"dist\"),\n      routes: [\"/\", \"/user\", \"/profile\"]\n    })\n  ]\n};\n\n```\n\n### 6.4 prerender-spa-plugin.js\nprerender-spa-plugin.js\n\n```\nconst path = require(\"path\");\nconst Prerenderer = require(\"@prerenderer/prerenderer\");\nconst PuppeteerRenderer = require(\"@prerenderer/renderer-puppeteer\");\nclass PrerenderSPAPlugin {\n  constructor(options) {\n    this._options = options;\n    this._options.renderer = new PuppeteerRenderer({ headless: true });\n  }\n  apply(compiler) {\n    let _this = this;\n    const compilerFS = compiler.outputFileSystem;\n    const afterEmit = (compilation, done) =\u003e {\n      const PrerendererInstance = new Prerenderer(_this._options);\n      PrerendererInstance.initialize()\n        .then(() =\u003e {\n          return PrerendererInstance.renderRoutes(_this._options.routes || []);\n        })\n        .then(renderedRoutes =\u003e {\n          let promises = renderedRoutes.map(rendered =\u003e {\n            return new Promise(function(resolve) {\n              rendered.outputPath = path.join(\n                _this._options.staticDir,\n                rendered.route,\n                \"index.html\"\n              );\n              let dir = path.dirname(rendered.outputPath);\n              compilerFS.mkdirp(dir, (err, made) =\u003e {\n                compilerFS.writeFile(\n                  rendered.outputPath,\n                  rendered.html,\n                  err =\u003e {\n                    resolve();\n                  }\n                );\n              });\n            });\n          });\n          return Promise.all(promises);\n        })\n        .then(() =\u003e {\n          PrerendererInstance.destroy();\n          done();\n        });\n    };\n    compiler.hooks.afterEmit.tapAsync(\"PrerenderSPAPlugin\", afterEmit);\n  }\n}\nmodule.exports = PrerenderSPAPlugin;\n```\n\n## 7. 图片懒加载\n[react-lazyload](https://github.com/twobin/react-lazyload)\n[lazyimages.zip](http://img.zhufengpeixun.cn/lazyimages.zip)\n### 7.1 webpack.config.js\nwebpack.config.js\n\n```\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n  mode: \"development\",\n  context: process.cwd(),\n  entry: \"./src/index.js\",\n  output: {\n    path: path.resolve(__dirname, \"dist\"),\n    filename: \"bundle.js\"\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.jsx?$/,\n        use: {\n          loader: \"babel-loader\",\n          options: {\n            presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\n            plugins: [\n              [\"@babel/plugin-proposal-decorators\", { legacy: true }],\n              [\"@babel/plugin-proposal-class-properties\", { loose: true }]\n            ]\n          }\n        },\n        include: path.join(__dirname, \"src\"),\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.(jpg|png|gif)$/,\n        use: { loader: \"url-loader\", options: { limit: 0 } }\n      },\n      {\n        test: /\\.css$/,\n        use: [\"style-loader\", \"css-loader\"]\n      }\n    ]\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: \"./src/index.html\", //指定模板文件\n      filename: \"index.html\" //产出后的文件名\n    })\n  ]\n};\n```\n\u003e 不适合不同的用户看都会不同的页面，这种类型的页面不适用预渲染\n\u003e 对于一些经常发生变化的页面，如体育比赛等，会导致编译后的数据不是实时更新的\n\n### 7.2 index.js\nsrc\\index.js\n\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport LazyLoad from \"./react-lazyload\";\nconst App = props =\u003e {\n  return (\n    \u003cul className=\"list\" style={{ overflow: \"auto\" }}\u003e\n      {props.images.map((image, index) =\u003e (\n        \u003cLazyLoad key={index} height={200}\u003e\n          \u003cli\u003e\n            {\" \"}\n            \u003cimg src={image} /\u003e\n          \u003c/li\u003e\n        \u003c/LazyLoad\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n};\nlet images = [\n  require(\"./images/1.jpg\"),\n  require(\"./images/2.jpg\"),\n  require(\"./images/3.jpg\"),\n  require(\"./images/4.jpg\"),\n  require(\"./images/5.jpg\"),\n  require(\"./images/6.jpg\"),\n  require(\"./images/7.jpg\"),\n  require(\"./images/8.jpg\")\n];\nReactDOM.render(\u003cApp images={images} /\u003e, document.getElementById(\"root\"));\n```\n\n### 7.3 index.css\nsrc\\index.css\n\n```\n*{\n    margin: 0;\n    padding: 0;\n}\nul,li{\n    list-style: none;\n}\nli img{\n    width:100%;\n    height:100%;\n}\n```\n### 7.4 react-lazyload.js\n- [getBoundingClientRect](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)返回值是一个 DOMRect 对象，这个对象是由该元素的\n```getClientRects()``` 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合\n- DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像\n素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的\n\nsrc\\react-lazyload.js\n\n```\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nlet listeners = [];\nlet lazyLoadHandler = () =\u003e {\n  for (var i = 0; i \u003c listeners.length; ++i) {\n    var listener = listeners[i];\n    checkVisible(listener);\n  }\n};\nlet checkVisible = component =\u003e {\n  let node = ReactDOM.findDOMNode(component);\n  let { top } = node.getBoundingClientRect();\n  let visible =\n    top \u003c= (window.innerHeight || document.documentElement.clientHeight);\n  if (visible) {\n    listeners = listeners.filter(item =\u003e item != component);\n    component.setState({ visible });\n  }\n};\nclass LazyLoad extends React.Component {\n  state = { visible: false };\n  constructor(props) {\n    super(props);\n    this.divRef = React.createRef();\n  }\n  componentDidMount() {\n    if (listeners.length == 0) {\n      window.addEventListener(\"scroll\", lazyLoadHandler);\n    }\n    listeners.push(this);\n    checkVisible(this);\n  }\n  render() {\n    return this.state.visible ? (\n      this.props.children\n    ) : (\n      \u003cdiv\n        style={{ height: this.props.height }}\n        className=\"lazyload-placeholder\"\n        ref={this.divRef}\n      /\u003e\n    );\n  }\n}\nexport default LazyLoad;\n```\n\n## 8. 长列表优化\n- 用数组保存所有列表元素的位置，只渲染可视区内的列表元素，当可视区滚动时，根据滚动的\noffset大小以及所有列表元素的位置，计算在可视区应该渲染哪些元素\n- [react-window](https://www.npmjs.com/package/react-window)\n- [fixed-size](https://react-window.now.sh/#/examples/list/fixed-size)\n- [react-virtualized](https://www.npmjs.com/package/react-virtualized)\n### 8.1 index.js\nindex.js\n\n```\nimport React, { Component, lazy, Suspense } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { FixedSizeList as List } from \"./react-window\";\nimport \"./index.css\";\nconst Row = ({ index, style }) =\u003e {\n  return (\n    \u003cdiv\n      key={index}\n      style={{\n        ...style,\n        backgroundColor: getRandomColor(),\n        lineHeight: \"30px\",\n        textAlign: \"center\"\n      }}\n    \u003e\n      Row {index + 1}\n    \u003c/div\u003e\n  );\n};\nconst Container = () =\u003e (\n  \u003cList height={150} itemCount={100} itemSize={30} width={\"100%\"}\u003e\n    {Row}\n  \u003c/List\u003e\n);\nReactDOM.render(\u003cContainer /\u003e, document.querySelector(\"#root\"));\nfunction getRandomColor() {\n  var rand = Math.floor(Math.random() * 0xffffff)\n    .toString(16)\n    .toUpperCase();\n  if (rand.length == 6) {\n    return \"#\" + rand;\n  } else {\n    return getRandomColor();\n  }\n}\n```\n### 8.2 index.css\nindex.css\n\n```\n*{\n    margin: 0;\n    padding: 0;\n}\nul,li{\n    list-style: none;\n}\n```\n\n### 8.3 react-window.js\nreact-window.js\n\n```\nimport React, { Component } from \"react\";\nexport class FixedSizeList extends React.Component {\n  state = { start: 0 };\n  constructor() {\n    super();\n    this.containerRef = React.createRef();\n  }\n  componentDidMount() {\n    this.containerRef.current.addEventListener(\"scroll\", () =\u003e {\n      let scrollTop = this.containerRef.current.scrollTop;\n      let start = Math.floor(scrollTop / this.props.itemSize); //起始的索引\n      this.setState({ start });\n    });\n  }\n  render() {\n    let { width, height, itemCount, itemSize } = this.props;\n    let children = [];\n    let size = Math.floor(height / itemSize) + 1; //每页的条数\n    let itemStyle = {\n      height: itemSize,\n      width: \"100%\",\n      position: \"absolute\",\n      left: 0,\n      top: 0\n    };\n    for (\n      let index = this.state.start;\n      index \u003c this.state.start + size;\n      index++\n    ) {\n      let style = { ...itemStyle, top: index * itemSize };\n      children.push(this.props.children({ index, style }));\n    }\n    let containerStyle = {\n      height,\n      width: width || \"100%\",\n      position: \"relative\",\n      overflow: \"auto\"\n    };\n    return (\n      \u003cdiv style={containerStyle} ref={this.containerRef}\u003e\n        \u003cdiv style={{ width: \"100%\", height: itemSize * itemCount }}\u003e\n          {children}\n        \u003c/div\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n## 9. key的优化\n### 9.1 diff策略\n- DOM节点跨节点层级移动可以忽略\n- 相同类型的组件生成相似的结构，不同类型的组件生成不同的结构\n- 对于同一层次的子节点可以通过唯一的key进行区分\n### 9.2 tree diff\n- 对树进行分层比较，两棵树只会对同一层次节点进行比较\n- 当出现跨层级移动时，并不会出现移动操作，而是直接删除重建\n### 9.3 组件diff\n- 如果是同一个类型的组件，会向下继续比较子节点\n- 如果类型不同，则替换组件下的所有子节点\n### 9.4 element diff\n当节点处于同一层级时， ```React diff``` 提供了三种节点操作,分别为：INSERT(插入)、MOVE(移动)和\nREMOVE(删除)\n- **INSERT**: 新的 ```component``` 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作\n- **MOVE**: 在老集合有新 ```component``` 类型，就需要做移动操作，可以复用以前的 DOM 节点\n- **REMOVE**: 老 ```component``` 不在新集合里的，也需要执行删除操作\n\n## 10. React 性能分析器\n- [introducing-the-react-profiler](http://react.html.cn/blog/2018/09/10/introducing-the-react-profiler.html)\n- React 16.5 增加了对新的开发者工具 DevTools 性能分析插件的支持\n- 此插件使用 React 实验性的 Profiler API 来收集有关每个组件渲染的用时信息，以便识别 React 应\n用程序中的性能瓶颈\n\n### 10.1 分析解析\n- 分析一个应用程序的性能（Profiling an application）\n- 查看性能数据(render(渲染)阶段和commit(提交)阶段)\n- 过滤 commits（Filtering commits）\n- 火焰图表（Flame chart）\n- 排序图表（Ranked chart）\n- 组件图表（Component chart）\n- 交互（Interactions）\n\n### 10.2 react-flame-graph\n[react-flame-graph](https://github.com/bvaughn/react-flame-graph)是用来可视化性能数据的React组件\n[火焰图（flame graph）性能分析器](https://blog.csdn.net/qq_25072517/article/details/78433756)\n\n\n","like_users":[],"create_time":{"$date":"2019-10-03T13:59:41.209Z"},"update_time":{"$date":"2019-10-03T13:59:41.209Z"},"id":5,"__v":0}
{"_id":{"$oid":"5d98168f6838f30030f94215"},"meta":{"views":33,"likes":0,"comments":0},"keyword":["node egg mongodb"],"desc":"基于 node egg mongodb 的 blog-node-egg 项目文档说明","numbers":"8841","img_url":"http://img.golderbrother.cn/egg-logo.svg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5d9816ac6838f30030f94216"}],"comments":[],"category":[{"$oid":"5d9817026838f30030f94217"}],"title":"基于 node egg mongodb 的 blog-node-egg 项目文档说明","author":"golderBrother","content":"基于 node egg mongodb 的 blog-node-egg 项目文档说明\n\n## 前言\n本文讲解的是：做为前端开发人员，对服务器的了解还是小白的我，是如何一步步将 node+mongodb 项目部署在阿里云 centos 7.3 的服务器上，并进行性能优化，达到页面 1 秒内看到 loading ，3 秒内看到首屏内容的。\n\n搭建的项目是采用了主流的前后端分离思想的，这里只讲 **服务器环境搭建与性能优化**。\n\n效果请看 https://www.golderbrother.cn\n\n## 1. 流程\n- 开发好前端与后端程序。\n- 购买服务器与域名\n- 服务器上安装所需环境（本项目是 node 和 mongodb ）\n- 服务器上开放端口与设置规则\n- 用 nginx、apache 或者tomcat 来提供HTTP服务或者设置代理\n- 上传项目代码 或者 用码云或者 gihub 来拉取你的代码到服务器上\n- 启动 egg 服务\n- 优化页面加载\n\n## 2. 内容细节\n### 2.1 开发好前端与后端程序\n开发好前端与后端程序，这个没什么好说的，就是开发！开发！开发！再开发！\n\n2.2 购买服务器与域名\n本人一直觉得程序员应该有一个自己的个人网站，拥有自己的域名与服务器。学知识或者测试项目的时候可以用来测试。\n\n阿里云有个专供学生的云翼计划 阿里云学生套餐，入门级的云服务器原价1400多，学生认证后只要114一年，非常划算。\n\n还是学生的，直接购买；不是学生了，有弟弟、妹妹的，可以用他们的大学生身份，购买，非常便宜实用（我购买的就是学生优惠套餐）。当然阿里云服务器在每年双 11 时都有很大优惠，也很便宜，选什么配置与价格得看自己的用处。\n\n服务器预装环境可以选择 CentOS 或者 windows server，，为了体验和学习 linux 系统，我选择了CentOS。\n![image](http://img.golderbrother.cn/aliyun-ecs.png)\n\n再次是购买域名 [阿里域名购买](https://wanwang.aliyun.com/domain/yumingheji)，本人也是在阿里云购买的。域名是分 国际域名与国内域名的，国际域名是不用备案的，但是国内的域名是必须 ICP备案的 [阿里云ICP代备案管理系统](https://beian.aliyun.com/order/index.htm?spm=a3c00.7621333.a3c1z.1.2439nxagnxagjz)，不然不能用，如果是国内域名，如何备案域名，请自己上网查找教程。\n![image](http://img.golderbrother.cn/aliyun-domain.png)\n\n当然如果你的网站只用来自己用的话，可以不用买域名，因为可以通过服务器的公网 ip 来访问网站内容的。\n\n如果购买了域名了，还要设置域名映射到相应的公网 ip ，不然也不能用。\n![image](http://img.golderbrother.cn/dns-server.png)\n\n## 3. 服务器上安装所需环境（本项目是 node 和 mongodb ）\n### 3.1 登录服务器\n因本人用的是 win系统 ，所以用 Putty 或 Xshell 来登录，可以参考一下这篇文章 [把 Node.js 项目部署到阿里云服务器（CentOs）](https://segmentfault.com/a/1190000004051670)\n\nroot 是阿里云服务器默认的账号名，连接时候会叫你输入密码，输入你购买时设置的或者后来设置的密码。\n如图：\n![image](http://img.golderbrother.cn/xsheel-login.png)\n\n一般在新服务器创建后，建议先升级一下 CentOS：\n```\nyum -y update\n```\n\n常用的 Linux 命令\n```\ncd 进入目录\ncd .. 返回上一个目录\nls -a 查看当前目录\nmkdir abc 创建abc文件夹\nmv 移动或重命名\nrm 删除一个文件或者目录\n```\n3.2 安装 node\n升级常用库文件, 安装 node.js 需要通过 g++ 进行编译。\n```\nyum -y install gcc gcc-c++ autoconf\n```\n\n跳转到目录：/usr/local/src，这个文件夹通常用来存放软件源代码：\n```\ncd /usr/local/src\n```\n\n下载 node.js 源码，也可以使用 scp 命令直接上传，因为下载实在太慢了： 下载地址：[Downloads](https://nodejs.org/en/download/)，请下载最新的相应版本的源码进行下载，本人下载了 v12.13.0 版本的。\n\n![image](http://img.golderbrother.cn/node-download.png)\n```\nhttps://nodejs.org/dist/v12.13.0/node-v12.13.0.tar.gz\n```\n\n下载完成后解压：\n```\ntar -xzvf node-v12.13.0.tar.gz\n```\n\n进入解压后的文件夹：\n```\ncd node-v12.13.0\n```\n\n执行配置脚本来进行预编译处理：\n```\n./configure\n```\n\n编译源代码，这个步骤花的时间会很长，大概需要 5 到 10 分钟：\n```\nmake\n```\n\n编译完成后，执行安装命令，使之在系统范围内可用：\n```\nmake install\n```\n\n安装 egg 推荐 global 安装\n```\nnpm -g install egg\n```\n\n建立超级链接, 不然 sudo node 时会报 \"command not found\"\n```\nsudo ln -s /usr/local/bin/node /usr/bin/node\nsudo ln -s /usr/local/lib/node /usr/lib/node\nsudo ln -s /usr/local/bin/npm /usr/bin/npm\nsudo ln -s /usr/local/bin/node-waf /usr/bin/node-waf\n```\n\n通过指令查看 node 及 npm 版本：\n```\nnode -v\nnpm -v\n```\n\nnode.js 到这里就基本安装完成了。\n\n## 3.2 安装 mongodb\n下载地址：[mongodb](https://www.mongodb.com/download-center/community) 下载时，请选对相应的环境与版本，因为本人的服务器是 CentOS ，其实本质就是 linux 系统，所以选择了如下图环境与目前最新的版本\n![image](http://img.golderbrother.cn/mongodb-download.png)\n\nmongodb :\n```\n软件安装位置：/usr/local/mongodb\n数据存放位置：/home/mongodb/data\n数据备份位置：/home/mongodb/bak\n日志存放位置：/home/mongodb/logs\n```\n\n下载安装包\n```\n\u003e cd /usr/local\n\u003e wget https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-4.0.13-signed.msi\n```\n\n解压安装包，重命名文件夹为 mongodb\n```\ntar zxvf mongodb-linux-x86_64-4.0.4.tgz\nmv mongodb-linux-x86_64-4.0.4 mongodb\n```\n\n在 var 文件夹里建立 mongodb 文件夹，并分别建立文件夹 data 用于存放数据，logs 用于存放日志\n```\nmkdir /var/mongodb\nmkdir /var/mongodb/data\nmkdir /var/mongodb/logs\n```\n\n打开 rc.local 文件，添加 CentOS 开机启动项：\n```\nvim /etc/rc.d/rc.local\n```\n// 不懂 vim 操作的请自行查看相应的文档教程，比如： vim 模式下，要 按了 i 才能插入内容，输入完之后，要按 shift 加 :wq 才能保存退出。\n将 mongodb 启动命令追加到本文件中，让 mongodb 开机自启动：\n```\n/usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath /var/mongodb/logs/log.log -fork\n```\n\n启动 mongodb\n```\n/usr/local/mongodb/bin/mongod --dbpath=/var/mongodb/data --logpath /var/mongodb/logs/log.log -fork\n```\n看到如下信息说明已经安装完成并成功启动:\n```\nforked process: 18394\nall output going to: /var/mongodb/logs/log.log\n```\n\nmongodb 默认的端口号是 27017。\n\n如果你数据库的连接要账号和密码的，要创建数据库管理员，不然直接连接即可。 在 mongo shell 中创建管理员及数据库。\n\n切换到 admin 数据库，创建超级管理员帐号\n```\nuse admin\ndb.createUser({ user: \"用户名\", pwd:\"登陆密码\", roles:[{ role: \"userAdminAnyDatabase\", db: \"admin\" }] })\n```\n切换到要使用的数据库，如 taodb 数据库，创建这个数据库的管理员帐号\n\n```\nuse taodb\ndb.createUser({ user: \"用户名\", pwd:\"登陆密码\", roles:[ { role: \"readWrite\", db: \"taodb\" }] //读写权限 })\n```\n\n重复按两下 control+c ，退出 mongo shell。 到这里 mongodb 基本已经安装设置完成了。\n\n备份与恢复 请看这篇文章：[MongoDB 备份(mongodump)与恢复(mongorestore)](http://www.runoob.com/mongodb/mongodb-mongodump-mongorestore.html) 安装 node 与 mongodb 也可以参考这篇文章：[CentOs搭建NodeJs服务器—Mongodb安装](https://www.jianshu.com/p/5a104184e010)\n\n## 3.3 服务器上开放端口与设置安全组规则\n\u003e 如果你只放静态的网页，可以参考这个篇文章 [通过云虚拟主机控制台设置默认首页](https://help.aliyun.com/knowledge_detail/36154.html)\n\n但是我们是要部署后台程序的，所以要看以下的内容：\n\n安全组规则是什么鬼\n\n\u003e 授权安全组规则可以允许或者禁止与安全组相关联的 ECS 实例的公网和内网的入方向和出方向的访问。[ 阿里云安全组应用案例文档](https://help.aliyun.com/document_detail/25475.html)\n\n\u003e 80 端口是为 HTTP(HyperText Transport Protocol) 即超文本传输协议开放的,浏览器 HTTP 访问 IP 或域名的 80 端口时,可以省略 80 端口号\n\n如果我们没有开放相应的端口，\n\n比如我们的服务要用到 3000 ，就要开放 3000 的端口，不然是访问不了的；其他端口同理。\n\n![image](http://img.golderbrother.cn/ecs-safe-group.png)\n\n端口都配置对了，以为能用公网 IP 进行访问了么 ? 小兄弟你太天真了 ...\n\n![image](http://img.golderbrother.cn/cat-unknown.jpg)\n\n还有 防火墙 这一关呢，如果防火墙没有关闭或者相关的端口没有开放，也是不能用公网 IP 进行访问网站内容的。\n\n和安全组端口同理，比如我们的服务要用到的是 3000 端口，就要开放 3000 的端口，不然是访问不了的；其他端口同理。\n\n出于安全考虑还是把防火墙开上，只开放相应的端口最好。\n\n怎么开放相应的端口 ？ 看下面两篇文章足矣，这里就不展开了。\n\n\u003e [1. 将nodejs项目部署到阿里云ESC服务器,linux系统配置80端口,实现公网IP访问](https://blog.csdn.net/putao2062/article/details/79688020)\n\n\u003e [2. centos出现“FirewallD is not running”怎么办](https://blog.csdn.net/qq_21508727/article/details/80071174)\n\n开启 nginx 代理\n\n- 进入到目录位置\n```\ncd /usr/local/nginx\n```\n- 在 nginx 目录下有一个 sbin 目录，sbin 目录下有一个 nginx 可执行程序。\n```\n./nginx\n```\n- 关闭 nginx\n```\n./nginx -s stop\n```\n- 重启\n```\n./nginx -s reload\n```\n基本的使用就是这样子了。\n\n**如下给出我的 nginx 代理的设置**：\n\n我的两个项目是放在 /usr/share/nginx/html/blog-react; 和 /usr/share/nginx/html/blog-react-admin; 下的，如果你们的路径不是这个，请修改成你们的路径。\n\n```\n# 前端(前台)展示打开的服务代理\nserver {\n    listen 80;\n    # 服务端地址，后面可以改成域名\n    server_name localhost;\n    # 静态资源会走这个\n    location / {\n        # 根目录\n        root /usr/share/nginx/html/blog-react;\n        # 默认文件\n        index index.html index.htm;\n        # 尝试寻找的文件\n        # try_files $uri $uri/ /index.html;\n        try_files $uri $uri/ @router;\n        autoindex on;\n        expires 7d; # 缓存 7 天\n    }\n    # 因为进入到文章详情时或者前端路由变化了，再刷新浏览器，发现浏览器出现 404 。刷新页面时访问的资源在服务端找不到，因为 react-router 设置的路径不是真实存在的路径。 所以那样设置是为了可以刷新还可以打到对应的路径的。\n    location @router{\n        rewrite ^.*$ /index.html last;\n    }\n    # 接口地址会走这个\n    location /api/ {\n        # proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。\n        proxy_set_header X-Real-IP $remote_addr;\n        # 代理的地址 /api -\u003e http://116.62.6.228:6100\n        # proxy_pass http://127.0.0.1:6100;\n        proxy_pass  http://116.62.6.228:6100/;\n    }\n\n    xxx\n```\n\n我是开了两个代理的：前台展示打开的服务代理和管理后台打开的服务代理，这个项目是分开端口访问的。 比如：我的公网 ip 是 47.106.20.666，那么可以通过 http://47.106.20.666 即可访问前台展示，http://47.106.20.666:4444 即可访问管理后台的登录界面。\n\n至于为什么要写这样的配置:\n```\ntry_files $uri $uri/ @router;\n\nlocation @router{\n        rewrite ^.*$ /index.html last;\n    }\n```\n因为进入到文章详情时或者前端路由变化了，再刷新浏览器，发现浏览器出现 404 。刷新页面时访问的资源在服务端找不到，因为 react-router 设置的路径不是真实存在的路径。 所以那样设置是为了可以刷新还可以打到对应的路径的。\n\n刷新出现 404 问题，可以看下这篇文章 [react,vue等部署单页面项目时,访问刷新出现404问题](https://www.jianshu.com/p/b4f004bb8b66)\n\n### 3.5 上传项目代码，或者用码云、 gihub 来拉取你的代码到服务器上\n我是创建了[github](https://github.com/GolderBrother) 来管理项目代码的，因为码云上可以创建免费的私有仓库，我在本地把码上传到 github.com 上，再进入服务器用 git 把代码拉取下来就可以了，非常方便。\n\n具体请看：\ngit 的安装请看： [CentOS 7.4 系统安装 git](https://www.cnblogs.com/hglibin/p/8627975.html)\n码云的请看：[码云（Gitee.com）帮助文档 V1.2](http://git.mydoc.io/?t=180676)\n\n如果不想用 git 进行代码管理，请用其他可以连接服务器上传文件的软件，比如 FileZilla。\n\n### 3.6 启动 egg 服务\n启动 egg 服务，我用了 pm2， 可以永久运行在服务器上，且不会一报错 express 服务就挂了，而且运行中还可以进行其他操作。\n\n安装：\n```\nnpm install -g pm2\n```\n\n切换当前工作目录到 express 应用文件夹下,执行 pm2 命令启动 express 服务：\n```\nnpm run dev\n```\n比如我操作项目时的基本操作：\n```\ncd /usr/projects/blog/blog-node-egg\npm2 start ./bin/www // 开启\npm2 stop ./bin/www // 关闭\npm2 list //查看所用已启动项目：\n```\n\n### 3.7 页面加载优化\n再看刚刚的 nginx 的一些配置：\n```\nserver {\n        gzip on;\n        gzip_buffers 32 4k;\n        gzip_comp_level 6;\n        gzip_min_length 200;\n        gzip_types text/css text/xml application/javascript;\n        gzip_vary on;\n    }\n```\n这个就是利用 nginx 开启 gzip，亲测开启之后,压缩了接近 2/3 的文件大小，本来要 1M 多的文件，开启压缩之后，变成了 300k 左右。\n\n还有其他的优化请看这篇文章 [React 16 加载性能优化指南](https://blog.csdn.net/xiaoguang44/article/details/80436952)，写的很不错，我的一些优化都是参考了这个篇文章的。\n\n做完一系列的优化处理之后，在网络正常的情况下，页面首屏渲染由本来是接近 5 秒，变成了 3 秒内，首屏渲染之前的 loading 在 1 秒内可见了。\n\n## 4. 项目地址\n### 本人的个人博客项目地址：\n\n\u003e [前台展示: https://github.com/GolderBrother/blog-react](https://github.com/GolderBrother/blog-react)\n\n\u003e [管理后台：https://github.com/GolderBrother/blog-react-admin](https://github.com/GolderBrother/blog-react-admin)\n\n\u003e [后端：https://github.com/GolderBrother/blog-node-egg](https://github.com/GolderBrother/blog-node-egg)\n\n","like_users":[],"create_time":{"$date":"2019-10-05T04:05:35.141Z"},"update_time":{"$date":"2019-10-05T04:05:35.141Z"},"id":6,"__v":0}
{"_id":{"$oid":"5d9de18255bcb9003009ed80"},"meta":{"views":12,"likes":0,"comments":0},"keyword":["TypeScript"],"desc":"JavaScript的超集。                         TypeScript是JavaScript类型的超集，它可以编译成纯JavaScript。                         TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。","numbers":"11489","img_url":"http://img.golderbrother.cn/typescript-logo.jpg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5d9de00955bcb9003009ed7e"}],"comments":[],"category":[{"$oid":"5d9de03455bcb9003009ed7f"}],"title":"TypeScript 技巧拾遗","author":"golderBrother","content":"### 前言\n\n很早以前就尝试过使用 TypeScript 来进行日常编码，但自己对静态类型语言的了解并不深入，再加上 TypeScript 的类型系统有着一定的复杂度，因此感觉自己并没有发挥好这门语言的优势，使代码变得更具可读性与可维护性。于是这几天便想着好好研究下这门语言，希望能够总结出一些特别的语言特性与实用技巧。\n\n### 操作符\n\ntypeof - 获取变量的类型\n\n```\nconst colors = {\n  red: 'red',\n  blue: 'blue'\n}\n\n// type res = { red: string; blue: string }\ntype res = typeof colors\n```\n\nkeyof - 获取类型的键\n\n```\nconst data = {\n  a: 3,\n  hello: 'world'\n}\n\n// 类型保护\nfunction get\u003cT extends object, K extends keyof T\u003e(o: T, name: K): T[K] {\n  return o[name]\n}\n\nget(data, 'a') // 3\nget(data, 'b') // Error\n```\n\n组合 typeof 与 keyof - 捕获键的名称\n\n```\nconst colors = {\n  red: 'red',\n  blue: 'blue'\n}\n\ntype Colors = keyof typeof colors\n\nlet color: Colors // 'red' | 'blue'\ncolor = 'red' // ok\ncolor = 'blue' // ok\ncolor = 'anythingElse' // Error\n```\n\nin - 遍历键名\n\n```\ninterface Square {\n  kind: 'square'\n  size: number\n}\n\n// type res = (radius: number) =\u003e { kind: 'square'; size: number }\ntype res = (radius: number) =\u003e { [T in keyof Square]: Square[T] }\n```\n\n### 特殊类型\n嵌套接口类型\n\n```\ninterface Producer {\n  name: string\n  cost: number\n  production: number\n}\n\ninterface Province {\n  name: string\n  demand: number\n  price: number\n  producers: Producer[]\n}\n\nlet data: Province = {\n  name: 'Asia',\n  demand: 30,\n  price: 20,\n  producers: [\n    { name: 'Byzantium', cost: 10, production: 9 },\n    { name: 'Attalia', cost: 12, production: 10 },\n    { name: 'Sinope', cost: 10, production: 6 }\n  ]\n}\ninterface Play {\n  name: string\n  type: string\n}\n\ninterface Plays {\n  [key: string]: Play\n}\n\nlet plays: Plays = {\n  'hamlet': { name: 'Hamlet', type: 'tragedy' },\n  'as-like': { name: 'As You Like It', type: 'comedy' },\n  'othello': { name: 'Othello', type: 'tragedy' }\n}\n```\n\n条件类型\n\n```\ntype isBool\u003cT\u003e = T extends boolean ? true : false\n\n// type t1 = false\ntype t1 = isBool\u003cnumber\u003e\n\n// type t2 = true\ntype t2 = isBool\u003cfalse\u003e\n```\n\n字典类型\n\n```\ninterface Dictionary\u003cT\u003e {\n  [index: string]: T\n}\n\nconst data: Dictionary\u003cnumber\u003e = {\n  a: 3,\n  b: 4,\n}\n```\n\ninfer - 延迟推断类型\n```\ntype ParamType\u003cT\u003e = T extends (param: infer P) =\u003e any ? P : T\n\ninterface User {\n  name: string\n  age: number\n}\n\ntype Func = (user: User) =\u003e void\n\ntype Param = ParamType\u003cFunc\u003e // Param = User\ntype AA = ParamType\u003cstring\u003e // string\ntype ElementOf\u003cT\u003e = T extends Array\u003cinfer E\u003e ? E : never\n\ntype TTuple = [string, number]\n\ntype ToUnion = ElementOf\u003cTTuple\u003e // string | number\n```\n\n使用 const enum 维护常量列表\n\n```\nconst enum STATUS {\n  TODO = 'TODO',\n  DONE = 'DONE',\n  DOING = 'DOING'\n}\n\nfunction todos(status: STATUS): Todo[] {\n  // ...\n}\n\ntodos(STATUS.TODO)\n\n```\n\nPartial \u0026 Pick\n\n```\ntype Partial\u003cT\u003e = {\n  [P in keyof T]?: T[P]\n}\n\ntype Pick\u003cT, K extends keyof T\u003e = {\n  [P in K]: T[P]\n}\n\ninterface User {\n  id: number\n  age: number\n  name: string\n}\n\n// type PartialUser = { id?: number; age?: number; name?: string }\ntype PartialUser = Partial\u003cUser\u003e\n\n// type PickUser = { id: number; age: number }\ntype PickUser = Pick\u003cUser, 'id'|'age'\u003e\n```\n\nExclude \u0026 Omit\n\n```\ntype Exclude\u003cT, U\u003e = T extends U ? never : T\n\n// type A = 'a'\ntype A = Exclude\u003c'x' | 'a', 'x' | 'y' | 'z'\u003e\ntype Omit\u003cT, K extends keyof any\u003e = Pick\u003cT, Exclude\u003ckeyof T, K\u003e\u003e\n\ninterface User {\n  id: number\n  age: number\n  name: string\n}\n\n// type PickUser = { age: number; name: string }\ntype OmitUser = Omit\u003cUser, 'id'\u003e\n```\n\n巧用 never 类型\n\n```\ntype FunctionPropertyNames\u003cT\u003e = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]\n\ntype NonFunctionPropertyNames\u003cT\u003e = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T]\n\ninterface Part {\n  id: number\n  name: string\n  subparts: Part[]\n  updatePart(newName: string): void\n}\n\ntype T40 = FunctionPropertyNames\u003cPart\u003e  // 'updatePart'\ntype T41 = NonFunctionPropertyNames\u003cPart\u003e  // 'id' | 'name' | 'subparts'\n```\n\n混合类 ( mixins )\n\n```\n// 所有 mixins 都需要\ntype Constructor\u003cT = {}\u003e = new (...args: any[]) =\u003e T\n\n// 添加属性的混合例子\nfunction TimesTamped\u003cTBase extends Constructor\u003e(Base: TBase) {\n  return class extends Base {\n    timestamp = Date.now()\n  }\n}\n\n// 添加属性和方法的混合例子\nfunction Activatable\u003cTBase extends Constructor\u003e(Base: TBase) {\n  return class extends Base {\n    isActivated = false\n    activate() {\n      this.isActivated = true\n    }\n    deactivate() {\n      this.isActivated = false\n    }\n  }\n}\n\n// 简单的类\nclass User {\n  name = ''\n}\n\n// 添加 TimesTamped 的 User\nconst TimestampedUser = TimesTamped(User)\n\n// 添加 TimesTamped 和 Activatable 的类\nconst TimestampedActivatableUser = TimesTamped(Activatable(User))\n\n// 使用组合类\nconst timestampedUserExample = new TimestampedUser()\nconsole.log(timestampedUserExample.timestamp)\n\nconst timestampedActivatableUserExample = new TimestampedActivatableUser()\nconsole.log(timestampedActivatableUserExample.timestamp)\nconsole.log(timestampedActivatableUserExample.isActivated)\n```\n\n### 控制反转与依赖注入\n控制反转 ( Inversion of Control ) 与依赖注入 ( Dependency Injection ) 是面向对象编程中十分重要的思想和法则。维基百科上给出的解释是 IoC 能够降低计算机代码之间的耦合度，DI 代表的则是在一个对象被创建时，注入该对象所依赖的所有对象的过程。前端框架 Angular 与基于 Node.js 的后端框架 Nest 都引用了这一思想。对于这两个概念的具体阐述在这里就不再展开，但读者可以看看这两篇文章 [1] [2] 。下面我们基于 Angular 5 以前的 Dependency Injection 来实现简版的控制反转与依赖注入。\n\n首先让我们来编写一段相关的测试代码：\n\n```\nimport { expect } from 'chai'\nimport { Injectable, createInjector } from './injection'\n\nclass Engine {}\n\nclass DashboardSoftware {}\n\n@Injectable()\nclass Dashboard {\n  constructor(public software: DashboardSoftware) {}\n}\n\n@Injectable()\nclass Car {\n  constructor(public engine: Engine) {}\n}\n\n@Injectable()\nclass CarWithDashboard {\n  constructor(public engine: Engine, public dashboard: Dashboard) {}\n}\n\nclass NoAnnotations {\n  constructor(_secretDependency: any) {}\n}\n\ndescribe('injector', () =\u003e {\n  it('should instantiate a class without dependencies', () =\u003e {\n    const injector = createInjector([Engine])\n    const engine = injector.get(Engine)\n    expect(engine instanceof Engine).to.be.true\n  })\n\n  it('should resolve dependencies based on type information', () =\u003e {\n    const injector = createInjector([Engine, Car])\n    const car = injector.get(Car)\n    expect(car instanceof Car).to.be.true\n    expect(car.engine instanceof Engine).to.be.true\n  })\n\n  it('should resolve nested dependencies based on type information', () =\u003e {\n    const injector = createInjector([CarWithDashboard, Engine, Dashboard, DashboardSoftware])\n    const _CarWithDashboard = injector.get(CarWithDashboard)\n    expect(_CarWithDashboard.dashboard.software instanceof DashboardSoftware).to.be.true\n  })\n\n  it('should cache instances', () =\u003e {\n    const injector = createInjector([Engine])\n    const e1 = injector.get(Engine)\n    const e2 = injector.get(Engine)\n    expect(e1).to.equal(e2)\n  })\n\n  it('should show the full path when no provider', () =\u003e {\n    const injector = createInjector([CarWithDashboard, Engine, Dashboard])\n    expect(() =\u003e injector.get(CarWithDashboard)).to.throw('No provider for DashboardSoftware!')\n  })\n\n  it('should throw when no type', () =\u003e {\n    expect(() =\u003e createInjector([NoAnnotations])).to.throw(\n      'Make sure that NoAnnotations is decorated with Injectable.'\n    )\n  })\n\n  it('should throw when no provider defined', () =\u003e {\n    const injector = createInjector([])\n    expect(() =\u003e injector.get('NonExisting')).to.throw('No provider for NonExisting!')\n  })\n})\n```\n可以看到我们要实现的核心功能有三个：\n\n- 根据提供的类创建 IoC 容器并且能够管理类之间的依赖关系\n\n- 在通过 IoC 容器获取类的实例对象时注入相关的依赖对象\n\n- 实现多级依赖与处理边缘情况\n\n首先来实现最简单的 ```@Injectable``` 装饰器：\n\n```\nexport const Injectable = (): ClassDecorator =\u003e target =\u003e {\n  Reflect.defineMetadata('Injectable', true, target)\n}\n```\n然后我们来实现根据提供的 provider 类创建能够管理类之间依赖关系的 IoC 容器：\n\n```\nabstract class ReflectiveInjector implements Injector {\n  abstract get(token: any): any\n  static resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return providers.map(resolveReflectiveProvider)\n  }\n  static fromResolvedProviders(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    return new ReflectiveInjector_(providers)\n  }\n  static resolveAndCreate(providers: Provider[]): ReflectiveInjector {\n    const resolvedReflectiveProviders = ReflectiveInjector.resolve(providers)\n    return ReflectiveInjector.fromResolvedProviders(resolvedReflectiveProviders)\n  }\n}\n\nclass ReflectiveInjector_ implements ReflectiveInjector {\n  _providers: ResolvedReflectiveProvider[]\n  keyIds: number[]\n  objs: any[]\n  constructor(_providers: ResolvedReflectiveProvider[]) {\n    this._providers = _providers\n\n    const len = _providers.length\n\n    this.keyIds = new Array(len)\n    this.objs = new Array(len)\n\n    for (let i = 0; i \u003c len; i++) {\n      this.keyIds[i] = _providers[i].key.id\n      this.objs[i] = undefined\n    }\n  }\n  // ...\n}\n\nfunction resolveReflectiveProvider(provider: Provider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n    ReflectiveKey.get(provider),\n    resolveReflectiveFactory(provider)\n  )\n}\n\nfunction resolveReflectiveFactory(provider: Provider): ResolvedReflectiveFactory {\n  let factoryFn: Function\n  let resolvedDeps: ReflectiveDependency[]\n\n  factoryFn = factory(provider)\n  resolvedDeps = dependenciesFor(provider)\n\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps)\n}\n\nfunction factory\u003cT\u003e(t: Type\u003cT\u003e): (args: any[]) =\u003e T {\n  return (...args: any[]) =\u003e new t(...args)\n}\n\nfunction dependenciesFor(type: Type\u003cany\u003e): ReflectiveDependency[] {\n  const params = parameters(type)\n  return params.map(extractToken)\n}\n\nfunction parameters(type: Type\u003cany\u003e) {\n  if (noCtor(type)) return []\n\n  const isInjectable = Reflect.getMetadata('Injectable', type)\n  const res = Reflect.getMetadata('design:paramtypes', type)\n\n  if (!isInjectable) throw noAnnotationError(type)\n\n  return res ? res : []\n}\n\nexport const createInjector = (providers: Provider[]): ReflectiveInjector_ =\u003e {\n  return ReflectiveInjector.resolveAndCreate(providers) as ReflectiveInjector_\n}\n```\n\n从上面的代码不难看出当 IoC 容器创建时会将提供的每个类以及该类所依赖的其他类作为 ```ResolvedReflectiveProvider_``` 的实例对象存储在容器中，对外返回的则是容器对象 ```ReflectiveInjector_ ```。\n\n接下来让我们来实现通过 IoC 容器获取类的实例对象的逻辑：\n\n```\nclass ReflectiveInjector_ implements ReflectiveInjector {\n  // ...\n  get(token: any): any {\n    return this._getByKey(ReflectiveKey.get(token))\n  }\n  private _getByKey(key: ReflectiveKey, isDeps?: boolean) {\n    for (let i = 0; i \u003c this.keyIds.length; i++) {\n      if (this.keyIds[i] === key.id) {\n        if (this.objs[i] === undefined) {\n          this.objs[i] = this._new(this._providers[i])\n        }\n        return this.objs[i]\n      }\n    }\n\n    let res = isDeps ? (key.token as Type).name : key.token\n\n    throw noProviderError(res)\n  }\n  _new(provider: ResolvedReflectiveProvider) {\n    const resolvedReflectiveFactory = provider.resolvedFactory\n    const factory = resolvedReflectiveFactory.factory\n\n    let deps = resolvedReflectiveFactory.dependencies.map(dep =\u003e this._getByKey(dep.key, true))\n\n    return factory(...deps)\n  }\n}\n```\n\n可以看到当我们调用 ```injector.get()``` 方法时 IoC 容器会根据给定类查找对应的 ```ReflectiveInjector_``` 对象，找到之后便会在实例化给定类之前注入该类依赖的所有类的实例对象，最后再返回给定类的实例化对象。\n\n现在我们再回头看上文的代码，多级依赖的功能其实早已实现。虽然在初始化 loC 容器时我们只能找到某个类的相关依赖，无法再通过依赖类找到更深层级的依赖，但是我们对提供的每个类遍历执行了相同的操作，因此很自然的就实现了多个类之间的依赖。\n\n对于边缘情况我们也做了相应的处理，比如提供的 ```provider``` 类为空数组，类并没有被 ```@Injectable``` 装饰器修饰，提供的类并不完整等。对应上文的代码为：\n\n```\nlet res = isDeps ? (key.token as Type).name : key.token\n\nthrow noProviderError(res)\nif (!isInjectable) throw noAnnotationError(type)\n```\n至此，控制反转与依赖注入的核心功能就实现的差不多了，剩下的就是一些接口定义代码，还有就是 ```ReflectiveKey``` 类的实现，它的大致作用其实就是基于 ES6 中的 Map 存储 provider 类。感兴趣的读者可以看看完整的代码示例。\n\n### 欢迎关注公众号：**前端工匠**，你的成长我们一起见证！\n![前端工匠](http://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsOFttAqFmhpAp30fwBKP2wLDz457ER8dicibZKt5KLBxG1Vj7jQ5WBWYNxEGg5Igu88F0l8wcqIt2ibg/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1\u0026retryload=0)","like_users":[],"create_time":{"$date":"2019-10-09T13:32:50.411Z"},"update_time":{"$date":"2019-10-09T13:32:50.411Z"},"id":7,"__v":0}
{"_id":{"$oid":"5d9df58355bcb9003009ed85"},"meta":{"views":17,"likes":0,"comments":0},"keyword":["git"],"desc":"Git 常用命令总结,掌握这些,轻松驾驭版本管理","numbers":"731","img_url":"http://img.golderbrother.cn/git-logo@2x.png","type":1,"state":1,"origin":0,"tags":[{"$oid":"5d9df42455bcb9003009ed84"}],"comments":[],"category":[{"$oid":"5d9df41955bcb9003009ed83"}],"title":"Git 常用命令总结,掌握这些,轻松驾驭版本管理","author":"golderBrother","content":"Git是什么？\n\nGit是目前世界上最先进的分布式版本控制系统（没有之一）。\n\nGit有什么特点？简单来说就是：高端大气上档次！\n\n虽然之前用过Git，但是都是一些简单的推送提交，因此还是有必要进行一些系统的学习，这里做一下笔记，以备后询，且不定期更新。\n\n关于SVN和Git的比较已经有很多文章说过了，就不再赘述，本文的重点是如何使用常用的Git命令进行操作，冷门的就不说了，且比较零散，系统的学习推介廖雪峰的Git教程。\n\n## 1. 概览\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/XP4dRIhZqqUg3iagVYaVdIzkicEFCcianicsbY1P3iaa7oGyXWRjb6sQ99UIlh2HeWRmVwqyPIcZAFOeCSwOgpPZAFA/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n- 工作区 Workspace\n\n- 暂存区 Stage / Index\n\n- 本地仓库 Repository\n\n- 远程仓库 Remote\n\n## 2. 修改\n### 2.1 暂存修改\n操作一览\n\n| 操作 | bash |\n| ------ | ------ |\n| 创建stash | git stash |\n| 查看 | git stash list |\n| 应用 | git stash apply stash@{ ```\u003cnum\u003e``` } |\n| 删除 | git stash drop stash@{ \u003cnum\u003e} |\n| 还原上一个暂存并删除暂存(如无conflict)  | git stash pop |\n\n未完待续~~~","like_users":[],"create_time":{"$date":"2019-10-09T14:58:11.365Z"},"update_time":{"$date":"2019-10-09T14:58:11.365Z"},"id":8,"__v":0}
{"_id":{"$oid":"5da1ab2255bcb9003009ed89"},"meta":{"views":27,"likes":0,"comments":0},"keyword":["Vue"],"desc":"Vue 开发必须知道的 36 个技巧","numbers":"28377","img_url":"http://img.golderbrother.cn/vue-logo.png","type":1,"state":1,"origin":0,"tags":[{"$oid":"5da1aa7855bcb9003009ed87"}],"comments":[],"category":[{"$oid":"5da1aa6b55bcb9003009ed86"}],"title":"Vue 开发必须知道的 36 个技巧","author":"golderBrother","content":"# Vue 开发必须知道的 36 个技巧\n\n## 前言\n\nVue 3.x 的 Pre-Alpha 版本。后面应该还会有 Alpha、Beta 等版本,预计至少要等到 2020 年第一季度才有可能发布 3.0 正式版;\n所以应该趁还没出来加紧打好 Vue2.x 的基础;\nVue 基本用法很容易上手,但是有很多优化的写法你就不一定知道了,本文从列举了 36 个 vue 开发技巧;\n后续 Vue 3.x 出来后持续更新.\n\n## 1.require.context()\n\n### 1.场景:如页面需要导入多个组件,原始写法:\n\n```js\nimport titleCom from '@/components/home/titleCom';\nimport bannerCom from '@/components/home/bannerCom';\nimport cellCom from '@/components/home/cellCom';\ncomponents: {\n  titleCom, bannerCom, cellCom;\n}\n```\n\n### 2.这样就写了大量重复的代码,利用 require.context 可以写成\n\n```js\nconst path = require('path');\nconst files = require.context('@/components/home', false, /\\.vue$/);\nconst modules = {};\nfiles.keys().forEach(key =\u003e {\n  const name = path.basename(key, '.vue');\n  modules[name] = files(key).default || files(key);\n});\ncomponents: modules;\n```\n\n这样不管页面引入多少组件,都可以使用这个方法\n\n### 3.API 方法\n\n实际上是 webpack 的方法,vue 工程一般基于 webpack,所以可以使用\n\n```js\nrequire.context(directory, useSubdirectories, regExp);\n```\n\n接收三个参数:\n\n- `directory`：说明需要检索的目录\n- `useSubdirectories`：是否检索子目录\n- `regExp`: 匹配文件的正则表达式,一般是文件名\n\n## 2.watch\n\n### 2.1 常用用法\n\n1.场景:表格初始进来需要调查询接口 `getList()`,然后 `input` 改变会重新查询\n\n```js\ncreated(){\n  this.getList()\n},\nwatch: {\n  inpVal(){\n    this.getList()\n  }\n}\n```\n\n### 2.2 立即执行\n\n2.可以直接利用 `watch` 的 `immediate` 和 `handler` 属性简写\n\n```js\nwatch: {\n  inpVal:{\n    handler: 'getList',\n      immediate: true\n  }\n}\n```\n\n### 2.3 深度监听\n\n3.`watch` 的 `deep` 属性,深度监听,也就是监听复杂数据类型\n\n```js\nwatch:{\n  inpValObj:{\n    handler(newVal,oldVal){\n      console.log(newVal)\n      console.log(oldVal)\n    },\n    deep:true\n  }\n}\n```\n\n\u003e 此时发现 oldVal 和 newVal 值一样; 因为它们索引同一个对象/数组，指向同一个内存地址，Vue 不会保留修改之前值的副本; 所以深度监听虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化\n\n## 3. 14 种组件通讯\n\n### 3.1 props\n\n这个应该非常属性,就是父传子的属性; props 值可以是一个数组或对象;\n\n```js\n// 数组:不建议使用\nprops:[]\n\n// 对象\nprops:{\n inpVal:{\n  type:Number, //传入值限定类型\n  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol\n  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n  required: true, //是否必传\n  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=\u003e[]\n  validator:(value) {\n    // 这个值必须匹配下列字符串中的一个\n    return ['success', 'warning', 'danger'].indexOf(value) !== -1\n  }\n }\n}\n```\n\n### 3.2 \\$emit\n\n这个也应该非常常见,子组件发射事件，父组件监听事件,其实就是子传父的方法\n\n```\n// 父组件\n\u003chome @title=\"title\"\u003e\n// 子组件\nthis.$emit('title',[{title:'这是title'}])\n```\n\n### 3.3 vuex\n\n- 1.这个也是很常用的,vuex 是一个状态管理器\n- 2.是一个独立的插件,适合数据共享多的项目里面,因为如果只是简单的通讯,使用起来会比较重\n- 3.API\n\n- `state`:定义存贮数据的仓库 ,可通过 this.\\$store.state 或 mapState 访问\n- `getter`:获取 store 值,可认为是 store 的计算属性,可通过 this.\\$store.getter 或\n  `mapGetters` 访问\n- `mutation`:同步改变 store 值,为什么会设计成同步,因为 mutation 是直接改变 store 值,\n  vue 对操作进行了记录,如果是异步无法追踪改变.可通过 mapMutations 调用\n- `action`:异步调用函数执行 mutation,进而改变 store 值,可通过 this.\\$dispatch 或 mapActions\n  访问\n- `modules`:模块,如果状态过多,可以拆分成模块,最后在入口通过...解构引入\n\n### 3.4 `attrs` 和 `listeners`\n\n`2.4.0` 新增 这两个是不常用属性,但是高级用法很常见;\n\n#### 1.`attrs`\n\n场景:如果父传子有很多值,那么在子组件需要定义多个 props\n解决:attrs 获取父传子中,未在子组件 props 定义的值\n\n```js\n\n// 父组件\n\u003chome title=\"这是标题\" width=\"80\" height=\"80\" imgUrl=\"imgUrl\"/\u003e\n\n// 子组件\nmounted() {\n  console.log(this.\\$attrs) //{title: \"这是标题\", width: \"80\", height: \"80\", imgUrl: \"imgUrl\"}\n},\n\n```\n\n相对应的如果子组件定义了 props,打印的值就是剔除定义的属性\n\n```js\nprops: {\n  width: {\n    type: String,\n    default: ''\n  }\n},\nmounted() {\n// 这边就没有 width 属性了\nconsole.log(this.\\$attrs) //{title: \"这是标题\", height: \"80\", imgUrl: \"imgUrl\"}\n},\n\n```\n\n#### 2.`listeners`\n\n场景:子组件需要调用父组件的方法\n解决:父组件的方法可以通过 v-on=\"listeners\" 传入内部组件——在创建更高层次的组件时非常有用\n\n```js\n\n// 父组件\n\u003chome @change=\"change\"/\u003e\n\n// 子组件\nmounted() {\nconsole.log(this.\\$listeners) //即可拿到 change 事件\n}\n\n```\n\n如果是孙组件要访问父组件的属性和调用方法,直接一级一级传下去就可以\n\n#### 3.`inheritAttrs`\n\n```js\n\n// 父组件\n\u003chome title=\"这是标题\" width=\"80\" height=\"80\" imgUrl=\"imgUrl\"/\u003e\n\n// 子组件\nmounted() {\nconsole.log(this.\\$attrs) //{title: \"这是标题\", width: \"80\", height: \"80\", imgUrl: \"imgUrl\"}\n},\n\n```\n\n`inheritAttrs` 默认值为 true，true 的意思是将父组件中除了 props 外的属性添加到子组件的根节点上(说明，即使设置为 true，子组件仍然可以通过\\$attr 获取到 props 以外的属性)\n将 `inheritAttrs:fals`e 后,属性就不会显示在根节点上了\n\n### 3.5 `provide` 和 `inject`\n\n`2.2.0` 新增\n\n描述:\nprovide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中;\n并且这对选项需要一起使用;\n以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。\n\n```js\n\n//父组件:\nprovide: { //provide 是一个对象,提供一个属性或方法\n  foo: '这是 foo',\n  fooMethod:()=\u003e{\n    console.log('父组件 fooMethod 被调用')\n  }\n},\n\n// 子或者孙子组件\ninject: ['foo','fooMethod'], //数组或者对象,注入到子组件\nmounted() {\n  this.fooMethod()\n  console.log(this.foo)\n}\n//在父组件下面所有的子组件都可以利用 inject\n\n```\n\nprovide 和 inject 绑定并不是可响应的。这是官方刻意为之的。 然而，如果你传入了一个可监听的**对象**，那么其对象的属性还是可响应的,**对象是因为是引用类型**\n\n```js\n\n//父组件:\nprovide: {\n  foo: '这是 foo'\n},\nmounted(){\n  this.foo='这是新的 foo'\n}\n\n// 子或者孙子组件\ninject: ['foo'],\nmounted() {\n  console.log(this.foo) //子组件打印的还是'这是 foo'\n}\n\n```\n\n### 3.6 `parent` 和 `children`\n\nparent:父实例 children:子实例\n\n```js\n\n//父组件\nmounted(){\nconsole.log(this.\\$children)\n//可以拿到 一级子组件的属性和方法\n//所以就可以直接改变 data,或者调用 methods 方法\n}\n\n//子组件\nmounted(){\nconsole.log(this.\\$parent) //可以拿到 parent 的属性和方法\n}\n\n```\n\n\u003e children 和 parent 并不保证顺序，也不是响应式的 只能拿到一级父组件和子组件\n\n### 3.7 `$refs`\n\n```js\n\n// 父组件\n\u003chome ref=\"home\"/\u003e\n\nmounted(){\nconsole.log(this.\\$refs.home) //即可拿到子组件的实例,就可以直接操作 data 和 methods\n}\n\n```\n\n### 3.8 `$root`\n\n```js\n\n// 父组件\nmounted(){\nconsole.log(this.$root) //获取根实例,最后所有组件都是挂载到根实例上\n  console.log(this.$root.$children[0]) //获取根实例的一级子组件\n  console.log(this.$root.$children[0].$children[0]) //获取根实例的二级子组件\n}\n\n```\n\n### 3.9 `.sync`\n\n在 `vue@1.x` 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值; 在 `vue@2.0` 的由于违背单项数据流的设计被干掉了; 在 `vue@2.3.0+` 以上版本又重新引入了这个 `.sync` 修饰符;\n\n```js\n\n// 父组件\n\u003chome :title.sync=\"title\" /\u003e\n//编译时会被扩展为\n\u003chome :title=\"title\" @update:title=\"val =\u003e title = val\"/\u003e\n\n// 子组件\n// 所以子组件可以通过$emit 触发 update 方法改变\nmounted(){\n  this.$emit(\"update:title\", '这是新的 title')\n}\n\n```\n\n### 3.10 `v-slot`\n\n`2.6.0` 新增\n\n- 1. `slot,slot-cope,scope` 在 2.6.0 中都被废弃,但未被移除\n- 2. 作用就是将父组件的 `template` 传入子组件\n- 3. 插槽分类:\n\nA.匿名插槽(也叫默认插槽): 没有命名,有且只有一个\n\n```js\n\n// 父组件\n\u003ctodo-list\u003e\n\u003ctemplate v-slot:default\u003e\n任意内容\n\u003cp\u003e我是匿名插槽 \u003c/p\u003e\n\u003c/template\u003e\n\u003c/todo-list\u003e\n\n// 子组件\n\u003cslot\u003e我是默认值\u003c/slot\u003e\n//v-slot:default 写上感觉和具名写法比较统一,容易理解,也可以不用写\n\n```\n\nB.具名插槽: 相对匿名插槽组件 slot 标签带 name 命名的;\n\n```js\n\n// 父组件\n\u003ctodo-list\u003e\n\u003ctemplate v-slot:todo\u003e\n任意内容\n\u003cp\u003e我是匿名插槽 \u003c/p\u003e\n\u003c/template\u003e\n\u003c/todo-list\u003e\n\n//子组件\n\u003cslot name=\"todo\"\u003e我是默认值\u003c/slot\u003e\n\n```\n\nC.作用域插槽: 子组件内数据可以被父页面拿到(解决了数据只能从父页面传递给子组件)\n\n```js\n\n// 父组件\n\u003ctodo-list\u003e\n\u003ctemplate v-slot:todo=\"slotProps\" \u003e\n{{slotProps.user.firstName}}\n\u003c/template\u003e\n\u003c/todo-list\u003e\n//slotProps 可以随意命名\n//slotProps 接取的是子组件标签 slot 上属性数据的集合所有 v-bind:user=\"user\"\n\n// 子组件\n\u003cslot name=\"todo\" :user=\"user\" :test=\"test\"\u003e\n{{ user.lastName }}\n\u003c/slot\u003e\ndata() {\nreturn {\nuser:{\nlastName:\"Zhang\",\nfirstName:\"yue\"\n},\ntest:[1,2,3,4]\n}\n},\n// {{ user.lastName }}是默认数据 v-slot:todo 当父页面没有(=\"slotProps\")\n\n```\n\n### 3.11 `EventBus`\n\n- 1.就是声明一个全局 Vue 实例变量 EventBus , 把所有的通信数据，事件监听都存储到这个变量上;\n- 2.类似于 Vuex。但这种方式只适用于极小的项目\n- 3.原理就是利用 on 和 emit 并实例化一个全局 vue 实现数据共享\n\n```js\n// 在 main.js\nVue.prototype.\\$eventBus = new Vue();\n\n// 传值组件\nthis.$eventBus.$emit('eventTarget', '这是 eventTarget 传过来的值');\n\n// 接收组件\nthis.$eventBus.$on('eventTarget', v =\u003e {\n  console.log('eventTarget', v); //这是 eventTarget 传过来的值\n});\n```\n\n- 4.可以实现平级,嵌套组件传值,但是对应的事件名 eventTarget 必须是全局唯一的\n\n### 3.12 `broadcast` 和 `dispatch`\n\nvue 1.x 有这两个方法,事件广播和派发,但是 vue 2.x 删除了 下面是对两个方法进行的封装\n\n```js\nfunction broadcast(componentName, eventName, params) {\n  this.$children.forEach(child =\u003e {\n    // 获取子组件还有没注册其他组件\n    var name = child.$options.componentName;\n\n    // 需要判断注册的其他组件不是本身才进行向下广播\n    if (name === componentName) {\n      child.$emit.apply(child, [eventName].concat(params));\n    } else {\n      broadcast.apply(child, [componentName, eventName].concat(params));\n    }\n  });\n}\nexport default {\n  methods: {\n    dispatch(componentName, eventName, params) {\n      var parent = this.$parent;\n      // 获取父组件还有没注册其他组件\n      var name = parent.$options.componentName;\n      // 获取父组件注册的其他组件不是本身才进行向上递归获取\n      while (parent \u0026\u0026 (!name || name !== componentName)) {\n        parent = parent.\\$parent;\n\n        if (parent) {\n          name = parent.$options.componentName;\n        }\n      }\n      if (parent) {\n        parent.$emit.apply(parent, [eventName].concat(params));\n      }\n    },\n    broadcast(componentName, eventName, params) {\n      broadcast.call(this, componentName, eventName, params);\n    }\n  }\n};\n```\n\n### 3.13 路由传参\n\n1.方案一\n\n```js\n\n// 路由表定义传参\n{\npath: '/describe/:id',\nname: 'Describe',\ncomponent: Describe\n}\n// api 方式传参(路径传入)\nthis.\\$router.push({\npath: `/describe/${id}`,\n})\n// 页面获取\nthis.\\$route.params.id\n\n```\n\n```js\n\n// 路由表定义\n{\npath: '/describe',\nname: 'Describe',\ncomponent: Describe\n}\n// 页面传参(params 对象方式传入)\nthis.$router.push({\n  name: 'Describe',\n  params: {\n    id: id\n  }\n})\n// 页面获取\nthis.$route.params.id\n\n```\n\n3.方案三\n\n```js\n\n// 路由表定义\n{\npath: '/describe',\nname: 'Describe',\ncomponent: Describe\n}\n// 页面传参(查询字符串方式)\n// url 会显示\u0026id=xxx\nthis.$router.push({\n  path: '/describe',\n    query: {\n      id: id\n  `}\n)\n// 页面获取\nthis.$route.query.id\n\n```\n\n4.三种方案对比 :\n方案二参数不会拼接在路由后面,页面刷新参数会丢失,方案一和三参数拼接在后面,丑,而且暴露了信息\n\n### 3.14 `Vue.observable`\n\n2.6.0 新增\n用法:让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象;\n返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新;\n也可以作为最小化的跨组件状态存储器，用于简单的场景。\n通讯原理实质上是利用 `Vue.observable` 实现一个简易的 vuex\n\n```js\n\n// 文件路径 - /store/store.js\nimport Vue from 'vue'\n\nexport const store = Vue.observable({ count: 0 })\nexport const mutations = {\nsetCount (count) {\nstore.count = count\n}\n}\n\n//使用\n\u003ctemplate\u003e\n\u003cdiv\u003e\n\u003clabel for=\"bookNum\"\u003e数 量\u003c/label\u003e\n\u003cbutton @click=\"setCount(count+1)\"\u003e+\u003c/button\u003e\n\u003cspan\u003e{{count}}\u003c/span\u003e\n\u003cbutton @click=\"setCount(count-1)\"\u003e-\u003c/button\u003e\n\u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript\u003e\nimport { store, mutations } from '../store/store' // Vue2.6新增API Observable\n\nexport default {\n  name: 'Add',\n  computed: {\n    count () {\n      return store.count\n    }\n  },\n  methods: {\n    setCount: mutations.setCount\n  }\n}\n\u003c/script\u003e\n\n```\n\n## 4.`render` 函数\n\n1.场景:有些代码在 template 里面写会重复很多,所以这个时候 render 函数就有作用啦\n\n```js\n\n// 根据 props 生成标签\n// 初级\n\u003ctemplate\u003e\n\n  \u003cdiv\u003e\n    \u003cdiv v-if=\"level === 1\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/div\u003e\n    \u003cp v-else-if=\"level === 2\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/p\u003e\n    \u003ch1 v-else-if=\"level === 3\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/h1\u003e\n    \u003ch2 v-else-if=\"level === 4\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/h2\u003e\n    \u003cstrong v-else-if=\"level === 5\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/stong\u003e\n    \u003ctextarea v-else-if=\"level === 6\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/textarea\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n// 优化版,利用 render 函数减小了代码重复率\n\u003ctemplate\u003e\n\n  \u003cdiv\u003e\n    \u003cchild :level=\"level\"\u003eHello world!\u003c/child\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cscript type='text/javascript'\u003e\n  import Vue from 'vue'\n  Vue.component('child', {\n    render(h) {\n      const tag = ['div', 'p', 'strong', 'h1', 'h2', 'textarea'][this.level]\n      return h(tag, this.$slots.default)\n    },\n    props: {\n      level: {  type: Number,  required: true  }\n    }\n  })\n  export default {\n    name: 'hehe',\n    data() { return { level: 3 } }\n  }\n\u003c/script\u003e\n\n```\n\n2.render 和 template 的对比\n前者适合复杂逻辑,后者适合逻辑简单; 前者属于自定 Render 函数, 后者属于声明是渲染; 前者的性能较高，后者性能较低。\n\n## 5.异步组件\n\n场景:项目过大就会导致加载缓慢,所以异步组件实现按需加载就是必须要做的事啦 1.异步注册组件 3 种方法\n\n```js\n// 工厂函数执行 resolve 回调\nVue.component('async-webpack-example', function(resolve) {\n  // 这个特殊的 `require` 语法将会告诉 webpack\n  // 自动将你的构建代码切割成多个包, 这些包\n  // 会通过 Ajax 请求加载\n  require(['./my-async-component'], resolve);\n});\n\n// 工厂函数返回 Promise\nVue.component(\n  'async-webpack-example',\n  // 这个 `import` 函数会返回一个 `Promise` 对象。\n  () =\u003e import('./my-async-component')\n);\n\n// 工厂函数返回一个配置化组件对象\nconst AsyncComponent = () =\u003e ({\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n});\n```\n\n异步组件的渲染本质上其实就是执行 2 次或者 2 次以上的渲染, 先把当前组件渲染为注释节点, 当组件加载成功后, 通过 `forceRender` 执行重新渲染。或者是渲染为注释节点, 然后再渲染为 loading 节点, 在渲染为请求完成的组件\n\n```\n\n注释节点 -\u003e 加载节点 -\u003e 请求完成的节点(加载失败的节点)\n\n```\n\n2.路由的按需加载\n\n```js\n\nwebpack\u003c 2.4 时\n{\npath:'/',\nname:'home',\ncomponents:resolve=\u003erequire(['@/components/home'],resolve)\n}\n\nwebpack\u003e 2.4 时\n{\npath:'/',\nname:'home',\ncomponents:()=\u003eimport('@/components/home')\n}\n\nimport()方法由 es6 提出，import()方法是动态加载，返回一个 Promise 对象，then 方法的参数是加载到的模块(取值 res.default)。类似于 Node.js 的 require 方法(同步加载)，主要 import()方法是异步加载的。\n\n```\n\n## 6.动态组件\n\n场景:做一个 tab 切换时就会涉及到组件动态加载\n\n```js\n\u003ccomponent v-bind:is=\"currentTabComponent\"\u003e\u003c/component\u003e\n```\n\n但是这样每次组件都会重新加载,会消耗大量性能,所以缓存组件 `keep-alive` 就起到了作用\n\n```js\n\u003ckeep-alive\u003e\n  \u003ccomponent v-bind:is=\"currentTabComponent\"\u003e\u003c/component\u003e\n\u003c/keep-alive\u003e\n```\n\n这样切换效果没有动画效果,这个也不用着急,可以利用内置的过渡组件 `transition`，需要配置动画类名 `enter-xxx`\n\n```js\n\u003ctransition\u003e\n  \u003ckeep-alive\u003e\n    \u003ccomponent v-bind:is=\"currentTabComponent\"\u003e\u003c/component\u003e\n  \u003c/keep-alive\u003e\n\u003c/transition\u003e\n```\n\n## 7.递归组件\n\n场景:如果开发一个 tree 组件,里面层级是根据后台数据决定的,这个时候就需要用到动态组件\n\n```js\n// 递归组件: 组件在它的模板内可以递归的调用自己，只要给组件设置name就可以了。\n// 设置那么House在组件模板内就可以递归使用了,不过需要注意的是，\n// 必须给一个条件来限制数量，否则会抛出错误: max stack size exceeded\n// 组件递归用来开发一些具体有未知层级关系的独立组件。比如：\n// 联级选择器和树形控件\n\n\u003ctemplate\u003e\n  \u003cdiv v-for=\"(item,index) in treeArr\"\u003e\n      子组件，当前层级值： {{index}} \u003cbr/\u003e\n      \u003c!-- 递归调用自身, 后台判断是否不存在改值 --\u003e\n      \u003ctree :item=\"item.arr\" v-if=\"item.flag\"\u003e\u003c/tree\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nexport default {\n  // 必须定义name，组件内部才能递归调用!!!\n  name: 'tree',\n  data(){\n    return {}\n  },\n  // 接收外部传入的值\n  props: {\n     item: {\n      type:Array,\n      default: ()=\u003e[]\n    }\n  }\n}\n\u003c/script\u003e\n\n```\n\n递归组件必须设置 name 和结束的阀值!!!\n\n## 8.函数式组件\n\n定义:无状态,无法实例化，内部没有任何生命周期处理方法\n规则:在 2.3.0 之前的版本中，如果一个函数式组件想要接收 `prop`，则 `props` 选项是必须的。\n在 2.3.0 或以上的版本中，你可以省略 `props` 选项，所有组件上的特性都会被自动隐式解析为 prop\n在 2.5.0 及以上版本中，如果你使用了单文件组件(就是普通的.vue 文件),可以直接在 template 上声明`functional`\n组件需要的一切都是通过 `context` 参数传递\n`context` 属性有:\n\n- 1.props：提供所有 prop 的对象\n- 2.children: VNode 子节点的数组\n- 3.slots: 一个函数，返回了包含所有插槽的对象\n- 4.scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。\n- 5.data：传递给组件的整个数据对象，作为 `createElement` 的第二个参数传入组件\n- 6.parent：对父组件的引用\n- 7.listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。\n- 8.injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性\n\n```js\n\u003ctemplate functional\u003e\n  \u003cdiv v-for=\"(item,index) in props.arr\"\u003e{{ item }}\u003c/div\u003e\n\u003c/template\u003e\n```\n\n## 9.components 和 Vue.component\n\ncomponents:局部注册组件\n\n```js\nexport default {\n  components: { home }\n};\n```\n\nVue.component:全局注册组件\n\n```js\nVue.component('home', home);\n```\n\n## 10.Vue.extend\n\n扩展\n场景:vue 组件中有些需要将一些元素挂载到元素上,这个时候 `extend` 就起到作用了 是构造一个组件的语法器 写法:\n\n```js\n// 创建构造器\nvar Profile = Vue.extend({\n  template: '\u003cp\u003e{{extendData}}\u003c/br\u003e实例传入的数据为:{{propsExtend}}\u003c/p\u003e', //template对应的标签最外层必须只有一个标签\n  data: function() {\n    return {\n      extendData: '这是extend扩展的数据'\n    };\n  },\n  props: ['propsExtend']\n});\n\n// 创建的构造器可以挂载到元素上,也可以通过 components 或 Vue.component()注册使用\n// 挂载到一个元素上。可以通过propsData传参.\n// propsData传给子组件的对象\nnew Profile({ propsData: { propsExtend: '我是实例传入的数据' } }).$mount('#app-extend');\n\n// 通过 components 或 Vue.component()注册\nVue.component('Profile', Profile);\n```\n\n## 11.mixins\n\n场景:有些组件有些重复的 js 逻辑,如校验手机验证码,解析时间等,mixins 就可以实现这种混入 mixins 值是一个数组\n\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n\n当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。\n比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。\n\n同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。\n\n值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。\n\n```js\nconst mixin = {\n  created() {\n    this.dealTime();\n  },\n  methods: {\n    dealTime() {\n      console.log('这是mixin的dealTime里面的方法');\n    }\n  }\n};\n\nexport default {\n  mixins: [mixin]\n};\n```\n\n全局混入\n混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。\n\n```js\n// 为自定义的选项 'myOption' 注入一个处理器。\nVue.mixin({\n  created: function() {\n    var myOption = this.$options.myOption;\n    if (myOption) {\n      console.log(myOption);\n    }\n  }\n});\n\nnew Vue({\n  myOption: 'hello!'\n});\n// =\u003e \"hello!\"\n```\n\n\u003e 请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。\n\u003e 更多查看 [vue 官网](https://cn.vuejs.org/v2/guide/mixins.html)\n\n## 12.extends\n\nextends 用法和 mixins 很相似,只不过接收的参数是简单的选项对象或构造函数,所以 extends 只能单次扩展一个组件\n\n```js\nconst extend = {\n  created() {\n    this.dealTime();\n  },\n  methods: {\n    dealTime() {\n      console.log('这是extend的dealTime里面的方法');\n    }\n  }\n};\n\nexport default {\n  extends: extend\n};\n```\n\n## 13.Vue.use()\n\n场景:我们使用 element 时会先 import,再 Vue.use()一下,实际上就是注册组件,触发 install 方法; 这个在组件调用会经常使用到; 会自动组织多次注册相同的插件\n\n## 14.install\n\n场景:在 Vue.use()说到,执行该方法会触发 install 方法，这是开发 vue 的插件,这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象(可选)\n\n```js\nvar MyPlugin = {};\nMyPlugin.install = function(Vue, options) {\n  // 2. 添加全局资源,第二个参数传一个值默认是update对应的值\n  Vue.directive('click', {\n    bind(el, binding, vnode, oldVnode) {\n      //做绑定的准备工作,添加时间监听\n      console.log('指令my-directive的bind执行啦');\n    },\n    inserted: function(el) {\n      //获取绑定的元素\n      console.log('指令my-directive的inserted执行啦');\n    },\n    update: function() {\n      //根据获得的新值执行对应的更新\n      //对于初始值也会调用一次\n      console.log('指令my-directive的update执行啦');\n    },\n    componentUpdated: function() {\n      console.log('指令my-directive的componentUpdated执行啦');\n    },\n    unbind: function() {\n      //做清理操作\n      //比如移除bind时绑定的事件监听器\n      console.log('指令my-directive的unbind执行啦');\n    }\n  });\n\n  // 3. 注入组件\n  Vue.mixin({\n    created: function() {\n      console.log('注入组件的created被调用啦');\n      console.log('options的值为', options);\n    }\n  });\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function(methodOptions) {\n    console.log('实例方法myMethod被调用啦');\n  };\n};\n\n//调用MyPlugin\nVue.use(MyPlugin, { someOption: true });\n\n//3.挂载\nnew Vue({\n  el: '#app'\n});\n```\n\n更多请戳 vue 中 extend，mixins，extends，components,install 的几个操作\n\n## 15. Vue.nextTick\n\n`2.1.0` 新增 场景:页面加载时需要让文本框获取焦点\n用法:在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM\n这个方式属于事件循环中的微任务(microtask),相当于 Promise.then()\n\n```js\nmounted(){ //因为 mounted 阶段 dom 并未渲染完毕,所以需要$nextTick\n  this.$nextTick(() =\u003e {\n    this.$refs.inputs.focus() //通过 $refs 获取dom 并绑定 focus 方法\n  })\n}\n```\n\n## 16.Vue.directive\n\n### 16.1 使用\n\n场景:官方给我们提供了很多指令,但是我们如果想将文字变成指定的颜色定义成指令使用,这个时候就需要用到 Vue.directive\n\n```js\n// 全局定义\nVue.directive(\"change-color\",function(el,binding,vnode){\n  el.style[\"color\"]= binding.value;\n})\n\n// 使用\n\u003ctemplate\u003e\n\u003cdiv v-change-color :value=\"color\"\u003e\n\u003c/div\u003e\n\u003c/template\u003e\n\u003cscript\u003e\n  export default{\n    data(){\n      return{\n        color:'green'\n      }\n    }\n  }\n\u003c/script\u003e\n```\n\n### 16.2 生命周期\n\n- 1.bind 只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。\n- 2.inserted:被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在 document 中)。\n- 3.update: 被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新。\n- 4.componentUpdate :被绑定的元素指令所在组件的 VNode 及其子 VNode 全部更新后调用。\n- 5.unbind: 只调用一次，指令月元素解绑的时候调用。\n\n## 17. Vue.filter\n\n场景:时间戳转化成年月日这是一个公共方法,所以可以抽离成过滤器使用\n\n```js\n// 使用\n// 在双花括号中\n{\n  {\n    message | capitalize;\n  }\n}\n\n// 在 `v-bind` 中\n\u003cdiv v-bind:id=\"rawId | formatId\"\u003e\u003c/div\u003e;\n\n// 全局注册\nVue.filter('stampToYYMMDD', value =\u003e {\n  // 处理逻辑\n});\n\n// 局部注册\nfilters: {\n  stampToYYMMDD: value =\u003e {\n    // 处理逻辑\n  };\n}\n\n// 多个过滤器全局注册\n// /src/common/filters.js\nlet dateServer = value =\u003e value.replace(/(\\d{4})(\\d{2})(\\d{2})/g, '$1-$2-$3');\nexport { dateServer };\n// /src/main.js\nimport * as custom from './common/filters/custom';\nObject.keys(custom).forEach(key =\u003e Vue.filter(key, custom[key]));\n```\n\n## 18.Vue.compile\n\n场景:在 render 函数中编译模板字符串。只在独立构建时有效\n\n```js\nvar res = Vue.compile('\u003cdiv\u003e\u003cspan\u003e{{ msg }}\u003c/span\u003e\u003c/div\u003e');\n\nnew Vue({\n  data: {\n    msg: 'hello'\n  },\n  render: res.render,\n  staticRenderFns: res.staticRenderFns\n});\n```\n\n## 19.Vue.version\n\n场景:有些开发插件需要针对不同 vue 版本做兼容,所以就会用到 Vue.version 用法:Vue.version()可以获取 vue 版本\n\n```js\nvar version = Number(Vue.version.split('.')[0]);\n\nif (version === 2) {\n  // Vue v2.x.x\n} else if (version === 1) {\n  // Vue v1.x.x\n} else {\n  // Unsupported versions of Vue\n}\n```\n\n## 20.Vue.set()\n\n场景:当你利用索引直接设置一个数组项时或你修改数组的长度时,由于 Object.defineprototype()方法限制,数据不响应式更新,主要是 vue 官方考虑到性能原因。不过 vue.3.x 将利用 proxy 这个问题将得到解决 解决方案\n\n```js\n// 利用 set，设置对象不存在的属性为响应式的，也是这个方法\nthis.$set(arr, index, item);\n\n// 利用数组的原生方法 pop(), push(), shift(), unshift(), splice()\n```\n\n## 21.Vue.config.keyCodes\n\n场景:自定义按键修饰符别名\n\n```js\n// 将键码为 113 定义为 f2\nVue.config.keyCodes.f2 = 113;\n\u003cinput type=\"text\" @keyup.f2=\"add\"/\u003e\n```\n\n## 22.Vue.config.performance\n\n场景:监听性能\n\n```js\nVue.config.performance = true;\n```\n\n只适用于开发模式和支持 performance.mark API 的浏览器上\n\n## 23.Vue.config.errorHandler\n\n- 1.场景:指定组件的渲染和观察期间未捕获错误的处理函数\n- 2.规则:\n  从 `2.2.0` 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃\n  从 `2.4.0` 起，这个钩子也会捕获 `Vue` 自定义事件处理函数内部的错误了\n  从 `2.6.0` 起，这个钩子也会捕获 `v-on DOM` 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理 3.使用\n\n```js\nVue.config.errorHandler = function(err, vm, info) {\n  // handle error\n  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子\n  // 只在 2.2.0+ 可用\n};\n```\n\n## 24.Vue.config.warnHandler\n\n2.4.0 新增 1.场景:为 Vue 的运行时警告赋予一个自定义处理函数,只会在开发者环境下生效 2.用法:\n\n```js\nVue.config.warnHandler = function(msg, vm, trace) {\n  // `trace` 是组件的继承关系追踪\n};\n```\n\n## 25.v-pre\n\n内置的格式化内容指令(不编译)\n场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能\n\n```js\n\u003cspan v-pre\u003e{{ this will not be compiled }}\u003c/span\u003e   显示的是{{ this will not be compiled }}\n\u003cspan v-pre\u003e{{msg}}\u003c/span\u003e     即使data里面定义了msg这里仍然是显示的{{msg}}\n```\n\n## 26.v-cloak\n\n场景:在网速慢的情况下,在使用 vue 绑定数据的时候，渲染页面时会出现变量闪烁\n用法:这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕\n\n```js\n// template 中\n\u003cdiv class=\"#app\" v-cloak\u003e\n    \u003cp\u003e{{value.name}}\u003c/p\u003e\n\u003c/div\u003e\n\n// css 中\n[v-cloak] {\n    display: none;\n}\n\n```\n\n这样就可以解决闪烁,但是会出现白屏,这样可以结合骨架屏使用(在组件挂载完毕前用骨架屏组件来代替展示，等加载成功后在展示原组件)\n\n## 27.v-once\n\n这个也是 vue 提供的 quan 指令\n场景:有些 template 中的静态 dom 没有改变,这时就只需要渲染一次,可以降低性能开销\n\n```js\n\u003cspan v-once\u003e 这时只需要加载一次的标签\u003c/span\u003e\n```\n\nv-once 和 v-pre 的区别: v-once 只渲染一次；v-pre 不编译,原样输出\n\n## 28.事件修饰符\n\n```\n.stop:阻止冒泡\n.prevent:阻止默认行为\n.self:仅绑定元素自身触发\n.once: 2.1.4 新增,只触发一次\n.passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用\n```\n\n## 29.按键修饰符和按键码\n\n场景:有的时候需要监听键盘的行为,如按下 enter 去查询接口等\n\n```\n// 对应键盘上的关键字\n.enter(回车键)\n.tab(tab键)\n.delete (捕获“删除”和“退格”键)\n.esc(esc键)\n.space(空格键)\n.up(上)\n.down(下)\n.left(左)\n.right(右)\n```\n\n## 30.Vue-router\n\n场景:Vue-router 是官方提供的路由插件\n\n### 30.1 缓存和动画\n\n- 1.路由是使用官方组件 vue-router,使用方法相信大家非常熟悉;\n- 2.这里我就叙述下路由的缓存和动画;\n- 3.可以用 exclude(除了)或者 include(包括),2.1.0 新增来坐判断\n\n```js\n\u003ctransition\u003e\n  \u003ckeep-alive :include=\"['a', 'b']\"\u003e\n  //或include=\"a,b\" :include=\"/a|b/\",a 和 b 表示组件的 name\n  //因为有些页面,如试试数据统计,要实时刷新,所以就不需要缓存\n    \u003crouter-view/\u003e //路由标签\n  \u003c/keep-alive\u003e\n  \u003crouter-view exclude=\"c\"/\u003e\n  // c 表示组件的 name值\n\u003c/transition\u003e\n```\n\n\u003e 注:匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)。匿名组件不能被匹配\n\n- 4.用 v-if 做判断,组件会重新渲染,但是不用一一列举组件 name\n\n### 30.2 全局路由钩子\n\n- 1.router.beforeEach\n\n```js\nrouter.beforeEach((to, from, next) =\u003e {\n  console.log('全局前置守卫：beforeEach -- next需要调用'); //一般登录拦截用这个,也叫导航钩子守卫\n  if (path === '/login') {\n    //跳转到登录页面，直接通过\n    next();\n    return;\n  }\n  if (token) {\n    // 有token就直接通过\n    next();\n  }\n});\n```\n\n- 2.router.beforeResolve (v 2.5.0+)\n  和 `beforeEach`类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用\n  即在 `beforeEach` 之后调用\n- 3.router.afterEach\n  全局后置钩子;\n  在所有路由跳转结束的时候调用;\n  这些钩子不会接受 `next` 函数也不会改变导航本身;\n\n### 30.3 组件路由钩子\n\n- 1.beforeRouteEnter\n  在渲染该组件的对应路由被确认前调用，用法和参数与 router.beforeEach 类似，next 需要被主动调用\n  此时组件实例还未被创建，不能访问 this\n  可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数\n\n```js\nbeforeRouteEnter (to, from, next) {\n  // 这里还无法访问到组件实例，this === undefined\n  next( vm =\u003e {\n    // 通过 `vm` 访问组件实例\n  })\n}\n```\n\n- 2.beforeRouteUpdate (v 2.2+)\n  在当前路由改变，并且该组件被复用时调用，可以通过 this 访问实例， next 需要被主动调用，不能传回调\n\n- 3.beforeRouteLeave\n  导航离开该组件的对应路由时调用，可以访问组件实例 this，next 需要被主动调用，不能传回调\n\n### 30.4 路由模式\n\n设置 mode 属性:hash 或 history\n\n### 30.5 Vue.\\$router\n\n```js\nthis.$router.push():跳转到不同的url，但这个方法回向history栈添加一个记录，点击后退会返回到上一个页面\nthis.$router.replace():不会有记录\nthis.$router.go(n):n可为正数可为负数。正数返回下一个页面(如果是返回过来的页面就有上一个页面历史),负数返回上一个页面，0就是刷新当前页面。类似 window.history.go(n)\n```\n\n### 30.6 Vue.\\$route\n\n表示当前跳转的路由对象,属性有:\nname:路由名称\npath:路径\nquery:传参接收值(查询字符串)\nparams:传参接收值\nfullPath:完成解析后的 URL，包含查询参数和 hash 的完整路径\nmatched:路由记录副本\nredirectedFrom:如果存在重定向，即为重定向来源的路由的名字\n\n```js\nthis.$route.params.id:获取通过 params 或url中的/:id传参的参数\nthis.$route.query.id:获取通过 query 传参的参数\n```\n\n### 30.7 router-view 的 key\n\n场景:由于 Vue 会复用相同组件, 即 `/page/1 =\u003e /page/2` 或者 `/page?id=1 =\u003e /page?id=2` 这类链接跳转时, 将不在执行`created, mounted`之类的钩子\n\n```js\n\u003crouter-view :key=\"$route.fullpath\"\u003e\u003c/router-view\u003e\n```\n\n这样组件的 created 和 mounted 就都会执行，相当于 routew-view 组件，页面跳转前后，key 值是不一样的，会触发视图重新加载\n\n## 31.Object.freeze\n\n场景:一个长列表数据,一般不会更改,但是 vue 会做 getter 和 setter 的转换\n用法:是 ES5 新增的特性，可以冻结一个对象，防止对象被修改\n支持:vue 1.0.18+对其提供了支持，对于 data 或 vuex 里使用 freeze 冻结了的对象，vue 不会做 getter 和 setter 的转换\n注意:冻结只是冻结里面的单个属性,引用地址还是可以更改\n\n## 31.Object.freeze\n\n场景:一个长列表数据,一般不会更改,但是 vue 会做 getter 和 setter 的转换\n用法:是 ES5 新增的特性，可以冻结一个对象，防止对象被修改\n支持:vue 1.0.18+对其提供了支持，对于 data 或 vuex 里使用 freeze 冻结了的对象，vue 不会做 getter 和 setter 的转换\n注意:冻结只是冻结里面的单个属性,引用地址还是可以更改\n\n```js\nnew Vue({\n  data: {\n    // vue不会对list里的object做getter、setter绑定\n    list: Object.freeze([{ value: 1 }, { value: 2 }])\n  },\n  mounted() {\n    // 界面不会有响应,因为单个属性被冻结\n    this.list[0].value = 100;\n\n    // 下面两种做法，界面都会响应\n    this.list = [{ value: 100 }, { value: 200 }];\n    this.list = Object.freeze([{ value: 100 }, { value: 200 }]);\n  }\n});\n```\n\n## 32.调试 template\n\n场景:在 Vue 开发过程中, 经常会遇到 template 模板渲染时 JavaScript 变量出错的问题, 此时也许你会通过 console.log 来进行调试 这时可以在开发环境挂载一个 log 函数\n\n```js\n// main.js\nVue.prototype.$log = window.console.log;\n\n// 组件内部\n\u003cdiv\u003e{{$log(info)}}\u003c/div\u003e\n\n```\n\n## 33.vue-loader 小技巧\n\n### 33.1 preserveWhitespace\n\n场景:开发 vue 代码一般会有空格,这个时候打包压缩如果不去掉空格会加大包的体积 配置 `preserveWhitespace` 可以减小包的体积\n\n```\n{\n  vue: {\n    preserveWhitespace: false\n  }\n}\n```\n\n### 33.2 transformToRequire\n\n场景:以前在写 Vue 的时候经常会写到这样的代码：把图片提前 require 传给一个变量再传给组件\n\n```js\n// page 代码\n\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cavatar :img-src=\"imgSrc\"\u003e\u003c/avatar\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\u003cscript\u003e\n  export default {\n    created () {\n      this.imgSrc = require('./assets/default-avatar.png')\n    }\n  }\n\u003c/script\u003e\n```\n\n现在:通过配置 transformToRequire 后，就可以直接配置，这样 vue-loader 会把对应的属性自动 require 之后传给组件\n\n```js\n// vue-cli 2.x在vue-loader.conf.js 默认配置是\ntransformToRequire: {\n    video: ['src', 'poster'],\n    source: 'src',\n    img: 'src',\n    image: 'xlink:href'\n}\n\n  // 配置文件,如果是vue-cli2.x 在vue-loader.conf.js里面修改\n  avatar: ['default-src']\n\n // page 代码可以简化为\n\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cavatar default-src=\"./assets/default-avatar.png\"\u003e\u003c/avatar\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n// vue-cli 3.x 在vue.config.js\n// vue-cli 3.x 将transformToRequire属性换为了transformAssetUrls\nmodule.exports = {\n  pages,\n  chainWebpack: config =\u003e {\n    config\n      .module\n        .rule('vue')\n        .use('vue-loader')\n        .loader('vue-loader')\n        .tap(options =\u003e {\n      options.transformAssetUrls = {\n        avatar: 'img-src',\n      }\n      return options;\n      });\n  }\n}\n\n// page 代码可以简化为\n\u003ctemplate\u003e\n  \u003cdiv\u003e\n    \u003cavatar img-src=\"./assets/default-avatar.png\"\u003e\u003c/avatar\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\n## 34.为路径设置别名\n\n1.场景:在开发过程中，我们经常需要引入各种文件，如图片、CSS、JS 等，为了避免写很长的相对路径（../），我们可以为不同的目录配置一个别名\n\n2.vue-cli 2.x 配置\n\n```js\n// 在 webpack.base.config.js中的 resolve 配置项，在其 alias 中增加别名\nresolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n    }\n  },\n```\n\n3.vue-cli 3.x 配置\n\n```js\n// 在根目录下创建vue.config.js\nvar path = require('path');\nfunction resolve(dir) {\n  console.log(__dirname);\n  return path.join(__dirname, dir);\n}\nmodule.exports = {\n  chainWebpack: config =\u003e {\n    config.resolve.alias.set(key, value); // key,value自行定义，比如.set('@@', resolve('src/components'))\n  }\n};\n```\n\n## 35.img 加载失败\n\n场景:有些时候后台返回图片地址不一定能打开,所以这个时候应该加一张默认图片\n\n```js\n// page 代码\n\u003cimg :src=\"imgUrl\" @error=\"handleError\" alt=\"\"\u003e\n\u003cscript\u003e\nexport default{\n  data(){\n    return{\n      imgUrl:''\n    }\n  },\n  methods:{\n    handleError(e){\n      e.target.src=reqiure('图片路径') //当然如果项目配置了transformToRequire,参考上面 33.2\n    }\n  }\n}\n\u003c/script\u003e\n```\n\n## 36.css\n\n### 36.1 局部样式\n\n1.Vue 中 style 标签的 scoped 属性表示它的样式只作用于当前模块，是样式私有化. 2.渲染的规则/原理：\n给 HTML 的 DOM 节点添加一个 `不重复的data属性` 来表示 唯一性\n在对应的 `CSS选择器末尾` 添加一个当前组件的 data 属性选择器来私有化样式，如：.demo[data-v-2311c06a]{}\n如果引入 less 或 sass 只会在 `最后一个元素上` 设置，本质上基于属性选择器\n\n```js\n// 原始代码\n\u003ctemplate\u003e\n  \u003cdiv class=\"demo\"\u003e\n    \u003cspan class=\"content\"\u003e\n      Vue.js scoped\n    \u003c/span\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n\n\u003cstyle lang=\"less\" scoped\u003e\n  .demo{\n    font-size: 16px;\n    .content{\n      color: red;\n    }\n  }\n\u003c/style\u003e\n\n// 浏览器渲染效果\n\u003cdiv data-v-fed36922\u003e\n  Vue.js scoped\n\u003c/div\u003e\n\u003cstyle type=\"text/css\"\u003e\n.demo[data-v-039c5b43] {\n  font-size: 14px;\n}\n.demo .content[data-v-039c5b43] { //.demo 上并没有加 data 属性\n  color: red;\n}\n\u003c/style\u003e\n```\n\n### 36.2 deep 属性\n\n给最外层的元素添加属性选择器\n\n```js\n// 上面样式加一个 /deep/\n\u003cstyle lang=\"less\" scoped\u003e\n  .demo{\n    font-size: 14px;\n  }\n  .demo /deep/ .content{\n    color: blue;\n  }\n\u003c/style\u003e\n\n// 浏览器编译后\n\u003cstyle type=\"text/css\"\u003e\n.demo[data-v-039c5b43] {\n  font-size: 14px;\n}\n.demo[data-v-039c5b43] .content {\n  color: blue;\n}\n\u003c/style\u003e\n```\n\n## 最后\n\n文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下[Github](https://github.com/GolderBrother)~\n","like_users":[],"create_time":{"$date":"2019-10-12T10:29:54.982Z"},"update_time":{"$date":"2019-10-12T10:29:54.982Z"},"id":10,"__v":0}
{"_id":{"$oid":"5da29e7153af0700308855e7"},"meta":{"views":22,"likes":0,"comments":0},"keyword":["ES6、ECMAscript 2015"],"desc":"ES6既是一个历史名词也是一个泛指，含义是5.1版本以后的JavaScript下一代标准，目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019。","numbers":"30584","img_url":"http://img.golderbrother.cn/es6.png","type":1,"state":1,"origin":0,"tags":[{"$oid":"5da29d1653af0700308855e5"}],"comments":[],"category":[{"$oid":"5da29d1d53af0700308855e6"}],"title":"1.5万字概括ES6全部特性","author":"golderBrother","content":"### 完整的 ES6 特性图\n\n![ES6](http://img.golderbrother.cn/es6.png)\n\n## 1.5 万字概括 ES6 全部特性\n\n前言\n第三次阅读阮一峰老师的[《ES6 标准入门》](https://es6.ruanyifeng.com/)了，以前阅读时不细心，很多地方都是一目十行。最近这次阅读都是逐个逐个字来读，发现很多以前都没有注意到的知识点，为了方便记忆和预览`全部ES6`特性，所以写下本文。\n\n\u003e 以下提到的《ES6 标准入门》统一使用《ES6》这个名称来代替，而最新的 ES6 版本也是截止到当前的 ES2019\n\n本文的知识点完全是参考或摘录[《ES6》](https://es6.ruanyifeng.com/)里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照[《ES6》](https://es6.ruanyifeng.com/)的内容来学习。\n\n本文整理出来的笔记都是书中的精华内容，囊括了整个`ES6体系`的所有特性，非常方便大家重新认识全部`ES6特性`。半小时的阅读就可以对`ES6`有一个全面的了解，可以认为是一本`ES6`特性小字典，收藏后可随时查阅\n\n![image](http://img.golderbrother.cn/es6-all.png)\n\n**修正**\n\n**ES6**是`ECMA`为`JavaScript`制定的第 6 个标准版本，相关历史可查看此章节(《ES6-ECMAScript6 简介》)[https://es6.ruanyifeng.com/#docs/intro]。\n标准委员会最终决定，标准在每年 6 月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年 6 月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。`ECMAscript 2015`是在 2015 年 6 月发布`ES6`的第一个版本。以此类推，`ECMAscript 2016`是`ES6`的第二个版本、 `ECMAscript 2017`是`ES6`的第三个版本。**ES6**既是一个历史名词也是一个泛指，含义是`5.1版本`以后的`JavaScript下一代标准`，目前涵盖了`ES2015`、`ES2016`、`ES2017`、`ES2018`、`ES2019`。\n所以有些文章上提到的 ES7(实质上是 ES2016)、ES8(实质上是 ES2017)、ES9(实质上是 ES2018)、ES10(实质上是 ES2019)，实质上都是一些不规范的概念。从 ES1 到 ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个 ES6 到 ES7，ES7 到 ES8，才用了一年，按照这样的定义下去，那不是很快就 ES20 了。用正确的概念来说 ES6 目前涵盖了**ES2015、ES2016、ES2017、ES2018、ES2019**\n\n![image](http://img.golderbrother.cn/es6-1.png)\n\n另外，ES6 更新的内容主要分为以下几点\n\n- **表达式**：声明、解构赋值\n- **内置对象**：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect\n- **语句与运算**：Class、Module、Iterator\n- **异步编程**：Promise、Generator、Async\n\n### ES2015\n\n![image](http://img.golderbrother.cn/es6-2.png)\n\n#### 声明\n\n**const 命令**：声明常量\n**let 命令**：声明变量\n\n\u003e 作用\n\n1. 作用域\n\n- 全局作用域\n- 函数作用域：function() {}\n- 块级作用域：{}\n\n2. 作用范围\n\n- var 命令在全局代码中执行\n- const 命令和 let 命令只能在代码块中执行\n\n3. 赋值使用\n\n- const 命令声明常量后必须立马赋值\n- let 命令声明变量后可立马赋值或使用时赋值\n\n4. 声明方法：`var、const、let、function、class、import`\n\n\u003e 重点难点\n\n- 不允许重复声明\n- 未定义就使用会报错：`const`命令和`let`命令不存在变量提升\n- 暂时性死区：在代码块内使用`let`命令声明变量之前，该变量都不可用\n\n#### 解构赋值\n\n1. 字符串解构：```const [a, b, c, d, e] = \"hello\"\n2. 数值解构：`const { toString: s } = 123`\n3. 布尔值解构：`const { toString: b } = true`\n4. 对象解构\n\n- 形式：`const { x, y } = { x: 1, y: 2 }`\n- 默认：`const { x, y = 2 } = { x: 1 }`\n- 改名：`const { x, y: z } = { x: 1, y: 2 }`\n\n5. 数组解构\n\n- 规则：数据结构具有`Iterator`接口可采用数组形式的解构赋值\n- 形式：`const [x, y] = [1, 2]`\n- 默认：`const [x, y = 2] = [1]`\n\n6. 函数参数解构\n\n- 数组解构：`function Func([x = 0, y = 1]) {}`\n- 对象解构：`function Func({ x = 0, y = 1 } = {}) {}`\n\n\u003e 应用场景\n\n- 交换变量值：`[x, y] = [y, x]`\n- 返回函数多个值：`const [x, y, z] = Func()`\n- 定义函数参数：`Func([1, 2])`\n- 提取 JSON 数据：`const { name, version } = packageJson`\n- 定义函数参数默认值：`function Func({ x = 1, y = 2 } = {}) {}`\n- 遍历 Map 结构：`for (let [k, v] of Map) {}`\n- 输入模块指定属性和方法：`const { readFile, writeFile } = require(\"fs\")`\n\n\u003e 重点难点\n\n- 匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值\n- 解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象\n- 解构默认值生效条件：属性值严格等于`undefined`\n- 解构遵循匹配模式\n- 解构不成功时变量的值等于`undefined`\n- `undefined`和`null`无法转为对象，因此无法进行解构\n\n#### 字符串扩展\n\nUnicode 表示法：`大括号`包含表示 Unicode 字符(`\\u{0xXX}`或`\\u{0XXX}`)\n字符串遍历：可通过`for-of`遍历字符串\n字符串模板：可单行可多行可插入变量的增强版字符串\n标签模板：函数参数的特殊调用\nString.raw()：返回把字符串所有变量替换且对斜杠进行转义的结果\nString.fromCodePoint()：返回码点对应字符\ncodePointAt()：返回字符对应码点(`String.fromCodePoint()`的逆操作)\nnormalize()：把字符的不同表示方法统一为同样形式，返回新字符串(`Unicode`正规化)\nrepeat()：把字符串重复`n`次，返回`新字符串`\nmatchAll()：返回正则表达式在字符串的所有匹配\nincludes()：是否存在指定字符串\nstartsWith()：是否存在字符串头部指定字符串\nendsWith()：是否存在字符串尾部指定字符串\n\n\u003e 重点难点\n\n以上扩展方法均可作用于由`4个字节储存`的`Unicode字符`上\n\n#### 数值扩展\n\n- [x] 二进制表示法：`0b`或`0B`开头表示二进制`(0bXX或0BXX)`\n- [x] 八进制表示法：`0o`或`0O`开头表示二进制`(0oXX或0OXX)`\n- [x] Number.EPSILON：数值最小精度\n- [x] Number.MIN_SAFE_INTEGER：最小安全数值(`-2^53`)\n- [x] Number.MAX_SAFE_INTEGER：最大安全数值(`2^53`)\n- [x] Number.parseInt()：返回转换值的整数部分\n- [x] Number.parseFloat()：返回转换值的浮点数部分\n- [x] Number.isFinite()：是否为有限数值\n- [x] Number.isNaN()：是否为`NaN`\n- [x] Number.isInteger()：是否为整数\n- [x] Number.isSafeInteger()：是否在数值安全范围内\n- [x] Math.trunc()：返回数值整数部分\n- [x] Math.sign()：返回数值类型(正数 1、负数-1、零 0)\n- [x] Math.cbrt()：返回数值立方根\n- [x] Math.clz32()：返回数值的 32 位无符号整数形式\n- [x] Math.imul()：返回两个数值相乘\n- [x] Math.fround()：返回数值的 32 位单精度浮点数形式\n- [x] Math.hypot()：返回所有数值平方和的平方根\n- [x] Math.expm1()：返回`e^n - 1`\n- [x] Math.log1p()：返回`1 + n`的自然对数(`Math.log(1 + n)`)\n- [x] Math.log10()：返回以 10 为底的 n 的对数\n- [x] Math.log2()：返回以 2 为底的 n 的对数\n- [x] Math.sinh()：返回 n 的双曲正弦\n- [x] Math.cosh()：返回 n 的双曲余弦\n- [x] Math.tanh()：返回 n 的双曲正切\n- [x] Math.asinh()：返回 n 的反双曲正弦\n- [x] Math.acosh()：返回 n 的反双曲余弦\n- [x] Math.atanh()：返回 n 的反双曲正切\n\n#### 对象扩展\n\n- [x] 简洁表示法：直接写入变量和函数作为对象的属性和方法({ prop, method() {} })\n- [x] 属性名表达式：字面量定义对象时使用[]定义键([prop]，不能与上同时使用)\n- [x] 方法的 name 属性：返回方法函数名\n  - 取值函数(getter)和存值函数(setter)：get/set 函数名(属性的描述对象在 get 和 set 上)\n  - bind 返回的函数：bound 函数名\n  - Function 构造函数返回的函数实例：anonymous\n\n* [x] 属性的可枚举性和遍历：描述对象的 enumerable\n* [x] super 关键字：指向当前对象的原型对象(只能用在对象的简写方法中 method() {})\n* [x] Object.is()：对比两值是否相等\n* [x] Object.assign()：合并对象(浅拷贝)，返回原对象\n* [x] Object.getPrototypeOf()：返回对象的原型对象\n* [x] Object.setPrototypeOf()：设置对象的原型对象\n* [x] **proto**：返回或设置对象的原型对象\n\n\u003e 属性遍历\n\n- 描述：自身、可继承、可枚举、非枚举、Symbol\n- 遍历\n\n- for-in：遍历对象自身可继承可枚举属性\n- Object.keys()：返回对象自身可枚举属性的键组成的数组\n- Object.getOwnPropertyNames()：返回对象自身可继承可枚举非枚举属性的键组成的数组\n- Object.getOwnPropertySymbols()：返回对象 Symbol 属性的键组成的数组\n- Reflect.ownKeys()：返回对象自身可继承可枚举非枚举 Symbol 属性的键组成的数组\n\n* 规则\n\n* 首先遍历所有数值键，按照数值升序排列\n  其次遍历所有字符串键，按照加入时间升序排列\n  最后遍历所有 Symbol 键，按照加入时间升序排列\n\n#### 数组扩展\n\n- [x] 扩展运算符(...)：转换数组为用逗号分隔的参数序列([...arr]，相当于 rest/spread 参数的逆运算)\n- [x] Array.from()：转换具有 Iterator 接口的数据结构为真正数组，返回新数组\n\n类数组对象：包含 length 的对象、Arguments 对象、NodeList 对象\n可遍历对象：String、Set 结构、Map 结构、Generator 函数\n\n- [x] Array.of()：转换一组值为真正数组，返回新数组\n- [x] copyWithin()：把指定位置的成员复制到其他位置，返回原数组\n- [x] find()：返回第一个符合条件的成员\n- [x] findIndex()：返回第一个符合条件的成员索引值\n- [x] fill()：根据指定值填充整个数组，返回原数组\n- [x] keys()：返回以索引值为遍历器的对象\n- [x] values()：返回以属性值为遍历器的对象\n- [x] entries()：返回以索引值和属性值为遍历器的对象\n- [x] 数组空位：ES6 明确将数组空位转为 undefined(空位处理规不一，建议避免出现)\n\n\u003e 扩展应用\n\n- 克隆数组：const arr = [...arr1]\n- 合并数组：const arr = [...arr1, ...arr2]\n- 拼接数组：arr.push(...arr1)\n- 代替 apply：Math.max.apply(null, [x, y]) =\u003e Math.max(...[x, y])\n- 转换字符串为数组：[...\"hello\"]\n- 转换类数组对象为数组：[...Arguments, ...NodeList]\n- 转换可遍历对象为数组：[...String, ...Set, ...Map, ...Generator]\n- 与数组解构赋值结合：const [x, ...rest/spread] = [1, 2, 3]\n- 计算 Unicode 字符长度：Array.from(\"hello\").length =\u003e [...\"hello\"].length\n\n\u003e 重点难点\n\n- 使用 keys()、values()、entries()返回的遍历器对象，可用 for-of 自动遍历或 next()手动遍历\n\n### 函数扩展\n\n- [x] 参数默认值：为函数参数指定默认值\n\n  - 形式：function Func(x = 1, y = 2) {}\n  - 参数赋值：惰性求值(函数调用后才求值)\n  - 参数位置：尾参数\n  - 参数作用域：函数作用域\n  - 声明方式：默认声明，不能用 const 或 let 再次声明\n  - length：返回没有指定默认值的参数个数\n  - 与解构赋值默认值结合：function Func({ x = 1, y = 2 } = {}) {}\n  - 应用\n\n    - 指定某个参数不得省略，省略即抛出错误：function Func(x = throwMissing()) {}\n    - 将参数默认值设为 undefined，表明此参数可省略：Func(undefined, 1)\n\n  - rest/spread 参数(...)：返回函数多余参数\n\n    - 形式：以数组的形式存在，之后不能再有其他参数\n    - 作用：代替 Arguments 对象\n    - length：返回没有指定默认值的参数个数但不包括 rest/spread 参数\n\n* [x] 严格模式：在严格条件下运行 JS\n\n  - 应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式\n\n- [x] name 属性：返回函数的函数名\n\n  - 将匿名函数赋值给变量：空字符串(ES5)、变量名(ES6)\n  - 将具名函数赋值给变量：函数名(ES5 和 ES6)\n  - bind 返回的函数：bound 函数名(ES5 和 ES6)\n  - Function 构造函数返回的函数实例：anonymous(ES5 和 ES6)\n\n- [x] 箭头函数(=\u003e)：函数简写\n\n  - 无参数：() =\u003e {}\n  - 单个参数：x =\u003e {}\n  - 多个参数：(x, y) =\u003e {}\n  - 解构参数：({x, y}) =\u003e {}\n  - 嵌套使用：部署管道机制\n  - this 指向固定化\n\n    - 并非因为内部有绑定 this 的机制，而是根本没有自己的 this，导致内部的 this 就是外层代码块的 this\n    - 因为没有 this，因此不能用作构造函数\n\n- [x] 尾调用优化：只保留内层函数的调用帧\n\n  - 尾调用\n\n    - 定义：某个函数的最后一步是调用另一个函数\n    - 形式：function f(x) { return g(x); }\n\n  - 尾递归\n\n    - 定义：函数尾调用自身\n    - 作用：只要使用尾递归就不会发生栈溢出，相对节省内存\n    - 实现：把所有用到的内部变量改写成函数的参数并使用参数默认值\n\n\u003e 箭头函数误区\n\n- [x] 函数体内的 this 是定义时所在的对象而不是使用时所在的对象\n- [x] 可让 this 指向固定化，这种特性很有利于封装回调函数\n- [x] 不可当作构造函数，因此箭头函数不可使用 new 命令\n- [x] 不可使用 yield 命令，因此箭头函数不能用作 Generator 函数\n- [x] 不可使用 Arguments 对象，此对象在函数体内不存在(可用 rest/spread 参数代替)\n- [x] 返回对象时必须在对象外面加上括号\n\n正则扩展\n\n变更 RegExp 构造函数入参：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符)\n正则方法调用变更：字符串对象的 match()、replace()、search()、split()内部调用转为调用 RegExp 实例对应的 RegExp.prototype[Symbol.方法]\nu 修饰符：Unicode 模式修饰符，正确处理大于\\uFFFF 的 Unicode 字符\n\n点字符(.)\nUnicode 表示法\n量词\n预定义模式\ni 修饰符\n转义\n\ny 修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与 g 修饰符作用类似)\nunicode：是否设置 u 修饰符\nsticky：是否设置 y 修饰符\nflags：正则表达式的修饰符\n\n重点难点\n\ny 修饰符隐含头部匹配标志^\n单单一个 y 修饰符对 match()只能返回第一个匹配，必须与 g 修饰符联用才能返回所有匹配\n\nSymbol\n\n定义：独一无二的值\n声明：const set = Symbol(str)\n入参：字符串(可选)\n方法\n\nSymbol()：创建以参数作为描述的 Symbol 值(不登记在全局环境)\nSymbol.for()：创建以参数作为描述的 Symbol 值，如存在此参数则返回原有的 Symbol 值(先搜索后创建，登记在全局环境)\nSymbol.keyFor()：返回已登记的 Symbol 值的描述(只能返回 Symbol.for()的 key)\nObject.getOwnPropertySymbols()：返回对象中所有用作属性名的 Symbol 值的数组\n\n内置\n\nSymbol.hasInstance：指向一个内部方法，当其他对象使用 instanceof 运算符判断是否为此对象的实例时会调用此方法\nSymbol.isConcatSpreadable：指向一个布尔值，定义对象用于 Array.prototype.concat()时是否可展开\nSymbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数\nSymbol.match：指向一个函数，当实例对象被 String.prototype.match()调用时会重新定义 match()的行为\nSymbol.replace：指向一个函数，当实例对象被 String.prototype.replace()调用时会重新定义 replace()的行为\nSymbol.search：指向一个函数，当实例对象被 String.prototype.search()调用时会重新定义 search()的行为\nSymbol.split：指向一个函数，当实例对象被 String.prototype.split()调用时会重新定义 split()的行为\nSymbol.iterator：指向一个默认遍历器方法，当实例对象执行 for-of 时会调用指定的默认遍历器\nSymbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值\nSymbol.toStringTag：指向一个函数，当实例对象被 Object.prototype.toString()调用时其返回值会出现在 toString()返回的字符串之中表示对象的类型\nSymbol.unscopables：指向一个对象，指定使用 with 时哪些属性会被 with 环境排除\n\n数据类型\n\nUndefined\nNull\nString\nNumber\nBoolean\nObject(包含 Array、Function、Date、RegExp、Error)\nSymbol\n\n应用场景\n\n唯一化对象属性名：属性名属于 Symbol 类型，就都是独一无二的，可保证不会与其他属性名产生冲突\n消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值\n遍历属性名：无法通过 for-in、for-of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过 Object.getOwnPropertySymbols 返回\n启用模块的 Singleton 模式：调用一个类在任何时候返回同一个实例(window 和 global)，使用 Symbol.for()来模拟全局的 Singleton 模式\n\n重点难点\n\nSymbol()生成一个原始类型的值不是对象，因此 Symbol()前不能使用 new 命令\nSymbol()参数表示对当前 Symbol 值的描述，相同参数的 Symbol()返回值不相等\nSymbol 值不能与其他类型的值进行运算\nSymbol 值可通过 String()或 toString()显式转为字符串\nSymbol 值作为对象属性名时，此属性是公开属性，但不是私有属性\nSymbol 值作为对象属性名时，只能用方括号运算符([])读取，不能用点运算符(.)读取\nSymbol 值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法\n\nSet\nSet\n\n定义：类似于数组的数据结构，成员值都是唯一且没有重复的值\n声明：const set = new Set(arr)\n入参：具有 Iterator 接口的数据结构\n属性\n\nconstructor：构造函数，返回 Set\nsize：返回实例成员总数\n\n方法\n\nadd()：添加值，返回实例\ndelete()：删除值，返回布尔值\nhas()：检查值，返回布尔值\nclear()：清除所有成员\nkeys()：返回以属性值为遍历器的对象\nvalues()：返回以属性值为遍历器的对象\nentries()：返回以属性值和属性值为遍历器的对象\nforEach()：使用回调函数遍历每个成员\n\n应用场景\n\n去重字符串：[...new Set(str)].join(\"\")\n去重数组：[...new Set(arr)]或 Array.from(new Set(arr))\n集合数组\n\n声明：const a = new Set(arr1)、const b = new Set(arr2)\n并集：new Set([...a, ...b])\n交集：new Set([...a].filter(v =\u003e b.has(v)))\n差集：new Set([...a].filter(v =\u003e !b.has(v)))\n\n映射集合\n\n声明：let set = new Set(arr)\n映射：set = new Set([...set].map(v =\u003e v _ 2))或 set = new Set(Array.from(set, v =\u003e v _ 2))\n\n重点难点\n\n遍历顺序：插入顺序\n没有键只有值，可认为键和值两值相等\n添加多个 NaN 时，只会存在一个 NaN\n添加相同的对象时，会认为是不同的对象\n添加值时不会发生类型转换(5 !== \"5\")\nkeys()和 values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等\n\nWeakSet\n\n定义：和 Set 结构类似，成员值只能是对象\n声明：const set = new WeakSet(arr)\n入参：具有 Iterator 接口的数据结构\n属性\n\nconstructor：构造函数，返回 WeakSet\n\n方法\n\nadd()：添加值，返回实例\ndelete()：删除值，返回布尔值\nhas()：检查值，返回布尔值\n\n应用场景\n\n储存 DOM 节点：DOM 节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏\n临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在 WeakSet 结构中的引用就会自动消\n\n重点难点\n\n成员都是弱引用，垃圾回收机制不考虑 WeakSet 结构对此成员的引用\n成员不适合引用，它会随时消失，因此 ES6 规定 WeakSet 结构不可遍历\n其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于 WeakSet 结构中\n\nMap\nMap\n\n定义：类似于对象的数据结构，成员键可以是任何类型的值\n声明：const set = new Map(arr)\n入参：具有 Iterator 接口且每个成员都是一个双元素数组的数据结构\n属性\n\nconstructor：构造函数，返回 Map\nsize：返回实例成员总数\n\n方法\n\nget()：返回键值对\nset()：添加键值对，返回实例\ndelete()：删除键值对，返回布尔值\nhas()：检查键值对，返回布尔值\nclear()：清除所有成员\nkeys()：返回以键为遍历器的对象\nvalues()：返回以值为遍历器的对象\nentries()：返回以键和值为遍历器的对象\nforEach()：使用回调函数遍历每个成员\n\n重点难点\n\n遍历顺序：插入顺序\n对同一个键多次赋值，后面的值将覆盖前面的值\n对同一个对象的引用，被视为一个键\n对同样值的两个实例，被视为两个键\n键跟内存地址绑定，只要内存地址不一样就视为两个键\n添加多个以 NaN 作为键时，只会存在一个以 NaN 作为键的值\nObject 结构提供字符串—值的对应，Map 结构提供值—值的对应\n\nWeakMap\n\n定义：和 Map 结构类似，成员键只能是对象\n声明：const set = new WeakMap(arr)\n入参：具有 Iterator 接口且每个成员都是一个双元素数组的数据结构\n属性\n\nconstructor：构造函数，返回 WeakMap\n\n方法\n\nget()：返回键值对\nset()：添加键值对，返回实例\ndelete()：删除键值对，返回布尔值\nhas()：检查键值对，返回布尔值\n\n应用场景\n\n储存 DOM 节点：DOM 节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏\n部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏\n\n重点难点\n\n成员键都是弱引用，垃圾回收机制不考虑 WeakMap 结构对此成员键的引用\n成员键不适合引用，它会随时消失，因此 ES6 规定 WeakMap 结构不可遍历\n其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于 WeakMap 结构中\n一旦不再需要，成员会自动消失，不用手动删除引用\n弱引用的只是键而不是值，值依然是正常引用\n即使在外部消除了成员键的引用，内部的成员值依然存在\n\nProxy\n\n定义：修改某些操作的默认行为\n声明：const proxy = new Proxy(target, handler)\n入参\n\ntarget：拦截的目标对象\nhandler：定制拦截行为\n\n方法\n\nProxy.revocable()：返回可取消的 Proxy 实例(返回{ proxy, revoke }，通过 revoke()取消代理)\n\n拦截方式\n\nget()：拦截对象属性读取\nset()：拦截对象属性设置，返回布尔值\nhas()：拦截对象属性检查 k in obj，返回布尔值\ndeleteProperty()：拦截对象属性删除 delete obj[k]，返回布尔值\ndefineProperty()：拦截对象属性定义 Object.defineProperty()、Object.defineProperties()，返回布尔值\nownKeys()：拦截对象属性遍历 for-in、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()，返回数组\ngetOwnPropertyDescriptor()：拦截对象属性描述读取 Object.getOwnPropertyDescriptor()，返回对象\ngetPrototypeOf()：拦截对象原型读取 instanceof、Object.getPrototypeOf()、Object.prototype.**proto**、Object.prototype.isPrototypeOf()、Reflect.getPrototypeOf()，返回对象\nsetPrototypeOf()：拦截对象原型设置 Object.setPrototypeOf()，返回布尔值\nisExtensible()：拦截对象是否可扩展读取 Object.isExtensible()，返回布尔值\npreventExtensions()：拦截对象不可扩展设置 Object.preventExtensions()，返回布尔值\napply()：拦截 Proxy 实例作为函数调用 proxy()、proxy.apply()、proxy.call()\nconstruct()：拦截 Proxy 实例作为构造函数调用 new proxy()\n\n应用场景\n\nProxy.revocable()：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问\nget()：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成 DOM 嵌套节点\nset()：数据绑定(Vue 数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写\nhas()：隐藏内部属性不被发现、排除不符合属性条件的对象\ndeleteProperty()：保护内部属性不被删除\ndefineProperty()：阻止属性被外部定义\nownKeys()：保护内部属性不被遍历\n\n重点难点\n\n要使 Proxy 起作用，必须针对实例进行操作，而不是针对目标对象进行操作\n没有设置任何拦截时，等同于直接通向原对象\n属性被定义为不可读写/扩展/配置/枚举时，使用拦截方法会报错\n代理下的目标对象，内部 this 指向 Proxy 代理\n\nReflect\n\n定义：保持 Object 方法的默认行为\n方法\n\nget()：返回对象属性\nset()：设置对象属性，返回布尔值\nhas()：检查对象属性，返回布尔值\ndeleteProperty()：删除对象属性，返回布尔值\ndefineProperty()：定义对象属性，返回布尔值\nownKeys()：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())\ngetOwnPropertyDescriptor()：返回对象属性描述，返回对象\ngetPrototypeOf()：返回对象原型，返回对象\nsetPrototypeOf()：设置对象原型，返回布尔值\nisExtensible()：返回对象是否可扩展，返回布尔值\npreventExtensions()：设置对象不可扩展，返回布尔值\napply()：绑定 this 后执行指定函数\nconstruct()：调用构造函数创建实例\n\n设计目的\n\n将 Object 属于语言内部的方法放到 Reflect 上\n将某些 Object 方法报错情况改成返回 false\n让 Object 操作变成函数行为\nProxy 与 Reflect 相辅相成\n\n废弃方法\n\nObject.defineProperty() =\u003e Reflect.defineProperty()\nObject.getOwnPropertyDescriptor() =\u003e Reflect.getOwnPropertyDescriptor()\n\n重点难点\n\nProxy 方法和 Reflect 方法一一对应\nProxy 和 Reflect 联合使用，前者负责拦截赋值操作，后者负责完成赋值操作\n\n数据绑定：观察者模式\n\nconst observerQueue = new Set();\nconst observe = fn =\u003e observerQueue.add(fn);\nconst observable = obj =\u003e new Proxy(obj, {\nset(tgt, key, val, receiver) {\nconst result = Reflect.set(tgt, key, val, receiver);\nobserverQueue.forEach(v =\u003e v());\nreturn result;\n}\n});\n\nconst person = observable({ age: 25, name: \"Yajun\" });\nconst print = () =\u003e console.log(`${person.name} is ${person.age} years old`);\nobserve(print);\nperson.name = \"Joway\";\n复制代码 Class\n\n定义：对一类具有共同特征的事物的抽象(构造函数语法糖)\n原理：类本身指向构造函数，所有方法定义在 prototype 上，可看作构造函数的另一种写法(Class === Class.prototype.constructor)\n方法和关键字\n\nconstructor()：构造函数，new 命令生成实例时自动调用\nextends：继承父类\nsuper：新建父类的 this\nstatic：定义静态属性方法\nget：取值函数，拦截属性的取值行为\nset：存值函数，拦截属性的存值行为\n\n属性\n\n**proto**：构造函数的继承(总是指向父类)\n**proto**.**proto**：子类的原型的原型，即父类的原型(总是指向父类的**proto**)\nprototype.**proto**：属性方法的继承(总是指向父类的 prototype)\n\n静态属性：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用\n静态方法：使用 static 定义方法，该方法不会被实例继承，只能通过类来调用(方法中的 this 指向类，而不是实例)\n继承\n\n实质\n\nES5 实质：先创造子类实例的 this，再将父类的属性方法添加到 this 上(Parent.apply(this))\nES6 实质：先将父类实例的属性方法加到 this 上(调用 super())，再用子类构造函数修改 this\n\nsuper\n\n作为函数调用：只能在构造函数中调用 super()，内部 this 指向继承的当前子类(super()调用后才可在构造函数中使用 this)\n作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类\n\n显示定义：使用 constructor() { super(); }定义继承父类，没有书写则显示定义\n子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用 super()，否则得不到父类的 this\n\n父类静态属性方法可被子类继承\n子类继承父类后，可从 super 上调用父类静态属性方法\n\n实例：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承\n\n显式指定属性方法：使用 this 指定到自身上(使用 Class.hasOwnProperty()可检测到)\n隐式指定属性方法：直接声明定义在对象原型上(使用 Class.**proto**.hasOwnProperty()可检测到)\n\n表达式\n\n类表达式：const Class = class {}\nname 属性：返回紧跟 class 后的类名\n属性表达式：[prop]\nGenerator 方法：\\* mothod() {}\nAsync 方法：async mothod() {}\n\nthis 指向：解构实例属性或方法时会报错\n\n绑定 this：this.mothod = this.mothod.bind(this)\n箭头函数：this.mothod = () =\u003e this.mothod()\n\n属性定义位置\n\n定义在构造函数中并使用 this 指向\n定义在类最顶层\n\nnew.target：确定构造函数是如何调用\n\n原生构造函数\n\nString()\nNumber()\nBoolean()\nArray()\nObject()\nFunction()\nDate()\nRegExp()\nError()\n\n重点难点\n\n在实例上调用方法，实质是调用原型上的方法\nObject.assign()可方便地一次向类添加多个方法(Object.assign(Class.prototype, { ... }))\n类内部所有定义的方法是不可枚举的(non-enumerable)\n构造函数默认返回实例对象(this)，可指定返回另一个对象\n取值函数和存值函数设置在属性的 Descriptor 对象上\n类不存在变量提升\n利用 new.target === Class 写出不能独立使用必须继承后才能使用的类\n子类继承父类后，this 指向子类实例，通过 super 对某个属性赋值，赋值的属性会变成子类实例的属性\n使用 super 时，必须显式指定是作为函数还是作为对象使用\nextends 不仅可继承类还可继承原生的构造函数\n\n私有属性方法\n\nconst name = Symbol(\"name\");\nconst print = Symbol(\"print\");\nclass Person {\nconstructor(age) {\nthis[name] = \"Bruce\";\nthis.age = age;\n}\n[print]() {\nconsole.log(`${this[name]} is ${this.age} years old`);\n}\n}\n复制代码\n继承混合类\n\nfunction CopyProperties(target, source) {\nfor (const key of Reflect.ownKeys(source)) {\nif (key !== \"constructor\" \u0026\u0026 key !== \"prototype\" \u0026\u0026 key !== \"name\") {\nconst desc = Object.getOwnPropertyDescriptor(source, key);\nObject.defineProperty(target, key, desc);\n}\n}\n}\nfunction MixClass(...mixins) {\nclass Mix {\nconstructor() {\nfor (const mixin of mixins) {\nCopyProperties(this, new mixin());\n}\n}\n}\nfor (const mixin of mixins) {\nCopyProperties(Mix, mixin);\nCopyProperties(Mix.prototype, mixin.prototype);\n}\nreturn Mix;\n}\nclass Student extends MixClass(Person, Kid) {}\n复制代码 Module\n\n命令\n\nexport：规定模块对外接口\n\n默认导出：export default Person(导入时可指定模块任意名称，无需知晓内部真实名称)\n单独导出：export const name = \"Bruce\"\n按需导出：export { age, name, sex }(推荐)\n改名导出：export { name as newName }\n\nimport：导入模块内部功能\n\n默认导入：import Person from \"person\"\n整体导入：import \\* as Person from \"person\"\n按需导入：import { age, name, sex } from \"person\"\n改名导入：import { name as newName } from \"person\"\n自执导入：import \"person\"\n复合导入：import Person, { name } from \"person\"\n\n复合模式：export 命令和 import 命令结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量\n\n默认导入导出：export { default } from \"person\"\n整体导入导出：export \\* from \"person\"\n按需导入导出：export { age, name, sex } from \"person\"\n改名导入导出：export { name as newName } from \"person\"\n具名改默认导入导出：export { name as default } from \"person\"\n默认改具名导入导出：export { default as name } from \"person\"\n\n继承：默认导出和改名导出结合使用可使模块具备继承性\n设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量\n严格模式：ES6 模块自动采用严格模式(不管模块头部是否添加 use strict)\n\n模块方案\n\nCommonJS：用于服务器(动态化依赖)\nAMD：用于浏览器(动态化依赖)\nCMD：用于浏览器(动态化依赖)\nUMD：用于浏览器和服务器(动态化依赖)\nESM：用于浏览器和服务器(静态化依赖)\n\n加载方式\n\n运行时加载\n\n定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)\n影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化\n\n编译时加载\n\n定义：直接从模块中获取需要的属性和方法进行加载(按需加载)\n影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展 JS 高级语法(宏和类型校验)\n\n加载实现\n\n传统加载：通过\u003cscript\u003e进行同步或异步加载脚本\n\n同步加载：\u003cscript src=\"\"\u003e\u003c/script\u003e\nDefer 异步加载：\u003cscript src=\"\" defer\u003e\u003c/script\u003e(顺序加载，渲染完再执行)\nAsync 异步加载：\u003cscript src=\"\" async\u003e\u003c/script\u003e(乱序加载，下载完就执行)\n\n模块加载：\u003cscript type=\"module\" src=\"\"\u003e\u003c/script\u003e(默认是 Defer 异步加载)\n\nCommonJS 和 ESM 的区别\n\nCommonJS 输出值的拷贝，ESM 输出值的引用\n\nCommonJS 一旦输出一个值，模块内部的变化就影响不到这个值\nESM 是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值\n\nCommonJS 是运行时加载，ESM 是编译时加载\n\nCommonJS 加载模块是对象(即 module.exports)，该对象只有在脚本运行完才会生成\nESM 加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成\n\nNode 加载\n\n背景：CommonJS 和 ESM 互不兼容，目前解决方案是将两者分开，采用各自的加载方案\n区分：要求 ESM 采用.mjs 后缀文件名\n\nrequire()不能加载.mjs 文件，只有 import 命令才可加载.mjs 文件\n.mjs 文件里不能使用 require()，必须使用 import 命令加载文件\n\n驱动：node --experimental-modules file.mjs\n限制：Node 的 import 命令目前只支持加载本地模块(file:协议)，不支持加载远程模块\n加载优先级\n\n脚本文件省略后缀名：依次尝试加载四个后缀名文件(.mjs、.js、.json、node)\n以上不存在：尝试加载 package.json 的 main 字段指定的脚本\n以上不存在：依次尝试加载名称为 index 四个后缀名文件(.mjs、.js、.json、node)\n以上不存在：报错\n\n不存在的内部变量：arguments、exports、module、require、this、**dirname、**filename\nCommonJS 加载 ESM\n\n不能使用 require()，只能使用 import()\n\nESM 加载 CommonJS\n\n自动将 module.exports 转化成 export default\nCommonJS 输出缓存机制在 ESM 加载方式下依然有效\n采用 import 命令加载 CommonJS 模块时，不允许采用按需导入，应使用默认导入或整体导入\n\n循环加载\n\n定义：脚本 A 的执行依赖脚本 B，而脚本 A 的执行又依赖脚本 B\n加载原理\n\nCommonJS：require()首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取\nESM：import 命令加载变量不会被缓存，而是成为一个指向被加载模块的引用\n\n循环加载\n\nCommonJS：只输出已经执行的部分，还未执行的部分不会输出\nESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)\n\n重点难点\n\nES6 模块中，顶层 this 指向 undefined，不应该在顶层代码使用 this\n一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取\nexport 命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值\nimport 命令大括号里的变量名必须与被导入模块对外接口的名称相同\nimport 命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口\nimport 命令命令具有提升效果，会提升到整个模块的头部，首先执行\n重复执行同一句 import 语句，只会执行一次\nexport default 命令只能使用一次\nexport default 命令导出的整体模块，在执行 import 命令时其后不能跟大括号\nexport default 命令本质是输出一个名为 default 的变量，后面不能跟变量声明语句\nexport default 命令本质是将后面的值赋给名为 default 的变量，可直接将值写在其后\nexport default 命令和 export {}命令可同时存在，对应复合导入\nexport 命令和 import 命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域\nimport()加载模块成功后，此模块会作为一个对象，当作 then()的参数，可使用对象解构赋值来获取输出接口\n同时动态加载多个模块时，可使用 Promise.all()和 import()相结合来实现\nimport()和结合 async/await 来书写同步操作的代码\n\n单例模式：跨模块常量\n\n// 常量跨文件共享\n// person.js\nconst NAME = \"Bruce\";\nconst AGE = 25;\nconst SEX = \"male\";\nexport { AGE, NAME, SEX };\n复制代码// file1.js\nimport { AGE } from \"person\";\nconsole.log(AGE);\n复制代码// file2.js\nimport { AGE, NAME, SEX } from \"person\";\nconsole.log(AGE, NAME, SEX);\n复制代码\n默认导入互换整体导入\n\nimport Person from \"person\";\nconsole.log(Person.AGE);\n复制代码 import \\* as Person from \"person\";\nconsole.log(Person.default.AGE);\n复制代码 Iterator\n\n定义：为各种不同的数据结构提供统一的访问机制\n原理：创建一个指针指向首个成员，按照次序使用 next()指向下一个成员，直接到结束位置(数据结构只要部署 Iterator 接口就可完成遍历操作)\n作用\n\n为各种数据结构提供一个统一的简便的访问接口\n使得数据结构成员能够按某种次序排列\nES6 创造了新的遍历命令 for-of，Iterator 接口主要供 for-of 消费\n\n形式：for-of(自动去寻找 Iterator 接口)\n数据结构\n\n集合：Array、Object、Set、Map\n原生具备接口的数据结构：String、Array、Set、Map、TypedArray、Arguments、NodeList\n\n部署：默认部署在 Symbol.iterator(具备此属性被认为可遍历的 iterable)\n遍历器对象\n\nnext()：下一步操作，返回{ done, value }(必须部署)\nreturn()：for-of 提前退出调用，返回{ done: true }\nthrow()：不使用，配合 Generator 函数使用\n\nForOf 循环\n\n定义：调用 Iterator 接口产生遍历器对象(for-of 内部调用数据结构的 Symbol.iterator())\n遍历字符串：for-in 获取索引，for-of 获取值(可识别 32 位 UTF-16 字符)\n遍历数组：for-in 获取索引，for-of 获取值\n遍历对象：for-in 获取键，for-of 需自行部署\n遍历 Set：for-of 获取值 =\u003e for (const v of set)\n遍历 Map：for-of 获取键值对 =\u003e for (const [k, v] of map)\n遍历类数组：包含 length 的对象、Arguments 对象、NodeList 对象(无 Iterator 接口的类数组可用 Array.from()转换)\n计算生成数据结构：Array、Set、Map\n\nkeys()：返回遍历器对象，遍历所有的键\nvalues()：返回遍历器对象，遍历所有的值\nentries()：返回遍历器对象，遍历所有的键值对\n\n与 for-in 区别\n\n有着同 for-in 一样的简洁语法，但没有 for-in 那些缺点、\n不同于 forEach()，它可与 break、continue 和 return 配合使用\n提供遍历所有数据结构的统一操作接口\n\n应用场景\n\n改写具有 Iterator 接口的数据结构的 Symbol.iterator\n解构赋值：对 Set 进行结构\n扩展运算符：将部署 Iterator 接口的数据结构转为数组\nyield*：yield*后跟一个可遍历的数据结构，会调用其遍历器接口\n接受数组作为参数的函数：for-of、Array.from()、new Set()、new WeakSet()、new Map()、new WeakMap()、Promise.all()、Promise.race()\n\nPromise\n\n定义：包含异步操作结果的对象\n状态\n\n进行中：pending\n已成功：resolved\n已失败：rejected\n\n特点\n\n对象的状态不受外界影响\n一旦状态改变就不会再变，任何时候都可得到这个结果\n\n声明：new Promise((resolve, reject) =\u003e {})\n出参\n\nresolve：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去\nreject：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去\n\n方法\n\nthen()：分别指定 resolved 状态和 rejected 状态的回调函数\n\n第一参数：状态变为 resolved 时调用\n第二参数：状态变为 rejected 时调用(可选)\n\ncatch()：指定发生错误时的回调函数\nPromise.all()：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)\n\n入参：具有 Iterator 接口的数据结构\n成功：只有全部实例状态变成 resolved，最终状态才会变成 resolved\n失败：其中一个实例状态变成 rejected，最终状态就会变成 rejected\n\nPromise.race()：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)\nPromise.resolve()：将对象转为 Promise 对象(等价于 new Promise(resolve =\u003e resolve()))\n\nPromise 实例：原封不动地返回入参\nThenable 对象：将此对象转为 Promise 对象并返回(Thenable 为包含 then()的对象，执行 then()相当于执行此对象的 then())\n不具有 then()的对象：将此对象转为 Promise 对象并返回，状态为 resolved\n不带参数：返回 Promise 对象，状态为 resolved\n\nPromise.reject()：将对象转为状态为 rejected 的 Promise 对象(等价于 new Promise((resolve, reject) =\u003e reject()))\n\n应用场景\n\n加载图片\nAJAX 转 Promise 对象\n\n重点难点\n\n只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态\n状态改变只有两种可能：从 pending 变为 resolved、从 pending 变为 rejected\n一旦新建 Promise 对象就会立即执行，无法中途取消\n不设置回调函数，内部抛错不会反应到外部\n当处于 pending 时，无法得知目前进展到哪一个阶段\n实例状态变为 resolved 或 rejected 时，会触发 then()绑定的回调函数\nresolve()和 reject()的执行总是晚于本轮循环的同步任务\nthen()返回新实例，其后可再调用另一个 then()\nthen()运行中抛出错误会被 catch()捕获\nreject()的作用等同于抛出错误\n实例状态已变成 resolved 时，再抛出错误是无效的，不会被捕获，等于没有抛出\n实例状态的错误具有冒泡性质，会一直向后传递直到被捕获为止，错误总是会被下一个 catch()捕获\n不要在 then()里定义 rejected 状态的回调函数(不使用其第二参数)\n建议使用 catch()捕获错误，不要使用 then()第二个参数捕获\n没有使用 catch()捕获错误，实例抛错不会传递到外层代码，即不会有任何反应\n作为参数的实例定义了 catch()，一旦被 rejected 并不会触发 Promise.all()的 catch()\nPromise.reject()的参数会原封不动地作为 rejected 的理由，变成后续方法的参数\n\nGenerator\n\n定义：封装多个内部状态的异步编程解决方案\n形式：调用 Generator 函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果)\n声明：function\\* Func() {}\n方法\n\nnext()：使指针移向下一个状态，返回{ done, value }(入参会被当作上一个 yield 命令表达式的返回值)\nreturn()：返回指定值且终结遍历 Generator 函数，返回{ done: true, value: 入参 }\nthrow()：在 Generator 函数体外抛出错误，在 Generator 函数体内捕获错误，返回自定义的 new Errow()\n\nyield 命令：声明内部状态的值(return 声明结束返回的值)\n\n遇到 yield 命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的 value\n下次调用 next()时，再继续往下执行直到遇到下一个 yield 命令\n没有再遇到 yield 命令就一直运行到 Generator 函数结束，直到遇到 return 语句为止并将其后表达式的值作为返回对象的 value\nGenerator 函数没有 return 语句则返回对象的 value 为 undefined\n\nyield\\*命令：在一个 Generator 函数里执行另一个 Generator 函数(后随具有 Iterator 接口的数据结构)\n遍历：通过 for-of 自动调用 next()\n作为对象属性\n\n全写：const obj = { method: function*() {} }\n简写：const obj = { * method() {} }\n\n上下文：执行产生的上下文环境一旦遇到 yield 命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行 next()时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行\n\n方法异同\n\n相同点：next()、throw()、return()本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换 yield 命令\n不同点\n\nnext()：将 yield 命令替换成一个值\nreturn()：将 yield 命令替换成一个 return 语句\nthrow()：将 yield 命令替换成一个 throw 语句\n\n应用场景\n\n异步操作同步化表达\n控制流管理\n为对象部署 Iterator 接口：把 Generator 函数赋值给对象的 Symbol.iterator，从而使该对象具有 Iterator 接口\n作为具有 Iterator 接口的数据结构\n\n重点难点\n\n每次调用 next()，指针就从函数头部或上次停下的位置开始执行，直到遇到下一个 yield 命令或 return 语句为止\n函数内部可不用 yield 命令，但会变成单纯的暂缓执行函数(还是需要 next()触发)\nyield 命令是暂停执行的标记，next()是恢复执行的操作\nyield 命令用在另一个表达式中必须放在圆括号里\nyield 命令用作函数参数或放在赋值表达式的右边，可不加圆括号\nyield 命令本身没有返回值，可认为是返回 undefined\nyield 命令表达式为惰性求值，等 next()执行到此才求值\n函数调用后生成遍历器对象，此对象的 Symbol.iterator 是此对象本身\n在函数运行的不同阶段，通过 next()从外部向内部注入不同的值，从而调整函数行为\n首个 next()用来启动遍历器对象，后续才可传递参数\n想首次调用 next()时就能输入值，可在函数外面再包一层\n一旦 next()返回对象的 done 为 true，for-of 遍历会中止且不包含该返回对象\n函数内部部署 try-finally 且正在执行 try，那么 return()会导致立刻进入 finally，执行完 finally 以后整个函数才会结束\n函数内部没有部署 try-catch，throw()抛错将被外部 try-catch 捕获\nthrow()抛错要被内部捕获，前提是必须至少执行过一次 next()\nthrow()被捕获以后，会附带执行下一条 yield 命令\n函数还未开始执行，这时 throw()抛错只可能抛出在函数外部\n\n首次 next()可传值\n\nfunction Wrapper(func) {\nreturn function(...args) {\nconst generator = func(...args);\ngenerator.next();\nreturn generator;\n}\n}\nconst print = Wrapper(function\\*() {\nconsole.log(`First Input: ${yield}`);\nreturn \"done\";\n});\nprint().next(\"hello\");\n复制代码 ES2016\n\n数值扩展\n\n指数运算符(\\*\\*)：数值求幂(相当于 Math.pow())\n\n数组扩展\n\nincludes()：是否存在指定成员\n\nES2017\n\n声明\n\n共享内存和原子操作：由全局对象 SharedArrayBuffer 和 Atomics 实现，将数据存储在一块共享内存空间中，这些数据可在 JS 主线程和 web-worker 线程之间共享\n\n字符串扩展\n\npadStart()：把指定字符串填充到字符串头部，返回新字符串\npadEnd()：把指定字符串填充到字符串尾部，返回新字符串\n\n对象扩展\n\nObject.getOwnPropertyDescriptors()：返回对象所有自身属性(非继承属性)的描述对象\nObject.values()：返回以值组成的数组\nObject.entries()：返回以键和值组成的数组\n\n函数扩展\n\n函数参数尾逗号：允许函数最后一个参数有尾逗号\n\nAsync\n\n定义：使异步函数以同步函数的形式书写(Generator 函数语法糖)\n原理：将 Generator 函数和自动执行器 spawn 包装在一个函数里\n形式：将 Generator 函数的\\*替换成 async，将 yield 替换成 await\n声明\n\n具名函数：async function Func() {}\n函数表达式：const func = async function() {}\n箭头函数：const func = async() =\u003e {}\n对象方法：const obj = { async func() {} }\n类方法：class Cla { async Func() {} }\n\nawait 命令：等待当前 Promise 对象状态变更完毕\n\n正常情况：后面是 Promise 对象则返回其结果，否则返回对应的值\n后随 Thenable 对象：将其等同于 Promise 对象返回其结果\n\n错误处理：将 await 命令 Promise 对象放到 try-catch 中(可放多个)\n\nAsync 对 Generator 改进\n\n内置执行器\n更好的语义\n更广的适用性\n返回值是 Promise 对象\n\n应用场景\n\n按顺序完成异步操作\n\n重点难点\n\nAsync 函数返回 Promise 对象，可使用 then()添加回调函数\n内部 return 返回值会成为后续 then()的出参\n内部抛出错误会导致返回的 Promise 对象变为 rejected 状态，被 catch()接收到\n返回的 Promise 对象必须等到内部所有 await 命令 Promise 对象执行完才会发生状态改变，除非遇到 return 语句或抛出错误\n任何一个 await 命令 Promise 对象变为 rejected 状态，整个 Async 函数都会中断执行\n希望即使前一个异步操作失败也不要中断后面的异步操作\n\n将 await 命令 Promise 对象放到 try-catch 中\nawait 命令 Promise 对象跟一个 catch()\n\nawait 命令 Promise 对象可能变为 rejected 状态，最好把其放到 try-catch 中\n多个 await 命令 Promise 对象若不存在继发关系，最好让它们同时触发\nawait 命令只能用在 Async 函数之中，否则会报错\n数组使用 forEach()执行 async/await 会失效，可使用 for-of 和 Promise.all()代替\n可保留运行堆栈，函数上下文随着 Async 函数的执行而存在，执行完成就消失\n\nES2018\n\n字符串扩展\n\n放松对标签模板里字符串转义的限制：遇到不合法的字符串转义返回 undefined，并且从 raw 上可获取原字符串\n\n对象扩展\n\n扩展运算符(...)：转换对象为用逗号分隔的参数序列({ ...obj }，相当于 rest/spread 参数的逆运算)\n\n扩展应用\n\n克隆对象：const obj = { **proto**: Object.getPrototypeOf(obj1), ...obj1 }\n合并对象：const obj = { ...obj1, ...obj2 }\n转换字符串为对象：{ ...\"hello\" }\n转换数组为对象：{ ...[1, 2] }\n与对象解构赋值结合：const { x, ...rest/spread } = { x: 1, y: 2, z: 3 }(不能复制继承自原型对象的属性)\n修改现有对象部分属性：const obj = { x: 1, ...{ x: 2 } }\n\n### 正则扩展\n\n[x] s 修饰符：dotAll 模式修饰符，使.匹配任意单个字符(dotAll 模式)\n[x] dotAll：是否设置 s 修饰符\n[x] 后行断言：x 只有在 y 后才匹配\n[x] 后行否定断言：x 只有不在 y 后才匹配\n[x] Unicode 属性转义：匹配符合 Unicode 某种属性的所有字符\n\n- 正向匹配：\\p{PropRule}\n- 反向匹配：\\P{PropRule}\n- 限制：\\p{...}和\\P{...}只对 Unicode 字符有效，使用时需加上 u 修饰符\n\n[x] 具名组匹配：为每组匹配指定名字(?\u003cGroupName\u003e)\n\n- 形式：str.exec().groups.GroupName\n- 解构赋值替换\n\n  - 声明：const time = \"2017-09-11\"、const regexp = /(?\u003cyear\u003e\\d{4})-(?\u003cmonth\u003e\\d{2})-(?\u003cday\u003e\\d{2})/u\n  - 匹配：time.replace(regexp, \"$\u003cday\u003e/$\u003cmonth\u003e/\\$\u003cyear\u003e\")\n\n### Promise\n\n[x] finally()：指定不管最后状态如何都会执行的回调函数\n\n### Async\n\n[x] 异步迭代器(for-await-of)：，循环等待每个 ```Promise``` 对象变为 ```resolved``` 状态才进入下一步\n\n## ES2019\n\n![ES2019](https://user-gold-cdn.xitu.io/2019/12/12/16ef8c141926fe7a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### 字符串扩展\n\n[x] **直接输入 U+2028 和 U+2029**：字符串可直接输入行分隔符和段分隔符\n[x] **JSON.stringify()**改造：可返回不符合 UTF-8 标准的字符串\n[x] **trimStart()**：消除字符串头部空格，返回新字符串\n[x] **trimEnd()**：消除字符串尾部空格，返回新字符串\n\n### 对象扩展\n\n[x] **Object.fromEntries()**：返回以键和值组成的对象(```Object.entries()```的逆操作)\n\n### 数组扩展\n\n[x] **flat()**：扁平化数组，返回新数组(默认展开一层数组)\n[x] **flatMap()**：映射且扁平化数组，返回新数组(只能展开一层数组)\n\n### 函数扩展\n\n[x] toString()改造：返回函数原始代码(与编码一致)\n[x] catch()参数可省略：```catch()```中的参数可省略\n\n### Symbol\n\n[x] description：返回 ```Symbol``` 值的描述\n\n## ES 提案\n\n![ES 提案](https://user-gold-cdn.xitu.io/2019/12/12/16ef8c1425aa671b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n### 声明\n\n[x] **globalThis 对象**：作为顶层对象，指向全局环境下的 this\n[x] **do 表达式**：封装块级作用域的操作，返回内部最后执行表达式的值(do{})\n[x] **throw 表达式**：直接使用 throw new Error()，无需()或{}包括\n[x] **!#命令**：指定脚本执行器(写在文件首行)\n\n### 数值扩展\n\n[x] 数值分隔符(_)：使用```_```作为千分位分隔符(增加数值的可读性)\n[x] BigInt()：创建任何位数的整数(新增的数据类型，使用 ```n``` 结尾)\n\n### 对象扩展\n\n[x] 链判断操作符(?.)：是否存在对象属性(不存在返回 undefined 且不再往下执行)\n[x] 空判断操作符(??)：是否值为 undefined 或 null，是则使用默认值\n\n### 函数扩展\n\n[x] 函数部分执行：复用函数功能(```?```表示单个参数占位符，```...```表示多个参数占位符)\n[x] 管道操作符(|\u003e)：把左边表达式的值传入右边的函数进行求值(```f(x)``` =\u003e ```x |\u003e f```)\n[x] 绑定运算符(::)：函数绑定(左边是对象右边是函数，取代 bind、apply、call 调用)\n\n- bind：```bar.bind(foo) =\u003e foo::bar```\n- apply：```bar.apply(foo, arguments) =\u003e foo::bar(...arguments)```\n\n### Proxy\n\n[x] Promise.try()：不想区分是否同步异步函数，包装函数为实例，使用 then()指定下一步流程，使用 catch()捕获错误\n\n### Realm\n\n[x] 定义：提供沙箱功能，允许隔离代码，防止被隔离的代码拿到全局对象\n[x] 声明：new Realm().global\n\n### Class\n\n[x] 静态属性：使用 static 定义属性，该属性不会被实例继承，只能通过类来调用\n[x] 私有属性：使用#定义属性，该属性只能在类内部访问\n[x] 私有方法：使用#定义方法，该方法只能在类内部访问\n[x] 装饰器：使用@注释或修改类和类方法\n\n### Module\n\n[x] import()：动态导入(返回 Promise)\n\n- 背景：import 命令被 JS 引擎静态分析，先于模块内的其他语句执行，无法取代 require()的动态加载功能，提案建议引入 import()来代替 require()\n- 位置：可在任何地方使用\n- 区别：require()是同步加载，import()是异步加载\n- 场景：按需加载、条件加载、模块路径动态化\n\n[x] import.meta：返回脚本元信息\n\n### Async\n\n[x] **顶层 Await**：允许在模块的顶层独立使用 await 命令(借用 await 解决模块异步加载的问题)\n\n### 结语\n\n![ES-all](https://user-gold-cdn.xitu.io/2019/12/12/16ef8c1427cebcde?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)","like_users":[],"create_time":{"$date":"2019-10-13T03:48:01.725Z"},"update_time":{"$date":"2019-10-13T03:48:01.725Z"},"id":11,"__v":0}
{"_id":{"$oid":"5db15f5553af0700308855ea"},"meta":{"views":18,"likes":0,"comments":0},"keyword":["npm"],"desc":"NPM命令实用使用技巧总结","numbers":"4101","img_url":"http://img.golderbrother.cn/npm.svg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5db15e1a53af0700308855e8"}],"comments":[],"category":[{"$oid":"5db15e2553af0700308855e9"}],"title":"NPM命令实用使用技巧总结","author":"golderBrother","content":"### 使用技巧总结\n如果你日常工作中有使用 NPM ，我相信你会喜欢这些使用技巧的。\n\n#### **创建项目**\n我们经常使用``` npm init ```来创建项目，并按照提示输入项目信息(项目名称、作者等)，但是，如果我们并不关心项目信息，并且保留默认值，那么我们对 npm 请求的每条数据按 Enter 键即可。\n事实上，我们只需要使用``` npm init -y ```,这个命令就可以达到直接使用默认值信息建一个项目。\n\n#### **安装模块**\n使用``` npm install ```来安装，你可以使用其简写```npm i ```\n\n#### **一次性安装多个模块**\n无需为你要安装的每个模块都输入一遍``` npm i ```指令，像这样：\n```\nnpm i gulp-pug\nnpm i gulp-debug\nnpm i gulp-sass\n```\n\n你只需要输入一行命令即可一次性批量安装模块\n```\nnpm i gulp-pug gulp-debug gulp-sass\n```\n\n更快捷的是，如果安装的所有模块的前缀是相同的，则可以这样安装，无需输入完整模块名\n```\nnpm i gulp{-debug,-sass,-pug}\n```\n\n#### **使用一些安装标志的快捷方式**\n如果你想安装一些包到生产环境依赖下面，你通常是这样安装：\n```\nnpm i gulp --save-prod\n```\n\n更简化，你可以使用-P标志，这样安装：\n```\nnpm i gulp -P\n```\n\n同理，开发环境下的依赖安装，你可以用``` -D ```代替``` --save-dev ```\n\n```\nnpm i gulp -D\n```\n\n当你不带任何安装标志时，``` npm ```默认将模块作为依赖项目添加到``` package.json ```文件中。如果你想避免这样，你可以使用``` no-save ```,这样安装：\n```\nnpm i vue --no-save\n```\n\n#### **获取安装包信息**\n使用``` npm view xxx ```或``` npm v xxx ```可以查看包信息，例如：\n如果你只是想看安装包最近的版本信息，你可以这样：\n```\n\u003e npm v vue version\n\u003e 2.5.17\n```\n\n如果你想获取安装包完整的版本信息列表，你可以使用复数形式，例如：\n```\n\u003e npm v vue versions\n\u003e [ '0.0.0',\n  '0.6.0',\n  '0.7.0',\n  ...\n  '2.5.15',\n  '2.5.16',\n  '2.5.17-beta.0',\n  '2.5.17' ]\n```\n\n#### **安装指定版本安装包**\n如果你想安装一个不是最新版本的安装包，你可以指定某个版本来安装，如：\n```\nnpm i vue@2.5.15\n```\n\n鉴于记住标签比记住版本数字容易多了，你可以使用用``` npm v ```命令来查到的版本信息列表里面的``` dist-tag ```来安装,比如：\n```\nnpm i vue@beta\n```\n\n#### **搜索安装包**\n有时候你不能明确记得你曾经使用过的或者朋友推荐的包名，这种情况下，你可以使用``` npm search ```从终端直接执行搜索，如：\n```\nnpm search gulp debug\n```\n\n或者\n\n```\nnpm s gulp debug\n```\n\n这将打印出包含说明、作者等其他信息的安装包列表。如图：\n\n#### **卸载包**\n如果你不想转到``` package.json ```文件并手动删除依赖包，则可以用以下方法删除：\n```\nnpm uninstall vue\n```\n\n这个命令会删除``` node_modules ```文件夹及``` package.json ```中对应的包。当然，你也可以用``` rm ```, ``` un ```或者``` r ```来达到相同的效果:\n```\nnpm rm vue\n```\n\n如果由于某些原因，你只想从``` node_modules ```文件夹中删除安装包，但是想在``` package.json ```中保留其依赖项，那么你可以使用``` no-save ```标志，如：\n```\nnpm rm vue --no-save\n```\n\n#### **依赖枚举**\n如果你想看一下你的项目依赖了哪些安装包，你可以这样看：\n```\nnpm ls\n```\n\n这个命令会将你项目的依赖列举出来，并且各个安装包的依赖也会显示出来。如果你只想看本项目的依赖，你可以这样：\n```\nnpm ls --depth=0\n```\n\n这样打印出来的结果就是本项目的依赖，像这样：\n```\n├── jquery@3.3.1\n├── vue@2.5.17\n└── yarn@1.12.3\n```\n\n当然，你也可以加上g来看看你全局安装的依赖包，如：\n```\nnpm ls -g -depth 0\n```\n\n#### **过期依赖枚举**\n大多数时候，你需要保持本地依赖的更新，你可以在项目目录下先查看一下安装包有没有版本更新，如：\n```\nnpm outdate\n```\n这个命令将会列出所有你可能有更新的过时的安装包列表，如图：\n\n#### **执行测试**\n你可以使用``` npm run tests ```来执行测试用例，但是你可以更方便地用``` npm test ```或者``` npm t ```来执行。\n\n#### **显示可用脚本**\n我们可以通过打开``` package.json ```文件来查看有哪些可执行的脚本，但是我们还可以这样查看：\n```\nnpm run\n```\n\n如果在package.json中有如下配置：\n```\n\"scripts\": {\n  \"test\": \"jest\",\n  \"build\": \"gulp build\"\n}\n```\n\n那么执行这个命令之后，会显示以下信息：\n```\nLifecycle scripts included in npm:\n  test\n    jest\navailable via `npm run-script`:\n  build\n    gulp-build\n```\n\n#### **安装Github Repo上的包**\n你可以直接这样安装来自Github repo上的包：\n```\nnpm i https://github.com/sindresorhus/gulp-debug\n```\n\n或者你可以忽略域名安装：\n```\nnpm i sindresorhus/gulp-debug\n```\n\n#### **打开安装包的Github主页**\n你当然可以直接谷歌搜索，然后找到对应的包链接打开，但是你还可以这样：\n```\nnpm repo create-react-app\n```\n有不需要安装的包，又想看下其 github 主页的，可以这样打开。\n\n#### **列出所有NPM环境的可用变量**\n你可以使用这个命令来列出所有NPM环境的可用变量：\n```\nnpm run env | grep npm_\n```\n\n执行后，将会打印出这样的信息：\n```\nnpm_config_access=\nnpm_config_allow_same_version=\nnpm_config_also=\nnpm_config_always_auth=\nnpm_config_argv={\"remain\":[],\"cooked\":[\"run\",\"env\"],\"original\":[\"run\",\"env\"]}\nnpm_config_audit=true\nxxx\n```\n\n这样变量的用处就是，可以在脚本中使用它们，还可以创建自己的变量。\n\n#### **创建自己的NPM可用变量**\n你可以在``` package.json ```中添加新的``` key ```来创建自己的``` npm ```变量，可以是任何``` key ```，我更喜欢将所有的``` npm ```变量都放在一个``` config ```中，这样看起来比较清晰：\n```\n\"config\": {\n  \"build_folder\":\"./dist\"\n}\n```\n\n你添加了之后，重新执行``` npm run env | grep npm_ ```，就能看到以下信息：\n```\nnpm_package_config_build_folder=./dist\nnpm_config_fetch_retry_maxtimeout=60000\nnpm_config_tag_version_prefix=v\nnpm_config_strict_ssl=true\nnpm_config_sso_type=oauth\n.\n.\n.\n```\n\n默认情况下，``` npm ```会重命名你的变量，给其加上前缀``` npm_package ```，并将其结构保留在``` package.json ```文件中，即变为``` config_build_folder ```。\n\n#### **在npm脚本中使用npm变量**\n你可以看到可用变量的完整列表，如果你想使用这些变量中的任何值，就可以在package.json中使用了，如：\n```\n\"scripts\": {\n  \"build\": \"gulp build --dist $npm_package_config_build_folder\"\n}\n```\n\n当你执行``` npm run build ```的时候，实际执行的是这样：\n```\ngulp build --dist ./dist\n```\n\n以上就是一些我最爱的日常工作中用到的命令~\n\n\n","like_users":[],"create_time":{"$date":"2019-10-24T08:22:45.594Z"},"update_time":{"$date":"2019-10-24T08:22:45.595Z"},"id":12,"__v":0}
{"_id":{"$oid":"5db2acfd53af0700308855ed"},"meta":{"views":25,"likes":0,"comments":0},"keyword":["http-cache"],"desc":"http缓存相关的知识点","numbers":"8802","img_url":"http://img.golderbrother.cn/cache-fe.webp","type":1,"state":1,"origin":0,"tags":[{"$oid":"5db2a66953af0700308855ec"}],"comments":[],"category":[{"$oid":"5db2a5b553af0700308855eb"}],"title":"http缓存相关的知识点","author":"golderBrother","content":"# 浏览器缓存一探究竟~\n\n先看一张经典的流程图，结合理解\n\n\u003e 吃了它\n\n![img](http://img.golderbrother.cn/cache-fe.webp)\n\n## 1. 缓存作用\n\n- 减少了冗余的`数据传输`，节省了网费。\n- 减少了服务器的负担， 大大提高了网站的`性能`\n- 加快了客户端加载网页的`速度`\n\n## 2. 缓存分类\n\n### 2.1 DNS 缓存\n\n主要就是在浏览器本地把对应的 IP 和域名关联起来，这样在进行 DNS 解析的时候就很快。\n\n### 2.2 MemoryCache\n\n是指存在**内存**中的**缓存**。从优先级上来说，它是浏览器最先尝试去命中的一种**缓存**。从效率上来说，它是**响应速度最快**的一种缓存。\n**内存缓存**是快的，也是“短命”的。它和渲染进程“生死相依”，当进程结束后，也就是 tab 关闭以后，内存里的数据也将不复存在。\n\n### 2.3 浏览器缓存\n\n浏览器缓存，也称**Http 缓存**，分为**强缓存**和**协商缓存**。优先级较高的是**强缓存**，在命中**强缓存**失败的情况下，才会走**协商缓存**\n\n### 2.3.1 强缓存\n\n**强缓存**是利用 `http` 头中的 `Expires` 和 `Cache-Control` 两个字段来控制的。**强缓存**中，当请求再次发出时，浏览器会根据其中的 `Expires` 和 `cache-control` 判断目标资源是否“命中”**强缓存**，若命中则直接从缓存中获取资源，不会再与服务端发生通信。\n\n#### Expires\n\n实现**强缓存**，过去我们一直用`Expires`。当服务器返回响应时，在 Response Headers 中将过期时间写入 `Expires` 字段。像这样\n\n`expires: Wed, 12 Sep 2019 06:12:18 GMT`\n\n可以看到，`expires` 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 `expires` 的时间戳，如果本地时间**小于** `expires` 设定的过期时间，那么就直接去缓存中取这个资源。\n\n从这样的描述中大家也不难猜测，`expires` 是有问题的，它最大的问题在于对`本地时间`的依赖。如果服务端和客户端的时间设置可能不同，或者我直接手动去把客户端的时间改掉，那么 `expires` 将无法达到我们的预期。\n\n#### Cache-Control\n\n考虑到 `expires` 的局限性，`HTTP1.1` 新增了`Cache-Control`字段来完成 `expires` 的任务。`expires` 能做的事情，`Cache-Control` 都能做；`expires` 完成不了的事情，`Cache-Control` 也能做。因此，`Cache-Control` 可以视作是 `expires` 的完全替代方案。在当下的前端实践里，我们继续使用 `expires` 的唯一目的就是向下兼容。\n\n在 `Cache-Control` 中，我们通过`max-age`来控制资源的有效期。`max-age` 不是一个时间戳，而是一个时间长度。在本例中，`max-age` 是 `31536000` 秒，它意味着该资源在 `31536000` 秒以内都是有效的，完美地规避了时间戳带来的潜在问题。\n\n`Cache-Control` 相对于 expires 更加准确，它的优先级也更高。当 `Cache-Control` 与 expires 同时出现时，我们以 `Cache-Control` 为准。\n\n可以参考下下面两张图：\n\n![img](http://img.golderbrother.cn/cache1.png)\n\n### 2.3.2 协商缓存(对比缓存)\n\n协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。\n\n协商缓存的实现,从 `Last-Modified` 到 `Etag`,`Last-Modified` 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 `Response Headers` 返回：\n\n#### Last-Modified\n\n```html\nLast-Modified: Fri, 27 Oct 2017 06:35:57 GMT\n```\n\n随后我们每次请求时，浏览器的请求头 `headers` 会带上一个叫 `If-Modified-Since` 的时间戳字段，它的值正是上一次 `response` 返回给它的 `Last-Modified` 值：\n\n```html\nIf-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT\n```\n\n服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的**最后修改时间**是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 `Response Headers` 中添加新的 `Last-Modified` 值；否则，返回 304 响应，`Response Headers` 不会再添加 `Last-Modified` 字段。\n\n如下图：\n\n![img](http://img.golderbrother.cn/cache3.png)\n\n通过最后修改时间来判断缓存是否可用\n\n- `Last-Modified`：响应时告诉客户端此资源的最后修改时间\n- `If-Modified-Since`：当资源过期时（使用 `Cache-Control` 标识的 `max-age`），发现资源具有 `Last-Modified` 声明，则再次向服务器请求时带上头 `If-Modified-Since`。\n- 服务器收到请求后发现有头 `If-Modified-Since` 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应最新的资源内容并返回 `200` 状态码；\n- 若最后修改时间和 `If-Modified-Since` 一样，说明资源没有修改，则响应 `304` 表示未更新，告知浏览器继续使用所保存的缓存文件。\n\n看个实例代码：\n\n```js\nlet http = require('http');\nlet fs = require('fs');\nlet path = require('path');\nlet mime = require('mime');\nhttp.createServer(function (req, res) {\n    let file = path.join(__dirname, req.url);\n    fs.stat(file, (err, stat) =\u003e {\n        if (err) {\n            sendError(err, req, res, file, stat);\n        } else {\n            let ifModifiedSince = req.headers['if-modified-since'];\n            if (ifModifiedSince) {\n                if (ifModifiedSince == stat.ctime.toGMTString()) {\n                    res.writeHead(304);\n                    res.end();\n                } else {\n                    send(req, res, file, stat);\n                }\n            } else {\n                send(req, res, file, stat);\n            }\n        }\n    });\n}).listen(8080);\nfunction send(req, res, file, stat) {\n    res.setHeader('Last-Modified', stat.ctime.toGMTString());\n    res.writeHead(200, { 'Content-Type': mime.getType(file) });\n    fs.createReadStream(file).pipe(res);\n}\nfunction sendError(err, req, res, file, stat) {\n    res.writeHead(400, { \"Content-Type\": 'text/html' });\n    res.end(err ? err.toString() : \"Not Found\");\n```\n\n使用 Last-Modified 存在一些弊端，这其中最常见的就是这样几个场景\n    1. 某些服务器不能精确得到文件的**最后修改时间**， 这样就无法通过**最后修改时间**来判断文件是否更新了。\n    2. 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。\n    3. 当我们修改文件的速度过快时（比如花了 `100ms` 完成了改动），由于 `If-Modified-Since` 只能检查到以**秒**为最小计量单位的时间差，所以它是**感知不到**这个改动的——该重新请求的时候，反而没有重新请求了。\n    4. 如果同样的一个文件位于多个CDN服务器上的时候内容虽然一样，修改时间不一样。\n\n第二和第三这两个场景其实指向了同一个 bug——服务器并没有正确感知文件的变化。为了解决这样的问题，Etag 作为 `Last-Modified` 的补充出现了。\n\n#### Etag\n\n\u003e 这个是协商缓存中的另外一种\n\n`Etag` 是由服务器为每个资源生成的唯一的标识字符串(**指纹**)，这个标识字符串可以是基于文件内容**编码**的，只要文件内容不同，它们对应的 `Etag` 就是不同的，反之亦然。因此 `Etag` 能够精准地感知文件的变化。\n\n`Etag`是 Web 服务端产生的，然后发给浏览器客户端。生成过程需要服务器额外付出开销，会**影响服务端的性能**，这是它的弊端。因此启用 `Etag` 需要我们审时度势。正如我们刚刚所提到的——`Etag` 并不能替代 `Last-Modified`，它只能作为 `Last-Modified` 的补充和强化存在。\n\n执行流程是这样的： \n    1. 客户端想判断缓存是否可用可以先获取缓存中文档的`ETag`，然后通过`If-None-Match`发送请求给 Web 服务器询问此缓存是否可用。 \n    2. 服务器收到请求，将服务器的中此文件的`ETag`,跟请求头中的`If-None-Match`相比较,如果值是一样的,说明缓存还是最新的,Web 服务器将发送`304 Not Modified`响应码给客户端表示缓存未修改过，可以使用。 \n    3. 如果不一样则 Web 服务器将发送该文档的最新版本给浏览器客户端\n\n\n看如下实例代码：\n\n```js\nlet http = require(\"http\");\nlet fs = require(\"fs\");\nlet path = require(\"path\");\nlet mime = require(\"mime\");\nlet crypto = require(\"crypto\");\nhttp\n  .createServer(function(req, res) {\n    let file = path.join(__dirname, req.url);\n    fs.stat(file, (err, stat) =\u003e {\n      if (err) {\n        sendError(err, req, res, file, stat);\n      } else {\n        let ifNoneMatch = req.headers[\"if-none-match\"];\n        let etag = crypto\n          .createHash(\"sha1\")\n          .update(stat.ctime.toGMTString() + stat.size)\n          .digest(\"hex\");\n        if (ifNoneMatch) {\n          if (ifNoneMatch == etag) {\n            res.writeHead(304);\n            res.end();\n          } else {\n            send(req, res, file, etag);\n          }\n        } else {\n          send(req, res, file, etag);\n        }\n      }\n    });\n  })\n  .listen(8080);\nfunction send(req, res, file, etag) {\n  res.setHeader(\"ETag\", etag);\n  res.writeHead(200, { \"Content-Type\": mime.lookup(file) });\n  fs.createReadStream(file).pipe(res);\n}\nfunction sendError(err, req, res, file, etag) {\n  res.writeHead(400, { \"Content-Type\": \"text/html\" });\n  res.end(err ? err.toString() : \"Not Found\");\n}\n```\n\n#### 强缓存和协商缓存比较\n\n优先级：\n\n`Etag` 在感知文件变化上比 `Last-Modified` 更加准确，优先级也更高。当 `Etag` 和 `Last-Modified` 同时存在时，以 `Etag` 为准。\n\n对比：\n\n- 强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互\n- 两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则\n\n### 2.4 Service Worker Cache\n\n`Service Worker` 是一种独立于主线程之外的 `Javascript 线程`。它**脱离**于浏览器窗体，因此无法直接访问 `DOM。这样独立的个性使得` `Service Worker` 的“个人行为”**无法干扰**页面的性能，这个**幕后工作者**可以帮我们实现**离线缓存**、**消息推送**和**网络代理**等功能。我们借助 `Service worker` 实现的离线缓存就称为 `Service Worker` Cache。\n\n`Service Worker` 的生命周期包括 `install、activited、working` 三个阶段。一旦 `Service Worker` 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件.\n\n它就在浏览器开发工具(F12) `Application` 标签页中\n\n### 2.5 Push Cache\n\n`Push Cache` 是指 `HTTP2` 在 `server push` 阶段存在的缓存。这块的知识比较新，应用也还处于萌芽阶段，应用范围有限不代表不重要——`HTTP2` 是趋势、是未来。在它还未被推而广之的此时此刻，仍希望大家能对 `Push Cache` 的关键特性有所了解：\n\n- `Push Cache` 是缓存的最后一道防线。浏览器只有在 `Memory Cache`、`HTTP Cache` 和 `Service Worker Cache` 均未命中的情况下才会去询问 `Push Cache`。\n- `Push Cache` 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。\n- 不同的页面只要共享了同一个 `HTTP2` 连接，那么它们就可以共享同一个 `Push Cache`。\n\n## 3. 请求流程\n\n### 3.1 第一次请求\n\n![img](http://img.golderbrother.cn/cache5.png)\n\n### 3.2 第二次请求\n\n走上面的缓存机制\n\n## 4. 如何干脆不发请求\n\n- 浏览器会将文件缓存到`Cache`目录，第二次请求时浏览器会先检查`Cache`目录下是否含有该文件，如果有，并且还没到`Expires`设置的时间，即文件还没有过期，那么此时浏览器将直接从 Cache 目录中读取文件，而不再发送请求\n- `Expires`是服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求,这是`HTTP1.0`的内容，现在浏览器均默认使用`HTTP1.1`,所以基本可以忽略\n- `Cache-Control`与`Expires`的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据,如果同时设置的话，其优先级高于`Expires`\n\n### 5.1 使用 Cache-Control\n\n- private 客户端可以缓存\n- public 客户端和代理服务器都可以缓存\n- max-age=60 缓存内容将在 60 秒后失效\n- no-cache 需要使用**对比缓存**验证数据,强制向源服务器再次验证\n- no-store 所有内容都不会缓存，**强制缓存**和**对比缓存**都不会触发\n- Cache-Control:private, max-age=60, no-cache\n\n```js\nlet http = require(\"http\");\nlet fs = require(\"fs\");\nlet path = require(\"path\");\nlet mime = require(\"mime\");\nlet crypto = require(\"crypto\");\nhttp\n  .createServer(function(req, res) {\n    let file = path.join(__dirname, req.url);\n    console.log(file);\n\n    fs.stat(file, (err, stat) =\u003e {\n      if (err) {\n        sendError(err, req, res, file, stat);\n      } else {\n        send(req, res, file);\n      }\n    });\n  })\n  .listen(8080);\nfunction send(req, res, file) {\n  let expires = new Date(Date.now() + 60 * 1000);\n  res.setHeader(\"Expires\", expires.toUTCString());\n  res.setHeader(\"Cache-Control\", \"max-age=60\");\n  res.writeHead(200, { \"Content-Type\": mime.lookup(file) });\n  fs.createReadStream(file).pipe(res);\n}\nfunction sendError(err, req, res, file, etag) {\n  res.writeHead(400, { \"Content-Type\": \"text/html\" });\n  res.end(err ? err.toString() : \"Not Found\");\n}\n```\n\n## 参考资料\n\n[谈谈浏览器缓存](https://github.com/LuckyWinty/fe-weekly-questions/issues/8)\n","like_users":[],"create_time":{"$date":"2019-10-25T08:06:21.056Z"},"update_time":{"$date":"2019-10-25T08:06:21.056Z"},"id":13,"__v":0}
{"_id":{"$oid":"5db2cda953af0700308855f3"},"meta":{"views":17,"likes":0,"comments":0},"keyword":["移动端、H5"],"desc":"移动端开发相关技巧","numbers":"11232","img_url":"http://img.golderbrother.cn/webapp.jpg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5db2cc3653af0700308855f1"}],"comments":[],"category":[{"$oid":"5db2cc3f53af0700308855f2"}],"title":"移动端开发相关技巧","author":"golderBrother","content":"## 前言\n在平时的H5移动端开发时，我们难免会遇到各种各样的坑点，这篇文章就带着大家来看看怎么解决，文章较长，建议收藏方便以后查阅！\n\n## 前方高能！\n### canvas在retina屏模糊\n只需要将画笔根据像素比缩放即可\n\n```\nrun(canvasEl) {\n    const canvas = canvasEl;\n    const ctx = canvas.getContext('2d');\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const backingStorePixelRatio = ctx.webkitBackingStorePixelRatio ||\n    ctx.mozBackingStorePixelRatio ||\n    ctx.msBackingStorePixelRatio ||\n    ctx.oBackingStorePixelRatio ||\n    ctx.backingStorePixelRatio || 1;\n\n    const ratio = devicePixelRatio / backingStorePixelRatio;\n    if (devicePixelRatio !== backingStorePixelRatio) {\n      const oldWidth = canvas.width;\n      const oldHeight = canvas.height;\n\n      canvas.width = oldWidth * ratio;\n      canvas.height = oldHeight * ratio;\n\n      canvas.style.width = `${oldWidth}px`;\n      canvas.style.height = `${oldHeight}px`;\n      ctx.scale(ratio, ratio);\n    }\n  },\n```\n\n### 用同等比例的图片在PC机上很清楚,但是手机上很模糊,原因是什么呢?\n经研究发现是``` devicePixelRatio ```(设备像素比)作怪,因为手机分辨率太小,如果按照分辨率来显示网页字会非常小,所以苹果就把iPhone 4的960*640分辨率在网页里只显示了480*320,这样devicePixelRatio＝2;现在android比较乱,有1.5/2/3等,想让图片在手机里显示更为清晰必须使用2x的背景图来代替img标签(一般情况都是用2倍),例如一个div的宽高是100*100,背景图必须得200*200,然后``` background-size:contain ```;这样显示出来的图片就比较清晰了;代码如下:\n\n```\n   background:url(../images/icon/all.png) no-repeat center center;\n   -webkit-background-size:50px 50px;\n   background-size: 50px 50px;\n   display:inline-block; \n   width:100%; \n   height:50px;\n```\n\n### 启动或禁用自动识别页面中的电话号码;\n```\n\u003cmeta name=\"format-detection\" content=\"telephone=no\"\u003e \n```\n默认情况下设备会自动识别任何可能是电话号码的字符串,设置telephone=no可以禁用这项功能,设置不识别邮箱和地址也同理\n\n### h5网站input设置为type=number的问题\nh5网页input的type设置为number一般会产生三个问题:\n\n问题1:maxlength属性不好用\n```\n\u003cinput type=\"number\" oninput=\"checkTextLength(this ,10)\"\u003e\n\u003cscript type=\"text/javascript\"\u003e\n    function checkTextLength(obj, length) {\n        if(obj.value.length \u003e length)  {\n            obj.value = obj.value.substr(0, length);\n        }\n    }\n\u003c/script\u003e\n```\n\n问题2:form提交的时候默认取整\n```\n\u003cinput type=\"number\" step=\"0.01\" /\u003e //input中type=number一般会自动生成一个上下箭头,点击上箭头默认增加一个step,点击下箭头默认会减少一个step;number中默认step是1,也就是step=0.01可以允许输入2位小数,并且点击上下箭头分别增加0.01和减少0.01;step和min一起使用时数值必须在min和max之间\n```\n\n问题3:部分安卓手机出现样式问题\n\n去除input默认样式的方法:\n```\ninput,textarea {\n    border: 0;\n    -webkit-appearance: none; //可同时屏蔽输入框怪异的内阴影,解决iOS下无法修改按钮样式,测试还发现,加了此属性后,iOS下默认还是有圆角的,不过可以用border-radius属性修改\n}\n```\n\n### select下拉选择设置问题\n问题1:右对齐实现\n\n设置如下属性\n```\nselect option {\n    direction: rtl;\n}\n```\n\n问题2:禁用select默认箭头\n```\n::-ms-expand修改表单控件下拉箭头,设置隐藏并使用背景图片来修饰\n\nselect::-ms-expand { display:none; }\n```\n\n### 移动端HTML5 audio autoplay失效问题\n由于自动播放网页中的音频或视频会给用户带来困扰或不必要的流量消耗,所以苹果系统和安卓系统通常都会禁止自动播放和使用JS的触发播放,必须由用户来触发才播放;解决方法思路:先通过用户touchstart触碰触发播放并暂停(让音频开始加载),后面用JS再操作就没问题了;\n解决代码:\n```\ndocument.addEventListener('touchstart', function () {\n    document.getElementsByTagName('audio')[0].play();\n    document.getElementsByTagName('audio')[0].pause();\n});\n```\n\nCSS动画页面闪白,动画卡顿,图片错乱的问题\n1.尽可能地使用合成属性transform和opacity来设计CSS3动画,不使用position的left和top来定位\n\n2.开启硬件加速\n```\n-webkit-transform: translate3d(0, 0, 0);\n-moz-transform: translate3d(0, 0, 0);\n-ms-transform: translate3d(0, 0, 0);\ntransform: translate3d(0, 0, 0);\n```\n\n浮动子元素撑开父元素盒子高度(BFC)\n\u003e BFC -\u003e 使其变为块级格式化上下文(Block Format Context)\n解决方法如下：\n1.父元素设置为 overflow: hidden;\n2.父元素设置为 display: inline-block;等\n这里两种方法都是通过设置css属性将浮动元素的父元素变成BFC(块级格式化上下文)元素,使子元素高度可以撑开父元素;不过最好使用方法1,因为inline-block元素本身会自带一些宽高度撑开其本身\n\n### 往返缓存问题\n点击浏览器的回退有时候不会自动执行js,特别是在mobilesafari中;这与往返缓存(bfcache)有关系,\n解决方法:\n```\nwindow.onunload = function(){};\n```\n\n### 定位的坑\n在IOS下``` fixed ```定位在软键盘顶起时会失效，所以我们在开发时统一使用``` absolute ```代替\n\n### audio元素和video元素在ios和andriod中播放问题\n```\n\u003caudio src=\"music/bg.mp3\" autoplay loop controls\u003e你的浏览器还不支持哦\u003c/audio\u003e //音频,写法一\n\u003caudio controls=\"controls\"\u003e //音频,写法二   \n    \u003csource src=\"music/bg.ogg\" type=\"audio/ogg\"\u003e\u003c/source\u003e\n    \u003csource src=\"music/bg.mp3\" type=\"audio/mpeg\"\u003e\u003c/source\u003e //优先播放音乐bg.ogg,不支持在播放bg.mp3    \n\u003c/audio\u003e\n```\n\n到这里一般都可以播放音乐了,如果还不行很有可能是微信的限制\n\n问题3:微信的限制\n\n如果是微信的限制,这时需要调用微信接口,页面先引入:\n```\n\u003cscript src=\"http://res.wx.qq.com/open/js/jweixin-1.0.0.js\"\u003e\u003c/script\u003e\n```\n\n然后JS写入微信事件:\n```\ndocument.addEventListener(\"WeixinJSBridgeReady\", function() {\n    document.getElementById('music').play();\n}, false);\n```\n\n小结:\n1.audio元素的autoplay属性在IOS及Android上无法使用,在PC端正常\n2.audio元素没有设置controls时,在IOS及Android会占据空间大小,而在PC端Chrome是不会占据任何空间\n问题4:Safari浏览器自动播放\n\n```\ndocument.addEventListener('touchstart', function(){   \n    audio.play();\n}, false);\n```\n\n### ios系统不支持动画暂停样式(animation-play-state)\nH5页面一般都会有BGM,也会提供一个旋转的音乐图标供用户开启关闭音乐;我们希望当用户点击音乐按钮时图标停止旋转,再点图标顺着之前停止的位置继续跑动画;``` animation-play-state ```是最简便的方式,然而ios不支持\n目前的解决方案是:音乐图标负责跑动画,图标父级元素负责记录停止时的转动值\n\n### ios防止长按页面元素被选中\n\nios防止长按页面元素被选中\n解决:加入样式可禁止用户进行复制,ios和一般的安卓都可以解决\n```\n-webkit-touch-callout:none;  //系统默认菜单被禁用;可以实现页面因为长按弹出各种操作窗口\n-webkit-user-select:none; //webkit浏览器  \n-khtml-user-select:none; //早期浏览器 \n-moz-user-select:none; //火狐 \n-ms-user-select:none; //IE10 \nuser-select:none; \n```\n添加完这段代码后在IOS上会有问题,这时发现input框无法正在输入内容了;造成这个原因是-webkit-user-select:none;这个属性,解决方法就是在css文件中同时设置一下input的属性,如下:\n```\ninput {      \n     -webkit-user-select:auto; //webkit浏览器    \n}\n```\n\n### html5碰到上下拉动滚动条时卡顿/慢怎么解决\n\n首先你可能会给页面的html和body增加了height: 100%, 然后就可能造成IOS上页面滑动的卡顿问题。\n解决方案是：\n1.让``` html ```和``` body ```固定100%（或者100vh），\n2.然后再在内部放一个``` height:100% ```的div，设置``` overflow-y: auto; ```和``` -webkit-overflow-scrolling: touch; ```\n``` overflow-x:auto ```在iOS有兼容问题\n解决方法:\n```\n.scroll-box {\n  /* 模态框之类的div不能放在这个容器中,否则关闭模态框有时候关闭不了 */\n  height: 100%;\n  overflow-y: auto;\n  -webkit-overflow-scrolling: touch;\n  overflow-scrolling: touch;\n}\n```\n\n点击元素产生背景或边框怎么去掉\n```\na,button,input,textarea{\n-webkit-tap-highlight-color: rgba(0,0,0,0);\n-webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用,就是输入法不再能够输入多个字符\n}\n// 或\na,button,input,textarea{\n-webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n```\n\n### 浏览器后退不刷新\n这种情况是以前遇到的,这里也说下;主要会发生在webview里多一点,当点击后退时页面以缓存形式出现,而不是刷新后的,很多情况下这不是你预期的效果\n解决方法是用js:\n\n```\n方法1：\nwindow.addEventListener('pageshow', () =\u003e {\n  if (e.persisted || (window.performance \u0026\u0026 \n    window.performance.navigation.type == 2)) {\n    location.reload()\n  }\n}, false);\n\n方法2:\nwindow.history.replaceState(null, '', window.location.href + '?timestamp=' + new Date().getTime());\n```\n\nonpageshow每次页面加载都会触发,无论是从缓存中加载还是正常加载,这是他和onload的区别;persisted判断页面是否从缓存中读出\n\n页面通过历史记录和前进后退访问时。type值为2\n\n### transition清除闪屏\n```\n-webkit-transform-style: preserve-3d; //设置内嵌的元素在 3D 空间如何呈现：保留3D\n-webkit-backface-visibility:hidden; //设置进行转换的元素的背面在面对用户时是否可见：隐藏\n-webkit-perspective: 1000;\n```\n\n### 解决active伪类失效\n```\n\u003cbody ontouchstart\u003e\u003c/body\u003e\n```\n\n### 顶部状态栏背景色\n```\n// apple-mobile-web-app-capable是设置Web应用是否以全屏模式运行;语法:\n\u003cmeta name=\"apple-mobile-web-app-capable\" content=\"yes\"\u003e //content设置为yesWeb应用会以全屏模式\n\u003cmeta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /\u003e\n```\n\n- 说明:除非你先使用``` apple-mobile-web-app-capable ```指定全屏模式,否则这个``` meta ```标签不会起任何作用;如果``` content ```设置为``` default ```,则状态栏正常显示;\n- 如果设置为``` blank ```,则状态栏会有一个黑色的背景;\n- 如果设置为``` blank-translucent ```,则状态栏显示为黑色半透明;如果设置为``` default ```或``` blank ```,则页面显示在状态栏的下方,即状态栏占据上方部分;页面占据下方部分，二者没有遮挡对方或被遮挡;\n- 如果设置为``` blank-translucent ```,则页面会充满屏幕,其中页面顶部会被状态栏遮盖住(会覆盖页面20px高度，而``` iphone4 ```和``` itouch4 ```的``` Retina ```屏幕为40px);默认值是``` default ```。\n\n## iOS专区\n### iOS中对``` input ```键盘事件``` keyup/keydown/keypress ```等支持不好的问题\n经查发现,IOS的输入法(不管是第三方还是自带)能检测到英文或数字的keyup,但检测不到中文的keyup,在输入中文后需要点回退键才开始搜索;解决办法是用html5的oninput事件去代替keyup,通过如下代码达到类似keyup的效果;\n\n1.修改了``` input:checkbox或input:radio ```元素的选择中状态,``` checked ```属性发生变化\n2.修改了``` input:text ```或``` textarea ```元素的值,value属性发生变化\n3.修改了select元素的选中项,selectedIndex属性发生变化\n统一使用input监听\n\n```\n\u003cinput type=\"text\" id=\"testInput\"\u003e\n\u003cscript type=\"text/javascript\"\u003e\n    document.getElementById('testInput').addEventListener('input', function(e){\n        var value = e.target.value; //e.target指向事件执行时鼠标所点击区域的那个元素;初学者会认为当前事件所绑定的元素就是鼠标所点击的那个元素,这时就要看看时间绑定的元素内部有没有子元素,如果有e.target指向这个子元素,如果没有e.target和this都指向事件所绑定的元素\n    });\n\u003c/script\u003e\n```\n\n### IOS键盘字母输入,默认首字母大写的解决方案\n设置如下属性\n```\n// input的三个属性autocomplete:默认为on,代表是否让浏览器自动记录输入的值,可以在input中加入autocomplete=\"off\"来关闭记录,保密输入内容;autocorrect:自动大小写\n\u003cinput autocomplete=\"off\" autocorrect=\"off\" /\u003e\n```\n\n### 关于iOS与OS X端字体的优化(横竖屏会出现字体加粗不一致等)问题\niOS浏览器横屏时会重置字体大小,设置text-size-adjust为none可以解决iOS上的问题,但桌面版Safari的字体缩放功能会失效,因此最佳方案是将text-size-adjust为100%\n```\n-webkit-text-size-adjust: 100%;\n-ms-text-size-adjust: 100%;\ntext-size-adjust: 100%;\n```\n\n### 某些情况下非可点击元素如(label,span)监听click事件,ios下不会触发\n针对此种情况只需对不触发click事件的元素添加一行css代码即可\n```\ncursor: pointer;\n```\n\n### ios对时间date()的支持不一样\n```\nvar date =new Date(\"2019/10/21\"); \n```\n调试发现2019/10/21等同2019-10-21 00:00:00,也就是说ios默认就是从0开始计算的,我们不需要设置后面的时分秒为00:00:00\n\n### iOS 时间转换显示NaN问题\n比如在开发中接口返回的时间是字符串\"yyyy-mm-dd hh:mm:ss\"格式，但界面显示只需要年月日\n但是发现在IOS上显示NaN,安卓上没有问题。\n解决办法：把时间转换成\"yyyy/mm/dd hh:mm:ss\"格式就可以了。\n```\n//2019-08-08 14:06:31 -\u003e 2019/08/08 14:06:31\ndate = date.replace(/-/g, '/')\n```\n\n### iOS(safari)标签绑定点击事件无效\niOS(safari)有时候某个标签绑定点击事件无效,加上空的onclick=\"\"就好了,如: ```\u003ca onclick=\"\"\u003e\u003c/a\u003e```\n\n### ios中location.href跳转页面空白\n在location.href外套一层setTimeout就解决了！\n\n```\nsetTimeout(() =\u003e {\n       window.location.href = 'www.juejin.im'\n}, 0);\n```\n\n### 键盘弹起下落时的bug解决方法\n在App.vue的created钩子里统一处理即可\n\n简易版(React)：\n```\n// js\nhandleWindowResize(){\n    let screenHeight = document.documentElement.clientHeight,\n    isOriginHei = true; // 是否为原始的高度\n    let newScreenHeight = screenHeight;\n    // 解决手机抬起软键盘，按钮会被顶到上面的问题\n    // 当键盘弹起时隐藏掉按钮，键盘隐藏时按钮显示\n    window.onresize = () =\u003e {\n      newScreenHeight = document.documentElement.clientHeight;\n      // 加100为了兼容华为的返回键\n      // isOriginHei = Boolean(newScreenHeight + 100 \u003e= screenHeight);\n      isOriginHei = Boolean(newScreenHeight \u003e= screenHeight);\n      this.setState({\n        isOriginHei\n      });\n    };\n  } \n\n  componentDidMount() {\n    this.handleWindowResize();\n  }\n// jsx\n{\n            isOriginHei \u0026\u0026 (\u003cItem className=\"register-btn-wrapper bottom-btn-wrapper\"\u003e\n              \u003cButton\n                type=\"primary\"\n                size=\"big\"\n                inline\n                onClick={() =\u003e this.handleSubmit()}\n              \u003e\n                提交\n              \u003c/Button\u003e\n            \u003c/Item\u003e)\n          }\n```\n\n升级版(Vue)：\n```\ncreated() {\n    this.handleFocusOut();\n    this.handleResize();\n},\nmethods:{\n    handleFocusOut() {\n      // input 焦点失焦后，ios 键盘收起，但没有触发 window resize，导致实际页面dom仍然被键盘顶上去--错位\n      document.addEventListener('focusout', () =\u003e {\n        document.body.scrollTop = 0;\n      });\n    },\n    // 监听resize事件（键盘弹起触发），然后将 input textarea 元素滑动到可视区域，并将特定元素隐藏\n    handleResize() {\n      const clientHeight = document.documentElement.clientHeight;\n      window.addEventListener('resize', () =\u003e {\n        // 判断当前 active 的元素是否为 input 或 textarea\n        if (\n          document.activeElement.tagName === 'INPUT' ||\n          document.activeElement.tagName === 'TEXTAREA'\n        ) {\n          setTimeout(() =\u003e {\n            // 原生方法，滚动至需要显示的位置\n            document.activeElement.scrollIntoView();\n          }, 0);\n        }\n\n        // 解决键盘弹起后 fixed 定位元素被顶起问题\n        const bodyHeight = document.documentElement.clientHeight;\n        const ele = document.getElementById('fixed-bottom');\n        if (ele) {\n          if (clientHeight \u003e bodyHeight) {\n            ele.style.display = 'none';\n          } else {\n            ele.style.display = 'block';\n          }\n        }\n      });\n    }\n}\n```\n\n### 总结\n路漫漫其修远兮,在兼容的道路上渐行渐远\n\n\n","like_users":[],"create_time":{"$date":"2019-10-25T10:25:45.247Z"},"update_time":{"$date":"2019-10-25T10:25:45.247Z"},"id":15,"__v":0}
{"_id":{"$oid":"5db6fbac0459c20030b9ed68"},"meta":{"views":29,"likes":0,"comments":0},"keyword":["react "],"desc":"新手学习 react 迷惑的点(完整版)","numbers":"12053","img_url":"http://img.golderbrother.cn/react-logo.svg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5cd447d79865305588453109"}],"comments":[],"category":[{"$oid":"5cd44852986530558845310a"}],"title":"新手学习 react 迷惑的点(完整版)","author":"golderBrother","content":"网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，所以我打算写篇文章来讲新手学习 React 的时候容易迷惑的点写出来。\n\n## 为什么要引入 React\n在写 React 的时候，你可能会写类似这样的代码：\n```js\nimport React from 'react'\n\nfunction A() {\n  // ...other code\n  return \u003ch1\u003e前端超神路\u003c/h1\u003e\n}\n```\n\n你肯定疑惑过，下面的代码都没有用到 React，为什么要引入 React 呢？\n\n如果你把``` import React from ‘react’ ```删掉，还会报下面这样的错误：\n![image](https://mmbiz.qpic.cn/mmbiz_jpg/CBxTibNZG9mGnMo4iaRFY2ibic8sAznlJhufasLKTYT7Uo1A8p6w95BdZAwUst3UAQamALxNiclq1ibuoAmGbIDe0lMw/640?wx_fmt=jpeg\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n那么究竟是哪里用到了这个 React，导致我们引入 React 会报错呢，不懂这个原因，那么就是 JSX 没有搞得太明白。\n\n你可以讲上面的代码(忽略导入语句)放到在线 babel 里进行转化一下，发现 babel 会把上面的代码转化成:\n\n```\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj \u0026\u0026 obj.__esModule ? obj : { default: obj }; }\n\nfunction A() {\n  // ...other code\n  return _react.default.createElement(\"h1\", null, \"\\u524D\\u7AEF\\u8D85\\u795E\\u8DEF\"); // -\u003e React.createElement(component, props, ...children)\n}\n```\n因为最上面的 ``` require(\"react\") ``` 需要引用react\n因为从本质上讲，JSX 只是为``` React.createElement(component, props, ...children) ```函数提供的语法糖。\n\n## 为什么要用 className 而不用 class\n\n1.React 一开始的理念是想与浏览器的 DOM API 保持一致而不是 HTML，因为 JSX 是 JS 的扩展，而不是用来代替 HTML 的，这样会和元素的创建更为接近。在元素上设置``` class ```需要使用``` className ```这个 API：\n```\nconst element = document.createElement(\"div\")\nelement.className = \"hello\" \n```\n\n2.浏览器问题，ES5 之前，在对象中不能使用保留字。以下代码在 IE8 中将会抛出错误：\n```\nconst element = {\n attributes: {\n   class: \"hello\"\n }\n}\n```\n\n3.解构问题，当你在解构属性的时候，如果分配一个 class 变量会出问题：\n```\nconst { class } = { class: 'foo' } // Uncaught SyntaxError: Unexpected token }\nconst { className } = { className: 'foo' } \nconst { class: className } = { class: 'foo' } \n```\n\n## 为什么属性要用小驼峰\n因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用``` camelCase ```（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。\n\n## 为什么 constructor 里要调用 super 和传递 props\n这是官网的一段代码，具体见：状态(State) 和 生命周期\n```\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      \u003cdiv\u003e\n        \u003ch1\u003eHello, world!\u003c/h1\u003e\n        \u003ch2\u003eIt is {this.state.date.toLocaleTimeString()}.\u003c/h2\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n而且有这么一段话，不仅让我们调用 super 还要把 props 传递进去，但是没有告诉我们为什么要这么做\n\n1.定义class组件，为什么需要加上 super() ？\nsuper的作用：super关键字，它指代父类的实例（即指代父类的this对象），子类没有自己的this对象，而是继承父类的this对象。子类必须在constructor方法中调用super方法，从而得到父类的this对象，否则会报错。\n\n 2.super()加不加props的区别究竟在哪里呢？\n需要在构造函数内使用this.props则在super()中添加props参数。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/CBxTibNZG9mGnMo4iaRFY2ibic8sAznlJhufrGiauyRzXRPicwzicTF7S5pzJGvKMAsEIEV6lAgPvEZSupXe0hWQ7t1sw/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/CBxTibNZG9mGnMo4iaRFY2ibic8sAznlJhufrGiauyRzXRPicwzicTF7S5pzJGvKMAsEIEV6lAgPvEZSupXe0hWQ7t1sw/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n不知道你有没有疑惑过为什么要调用 super 和传递 props，接下来我们来解开谜题吧。\n\n```为什么要调用 super```\n\n其实这不是 React 的限制，这是 JavaScript 的限制，在构造函数里如果要调用 this，那么提前就要调用 super，在 React 里，我们常常会在构造函数里初始化 state，``` this.state = xxx ```，所以需要调用 super。\n\n```为什么要传递 props```\n\n你可能以为必须给 super 传入``` props ```，否则``` React.Component ```就没法初始化``` this.props ```：\n\n```\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n```\n\n不过，如果你不小心漏传了``` props ```，直接调用了``` super() ```，你仍然可以在``` render ```和其他方法中访问``` this.props ```（不信的话可以试试嘛）。\n\n为啥这样也行？因为``` React 会在构造函数被调用之后，会把 props 赋值给刚刚创建的实例对象 ```：\n```\nconst instance = new YourComponent(props);\ninstance.props = props;\n```\n\n``` props ```不传也能用，是有原因的。\n\n但这意味着你在使用``` React ```时，可以用``` super() ```代替 ```super(props) 了么```？\n\n那还是不行的，不然官网也不会建议你调用 props 了，虽然 React 会在构造函数运行之后，为``` this.props``` 赋值，但在``` super() ```调用之后与构造函数结束之前， ``` this.props ``` 仍然是没法用的。\n\n```\n// Inside React\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n\n// Inside your code\nclass Button extends React.Component {\n  constructor(props) {\n    super(); // 😬 忘了传入 props\n    console.log(props); // ✅ {}\n    console.log(this.props); // 😬 undefined\n  }\n  // ...\n}\n```\n\n要是构造函数中调用了某个访问 props 的方法，那这个 bug 就更难定位了。```因此我强烈建议始终使用super(props)，即使这不是必须的: ```\n```\nclass Button extends React.Component {\n  constructor(props) {\n    super(props); // ✅ We passed props\n    console.log(props); // ✅ {}\n    console.log(this.props); // ✅ {}\n  }\n  // ...\n}\n```\n\n上面的代码确保``` this.props ```始终是有值的。\n\n如果你想避免以上的问题，你可以通过``` class 属性提案 ```来简化代码：\n```\nclass Clock extends React.Component {\n  state = {date: new Date()};\n\n  render() {\n    return (\n      \u003cdiv\u003e\n        \u003ch1\u003eHello, world!\u003c/h1\u003e\n        \u003ch2\u003eIt is {this.state.date.toLocaleTimeString()}.\u003c/h2\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n## 为什么组件用大写开头\n前面以及说过了，JSX 是``` React.createElement(component, props, …children)  ```提供的语法糖，component 的类型是：``` string/ReactClass type ```，我们具体看一下在什么情况下会用到 string 类型，什么情况下用到``` ReactClass type ```类型\n\n- string 类型react会觉得他是一个原生dom节点\n\n- ReactClass type 类型 自定义组件\n\n例如（string）：在 jsx 中我们写一个\n```\n\u003cdiv\u003e\u003c/div\u003e\n```\n\n转换为js的时候就变成了\n```\nReact.createElement(\"div\", null)\n```\n\n例如（ReactClass type）：在jsx中我们写一个\n```\nfunction MyDiv() {\n    return (\u003cdiv\u003e\u003cdiv\u003e)\n}\n\u003cMyDiv\u003e\u003c/MyDiv\u003e\n```\n\n转换为js的时候就变成了\n```\nfunction MyDiv() {\n  return React.createElement(\"div\", null);\n}\n\nReact.createElement(MyDiv, null);\n```\n\n但是上边的例子中如果将MyDiv中的首字母小写，如下\n```\nfunction myDiv() {\n    return (\u003cdiv\u003e\u003cdiv\u003e)\n}\n\u003cmyDiv\u003e\u003c/myDiv\u003e\n```\n\n转换为 js 的时候就变成了\n```\nfunction MyDiv() {\n  return React.createElement(\"div\", null);\n}\n\nReact.createElement(\"myDiv\", null);\n```\n\n由于找不到 myDiv 这个 dom，所以就会报错。\n\n## 为什么调用方法要 bind this\n\n```前提知识```：深刻的理解 JavaScript 中的 this\n\n相信刚写 React 的时候，很多朋友可能会写类似这样的代码：\n```\nclass Foo extends React.Component {\n  handleClick () {\n    this.setState({ xxx: aaa })\n  }\n\n  render() {\n    return (\n      \u003cbutton onClick={this.handleClick}\u003e\n        Click me\n      \u003c/button\u003e\n    )\n  }\n}\n```\n\n发现会报``` this ```是``` undefined ```的错，然后可能对事件处理比较疑惑，然后去看官网的事件处理有下面一段话：\n\u003e 你必须谨慎对待``` JSX ```回调函数中的``` this ```，在 JavaScript 中，``` class ```的方法默认不会绑定``` this ```。如果你忘记绑定``` this.handleClick ```并把它传入了 onClick，当你调用这个函数的时候``` this ```的值为``` undefined ```。这并不是``` React ```特有的行为；这其实与``` JavaScript ```函数工作原理有关。通常情况下，如果你没有在方法后面添加``` () ```，例如``` onClick={this.handleClick} ```，你应该为这个方法绑定``` this ```。\n\n然后你看了官网的例子和建议之后，知道需要为事件处理函数绑定 this就能解决，想下面这样：\n```\nclass Foo extends React.Component {\n  handleClick () {\n    this.setState({ xxx: aaa })\n  }\n\n  render() {\n    return (\n      \u003cbutton onClick={this.handleClick.bind(this)}\u003e\n        Click me\n      \u003c/button\u003e\n    )\n  }\n}\n```\n但是可能你没有去思考过为什么需要 bind this？如果你不能理解的话，还是 js 的基础没有打好。\n\n```React 是如何处理事件的？```\n\n咱们先来了解一下 React 是如何处理事件的。\n\nReact 的事件是合成事件， 内部原理非常复杂，我这里只把关键性，可以用来解答这个问题的原理部分进行介绍即可(后面应该会写一篇 react 的事件原理，敬请期待)。\n\n文章上面已经说过，jsx 实际上是``` React.createElement(component, props, …children) ```函数提供的语法糖，那么这段 jsx 代码：\n```\n \u003cbutton onClick={this.handleClick}\u003e\n     Click me\n \u003c/button\u003e\n```\n\n会被转化为：\n```\nReact.createElement(\"button\", {\n     onClick: this.handleClick\n}, \"Click me\")\n```\n\n了解了上面的，然后简单的理解 react 如何处理事件的，React 在组件加载(``` mount ```)和更新(``` update ```)时，将事件通过``` addEventListener ```统一注册到 ``` document ```上，然后会有一个事件池存储了所有的事件，当事件触发的时候，通过``` dispatchEvent ```进行事件分发。\n\n所以你可以简单的理解为，最终``` this.handleClick ```会作为一个回调函数调用。\n\n理解了这个，然后再来看看回调函数为什么就会丢失``` this ```。\n```this 简单回顾```\n\u003e 在函数内部，``` this ```的值取决于函数被调用的方式。\n\n如果你不能理解上面那句话，那么你可能需要停下来阅读文章，去查一下相关资料，否则你可能看不懂下面的，如果你懒的话，就看为你准备好的 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)吧。\n通过上面对事件处理的介绍，来模拟一下在类组件的``` render ```函数中， 有点类似于做了这样的操作:\n\n```\nclass Foo {\n    sayThis () {\n         console.log(this); // 这里的 `this` 指向谁？-\u003e undefined\n     }\n\n     exec (cb) {\n         cb();\n     }\n\n    render () {\n         this.exec(this.sayThis);\n  }\n}\n\nvar foo = new Foo();\nfoo.render(); // 输出结果是什么？\n```\n你会发现最终结果输出的是``` undefined ```，如果你不理解为什么输出的是``` undefined ```，那么还是上面说的，需要去深刻的理解``` this ```的原理。如果你能理解输出的是``` undefined ```，那么我觉得你就可以理解为什么需要``` bind this ```了。\n\n那么你可能会问：为什么React没有自动的把 bind 集成到 render 方法中呢?在 exec 调用回调的时候绑定进去，像这样：\n```\nclass Foo {\n    sayThis () {\n         console.log(this); // 这里的 `this` 指向谁？\n     }\n\n     exec (cb) {\n         cb().bind(this);\n     }\n\n    render () {\n         this.exec(this.sayThis);\n  }\n}\n\nvar foo = new Foo();\nfoo.render(); // 输出结果是什么？\n```\n\n``` 因为 render 多次调用每次都要 bind 会影响性能，所以官方建议你自己在 constructor 中手动 bind 达到性能优化。```\n\n### 四种事件处理对比 \n#### 1. 直接 bind this 型\n就是像文章开始的那样，直接在事件那里 bind this\n```\nclass Foo extends React.Component {\n  handleClick () {\n    this.setState({ xxx: aaa })\n  }\n\n  render() {\n    return (\n      \u003cbutton onClick={this.handleClick.bind(this)}\u003e\n        Click me\n      \u003c/button\u003e\n    )\n  }\n}\n```\n\n```优点```：写起来顺手，一口气就能把这个逻辑写完，不用移动光标到其他地方。\n\n```缺点```：性能不太好，这种方式跟 react 内部帮你 bind 一样的，每次 render 都会进行 bind，而且如果有两个元素的事件处理函数式同一个，也还是要进行 bind，这样会多写点代码，而且进行两次 bind，性能不是太好。(其实这点性能往往不会是性能瓶颈的地方，如果你觉得顺手，这样写完全没问题)\n\n#### 2. constuctor 手动 bind 型\n```\nclass Foo extends React.Component {\n  constuctor(props) {\n    super(props)\n    this.handleClick = this.handleClick.bind(this)\n  }\n  handleClick () {\n    this.setState({ xxx: aaa })\n  }\n\n  render() {\n    return (\n      \u003cbutton onClick={this.handleClick}\u003e\n        Click me\n      \u003c/button\u003e\n    )\n  }\n}\n```\n\n```优点```：相比于第一种性能更好，因为构造函数只执行一次，那么只会 bind 一次，而且如果有多个元素都需要调用这个函数，也不需要重复 bind，基本上解决了第一种的两个缺点。\n\n```缺点```：没有明显缺点，硬要说的话就是太丑了，然后不顺手(我觉得丑，你觉得不丑就这么写就行了)。\n\n#### 3. 箭头函数型\n```\nclass Foo extends React.Component {\n  handleClick () {\n    this.setState({ xxx: aaa })\n  }\n\n  render() {\n    return (\n      \u003cbutton onClick={(e) =\u003e this.handleClick(e)}\u003e\n        Click me\n      \u003c/button\u003e\n    )\n  }\n}\n```\n\n```优点```：顺手，好看。\n\n```缺点```：每次 render 都会重复创建函数，性能会差一点。\n\n#### 4. public class fields 型\n\n这种``` class fields ```还处于实验阶段，据我所知目前还没有被纳入标准，具体可见这里。\n```\nclass Foo extends React.Component {\n  handleClick = () =\u003e {\n    this.setState({ xxx: aaa })\n  }\n\n  render() {\n    return (\n      \u003cbutton onClick={this.handleClick}\u003e\n        Click me\n      \u003c/button\u003e\n    )\n  }\n}\n```\n```优点```：好看，性能好。\n\n```缺点```：没有明显缺点，如果硬要说可能就是要多装一个 babel 插件来支持这种语法。\n\n```总结```\n我平时用的就这四种写法，我这边从代码的美观性、性能以及是否顺手方便对各种写法做了简单的对比。其实每种方法在项目里用都是没什么问题的，性能方面基本上可以忽略，对于美观性和顺手比较主观，所以总体来说就是看大家的偏好咯，如果硬要推荐的话，我还是比较推荐第四种写法，美观而且不影响性能。\n\n## 为什么要 setState，而不是直接 this.state.xx = oo\n\n这个问题是我们公司后端写``` React ```的时候提出的问题，为啥不能直接修改``` state ```，要``` setState ```一下。我在想，从``` vue ```转到``` React ```可能也会有这种疑问，因为``` vue ```修改状态都是直接改的。\n\n如果我们了解``` setState ```的原理的话，可能就能解答这个问题了，setState 做的事情不仅仅只是修改了 this.state 的值，另外最重要的是它会触发 React 的更新机制，会进行 diff ，然后将``` patch ```部分更新到真实``` dom ```里。\n\n如果你直接``` this.state.xx == oo ```的话，state 的值确实会改，但是改了不会触发 UI 的更新，那就不是数据驱动了。\n\n那为什么``` Vue ```直接修改``` data ```可以触发``` UI ```的更新呢？因为``` Vue ```在创建``` UI ```的时候会把这些``` data ```给收集起来(get的时候收集依赖)，并且在这些``` data ```的访问器属性 setter 进行了重写，在这个重写的方法里会去触发``` UI ```的更新(``` nitofy ```触发``` setter ```函数里面的``` update ```方法)。如果你想更多的了解``` vue ```的原理，可以去购买染陌大佬的剖析``` Vue.js ```内部运行机制。\n\n\u003e 不明白访问器属性的可以看这篇文章：深入理解JS里的对象\n\n## setState 是同步还是异步相关问题\n### 1. setState 是同步还是异步？\n\n我的回答是执行过程代码同步的，``` 只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步” ```，所以``` 表现出来 ```有时是同步，有时是“异步”。\n\n### 2. 何时是同步，何时是异步呢？\n\n只在合成事件和钩子函数中是“异步”的，在原生事件和``` setTimeout/setInterval ```等原生 API 中都是同步的。简单的可以理解为被``` React ```控制的函数里面就会表现出“异步”，反之表现为同步。\n\n### 3. 那为什么会出现异步的情况呢？\n\n为了做性能优化，将``` state ```的更新延缓到最后， 然后批量合并``` update ```再去渲染，这对于应用的性能优化是有极大好处的，如果每次的状态改变都去重新渲染真实``` dom ```，那么它将带来巨大的性能消耗。\n\n### 4. 那如何在表现出异步的函数里可以准确拿到更新后的 state 呢？\n\n通过第二个参数``` setState(partialState, callback) ```中的``` callback ```拿到更新后的结果。\n\n或者可以通过给``` setState ```传递函数来表现出同步的情况：\n```\nthis.setState((state) =\u003e {\n    return { val: newVal }\n})\n```\n\n### 5. 那表现出异步的原理是怎么样的呢？\n直接讲源码肯定篇幅不够，可以看这篇文章：你真的理解setState吗？。\n\n我这里还是用最简单的语言让你理解：在``` React ```的``` setState ```函数实现中，会根据``` isBatchingUpdates ```(默认是``` false ```) 变量判断是否直接更新``` this.state ```还是放到队列中稍后更新。然后有一个``` batchedUpdate ```函数，可以修改``` isBatchingUpdates ```为``` true ```，当``` React ```调用事件处理函数之前，或者生命周期函数之前就会调用``` batchedUpdate ```函数，这样的话，``` setState ```就不会同步更新``` this.state ```，而是放到更新队列里面后续更新。\n\n这样你就可以理解为什么原生事件和``` setTimeout/setinterval ```里面调用``` this.state ```会同步更新了吧，因为通过这些函数调用的``` React ```没办法去调用``` batchedUpdate ```函数将``` isBatchingUpdates ```设置为``` true ```，那么这个时候``` setState ```的时候默认就是``` false ```，那么就会同步更新。\n\n```最后```\n\n``` setState ```是``` React ```非常重要的一个方法，值得大家好好去研究一下他的原理。","like_users":[],"create_time":{"$date":"2019-10-28T14:31:08.473Z"},"update_time":{"$date":"2019-10-28T14:31:08.473Z"},"id":16,"__v":0}
{"_id":{"$oid":"5db8ee050459c20030b9ed6d"},"meta":{"views":44,"likes":0,"comments":0},"keyword":["Vue 面试题"],"desc":"30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）","numbers":"28251","img_url":"http://img.golderbrother.cn/vue-logo.png","type":1,"state":1,"origin":1,"tags":[{"$oid":"5da1aa7855bcb9003009ed87"}],"comments":[],"category":[{"$oid":"5da1aa6b55bcb9003009ed86"}],"title":"30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）","author":"golderBrother","content":"# 30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）\n\n## 前言\n\n本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。\n\n希望读者读完本文，有一定的启发思考，也能对自己的 Vue 掌握程度有一定的认识，对缺漏之处进行弥补，对 Vue 有更好的掌握\n\n### 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么\n\nSPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\n\n优点：\n\n- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n- 基于上面一点，SPA 相对对服务器压力小；\n- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\n\n缺点：\n\n- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\n- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\n- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。\n\n### 2、v-show 与 v-if 有什么区别\n\n- v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\n- v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。\n\n所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。\n\n### 3、Class 与 Style 如何动态绑定\n\n#### Class 可以通过对象语法和数组语法进行动态绑定\n\n- 对象语法：\n  实际上绑定后的类名就是键名，键值为是否绑定\n\n```js\n\u003cdiv v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\u003e\u003c/div\u003e\ndata: {\n  isActive: true,\n  hasError: false\n}\n```\n\n- 数组语法：\n  实际上就是支持绑定多个类名，支持表达式\n\n```js\n\u003cdiv v-bind:class=\"[isActive ? activeClass : '', errorClass]\"\u003e\u003c/div\u003e\n\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n\n#### Style 也可以通过对象语法和数组语法进行动态绑定\n\n- 对象语法：\n  实际上就是直接绑定样式值\n\n```js\n\u003cdiv v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"\u003e\u003c/div\u003e\n\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n```\n\n- 数组语法：\n  实际上就是绑定的是样式对象\n\n```js\n\u003cdiv v-bind:style=\"[styleColor, styleSize]\"\u003e\u003c/div\u003e\n\ndata: {\n  styleColor: {\n     color: 'red'\n   },\n  styleSize:{\n     fontSize:'23px'\n  }\n}\n```\n\n### 4、怎样理解 Vue 的单向数据流\n\n所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。\n这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。\n额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。\n这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n子组件想修改时，只能通过 \\$emit 派发一个自定义事件，父组件接收到后，由父组件修改。\n有两种常见的试图改变一个 prop 的情形 :\n\n- **这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用**。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：\n\n```js\n\nprops: ['initialCounter'],\ndata: function () {\nreturn {\ncounter: this.initialCounter\n}\n}\n\n```\n\n- **这个 prop 以一种原始的值传入且需要进行转换**。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性\n\n```js\n\nprops: ['size'],\ncomputed: {\nnormalizedSize: function () {\nreturn this.size.trim().toLowerCase()\n}\n}\n\n```\n\n这样通过一个计算属性来对props数据进行定制化的处理，就不会改变props数据啦！\n\n### 5、computed 和 watch 的区别和运用的场景\n\n**computed**： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；\n**watch**： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；\n**运用场景**：\n\n- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n\n- 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n### 6、直接给一个数组项赋值，Vue 能检测到变化吗？\n\n由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：\n\n- 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue\n\n- 当你修改数组的长度时，例如：vm.items.length = newLength\n\n为了解决第一个问题，Vue 提供了以下操作方法：\n\n```js\n\n// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// vm.$set，Vue.set的一个别名\nvm.$set(vm.items, indexOfItem, newValue)\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n\n```\n\n为了解决第二个问题，Vue 提供了以下操作方法：\n\n```js\n\n// Array.prototype.splice\nvm.items.splice(newLength)\n\n````\n\n\u003e 因为尤大大在数组的监测上考虑到了性能方面的问题，所以不能做到数据元素或者数组长度改变的监听，只能通过set这个API或者数组的方法，本质上源码也是调用原生数组的方法对操作数组来改变数据的。\n\n### 7、谈谈你对 Vue 生命周期的理解？\n\n（1）生命周期是什么？\nVue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -\u003e 渲染、更新 -\u003e 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。\n\n（2）各个生命周期的作用\n| 生命周期 | 描述 |\n| ------ | ------ |\n| beforeCreate | 组件实例被创建之初，组件的属性生效之前 |\n| created | 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 |\n| beforeMount | 在挂载开始之前被调用：相关的 render 函数首次被调用，真实 dom 还是没有生成 |\n| mounted | el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 |\n| beforeUpdate | 组件数据更新之前调用，发生在虚拟 DOM 打补丁（dom diff -\u003e patch）之前 |\n| updated |  组件数据更新之后 |\n| activited | keep-alive 专属，被包裹的组件被激活时调用 |\n| deactivated | keep-alive 专属，被包裹的组件被销毁时调用 |\n| beforeDestory | 组件销毁前调用，在这个钩子还能操作data和methods等 |\n| destroyed | 组件销毁后调用，移除监听，解绑事件，销毁组件 |\n\n（3）生命周期示意图\n![vue-lifecycle](http://img.golderbrother.cn/vue-liftcycle.webp)\n\n### 8、Vue 的父组件和子组件生命周期钩子函数执行顺序？\n\nVue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：\n\n- 加载渲染过程\n父 beforeCreate -\u003e 父 created -\u003e 父 beforeMount -\u003e 子 beforeCreate -\u003e 子 created -\u003e 子 beforeMount -\u003e 子 mounted -\u003e 父 mounted\n- 子组件更新过程\n父 beforeUpdate -\u003e 子 beforeUpdate -\u003e 子 updated -\u003e 父 updated\n- 父组件更新过程\n父 beforeUpdate -\u003e 父 updated\n- 销毁过程\n父 beforeDestroy -\u003e 子 beforeDestroy -\u003e 子 destroyed -\u003e 父 destroyed\n总的来说，生命周期钩子函数的执行顺序是父(前) -\u003e 子(前) -\u003e 子(后) -\u003e 父(后)\n\n### 9、在哪个生命周期内调用异步请求？\n\n可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：\n\n- 能更快获取到服务端数据，减少页面 loading 时间；\n- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；\n\n### 10、在什么阶段才能访问操作DOM？\n\n在钩子函数```mounted```被调用前，Vue 已经将编译好的模板(tamplate)挂载到页面上(el)，所以在 mounted 中可以访问操作 DOM。\nvue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。\n\n![vue-lifecycle](http://img.golderbrother.cn/vue-lifecycle.png)\n\n### 11、父组件可以监听到子组件的生命周期吗？\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：\n\n```js\n// Parent.vue\n\u003cChild @mounted=\"doSomething\"/\u003e\n\n// Child.vue\nmounted() {\n  this.$emit(\"mounted\");\n}\n以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过``` @hook ```来监听即可，如下所示：\n```\n\n```js\n// Parent.vue\n\u003cChild @hook:mounted=\"doSomething\" \u003e\u003c/Child\u003e\n\ndoSomething() {\nconsole.log('父组件监听到 mounted 钩子函数 ...');\n},\n\n// Child.vue\nmounted(){\nconsole.log('子组件触发 mounted 钩子函数 ...');\n},\n\n// 以上输出顺序为：\n// 子组件触发 mounted 钩子函数 ...\n// 父组件监听到 mounted 钩子函数 ...\n\n```\n\n当然```@hook```方法不仅仅是可以监听```mounted```，其它的生命周期事件，例如：```created，updated```等都可以监听。\n\n### 12、谈谈你对 keep-alive 的了解？\n\n```\u003ckeep-alive\u003e```是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。\n```\u003ckeep-alive\u003e```包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。\n```\u003ckeep-alive\u003e```与 ```\u003ctransition\u003e```相似，只是一个抽象组件，它不会在DOM树中渲染(真实或者虚拟都不会)，也不在父组件链中存在，比如：你永远在 this.$parent 中找不到 keep-alive 。\nkeep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：\n\n- 一般结合路由和动态组件一起使用，用于缓存组件；\n- 提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；\n- 对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。\n\ninclude 和 exclude的用法如下：\n\n```html\n\u003ckeep-alive include=\"test-keep-alive\"\u003e\n  \u003c!-- 将缓存name为test-keep-alive的组件\n  \u003ccomponent\u003e\u003c/component\u003e\n\u003c/keep-alive\u003e\n\n\u003ckeep-alive include=\"a,b\"\u003e\n  \u003c!-- 将缓存name为a或者b的组件，结合动态组件使用 --\u003e\n  \u003ccomponent :is=\"view\"\u003e\u003c/component\u003e\n\u003c/keep-alive\u003e\n\n\u003c!-- 使用正则表达式，需使用v-bind --\u003e\n\u003ckeep-alive :include=\"/a|b/\"\u003e\n  \u003ccomponent :is=\"view\"\u003e\u003c/component\u003e\n\u003c/keep-alive\u003e\n\n\u003c!-- 动态判断 --\u003e\n\u003ckeep-alive :include=\"includedComponents\"\u003e\n  \u003crouter-view\u003e\u003c/router-view\u003e\n\u003c/keep-alive\u003e\n\n\u003ckeep-alive exclude=\"test-keep-alive\"\u003e\n  \u003c!-- 将不缓存name为test-keep-alive的组件 --\u003e\n  \u003ccomponent\u003e\u003c/component\u003e\n\u003c/keep-alive\u003e\n\n```\n\n### 13、组件中 data 为什么是一个函数\n\n\u003e 为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？\n\n```js\n// data\ndata() {\n  return {\n    message: \"子组件\",\n    childName:this.name\n  }\n}\n\n// new Vue\nnew Vue({\n  el: '#app',\n  router,\n  template: '\u003cApp/\u003e',\n  components: {App}\n})\n```\n\n因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响。\n\n如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。\n\n### 14、v-model 的原理\n\n我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：\n\n- text 和 textarea 元素使用 value 属性和 input 事件；\n- checkbox 和 radio 使用 checked 属性和 change 事件；\n- select 字段将 value 作为 prop 并将 change 作为事件。\n  以 input 表单元素为例：\n\n```js\n\u003cinput v-model='something'\u003e\n\n相当于\n\n\u003cinput v-bind:value=\"something\" v-on:input=\"something = $event.target.value\"\u003e\n```\n\n如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：\n\n```js\n// 父组件：\n\u003cModelChild v-model=\"message\"\u003e\u003c/ModelChild\u003e\n\n// 子组件：\n\u003cdiv\u003e{{value}}\u003c/div\u003e\n\nprops:{\n    value: String\n},\nmethods: {\n  test1(){\n     this.$emit('input', '小红')\n  },\n},\n```\n\n### 15、Vue 组件间通信有哪几种方式\n\nVue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。\n\nVue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。\n\n#### （1）props / \\$emit 适用 父子组件通信\n\n这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。\n\n#### （2）ref 与 $parent / $children 适用 父子组件通信\n\nref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例\n$parent / $children：访问父 / 子实例\n\n继续将属性传递\n\n```html\n\u003cGrandson1 :value=\"value\"\u003e\u003c/Grandson1\u003e\n\u003ctemplate\u003e\n \u003cdiv\u003e\n  孙子:{{value}}\n  \u003c!-- 调用父组件的input事件 --\u003e\n  \u003cbutton @click=\"$parent.$emit('input',200)\"\u003e更改\u003c/button\u003e\n \u003c/div\u003e\n\u003c/template\u003e\n\u003cscript\u003e\nexport default {\n props: {\n  value: {\n   type: Number\n  }\n }\n};\n\u003c/script\u003e\n```\n\n如果层级很深那么就会出现$parent.$parent.....我们可以封装一个$dispatch方法向上进行派发\n\n```js\n#$dispatch\nVue.prototype.$dispatch = function $dispatch(eventName, data) {\n  let parent = this.$parent;\n  while (parent) {\n    parent.$emit(eventName, data);\n    parent = parent.$parent;\n  }\n};\n```\n\n既然能向上派发那同样可以向下进行派发\n\n```js\n#$broadcast\nVue.prototype.$broadcast = function $broadcast(eventName, data) {\n  const broadcast = function () {\n    this.$children.forEach((child) =\u003e {\n      child.$emit(eventName, data);\n      if (child.$children) {\n        $broadcast.call(child, eventName, data);\n      }\n    });\n  };\n  broadcast.call(this, eventName, data);\n};\n```\n\n#### （3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信\n\n这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。\n用于跨组件通知(不复杂的项目可以使用这种方式)\n\n```js\nVue.prototype.$bus = new Vue();\nSon2组件和Grandson1相互通信\n\n mounted() {\n  this.$bus.$on(\"my\", data =\u003e {\n   console.log(data);\n  });\n },\nmounted() {\n  this.$nextTick(() =\u003e {\n   this.$bus.$emit(\"my\", \"我是Grandson1\");\n  });\n },\n```\n\n#### （4）$attrs/$listeners 适用于 隔代组件通信\n\n$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=\"$attrs\" 传入内部组件。通常配合 inheritAttrs 选项一起使用。\n$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"$listeners\" 传入内部组件\n\n**$attrs**\n批量向下传入属性\n\n```js\n\u003cSon2 name=\"小珠峰\" age=\"10\"\u003e\u003c/Son2\u003e\n\n\u003c!-- 可以在son2组件中使用$attrs属性,可以将属性继续向下传递 --\u003e\n\u003cdiv\u003e\n  儿子2: {{$attrs.name}}\n  \u003cGrandson2 v-bind=\"$attrs\"\u003e\u003c/Grandson2\u003e\n\u003c/div\u003e\n\n\n\u003ctemplate\u003e\n \u003cdiv\u003e孙子:{{$attrs}}\u003c/div\u003e\n\u003c/template\u003e\n```\n\n\\$listeners\n批量向下传入方法\n\n```html\n\u003cSon2 name=\"小珠峰\" age=\"10\" @click=\"()=\u003e{this.mny = 500}\"\u003e\u003c/Son2\u003e\n\u003c!-- 可以在son2组件中使用listeners属性,可以将方法继续向下传递 --\u003e\n\u003cGrandson2 v-bind=\"$attrs\" v-on=\"$listeners\"\u003e\u003c/Grandson2\u003e\n\n\u003cbutton @click=\"$listeners.click()\"\u003e更改\u003c/button\u003e\n```\n\n#### （5）provide / inject 适用于 隔代组件通信\n\n祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。\n\n在父级中注入数据\n\n```js\nprovide() {\n  return { parentMsg: \"父亲\" };\n},\n```\n\nInject\n在任意子组件中可以注入父级数据\n\n```js\ninject: [\"parentMsg\"] // 会将数据挂载在当前实例上\n```\n\n#### （6）Vuex 适用于 父子、隔代、兄弟组件通信\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n\n- Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n- 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n\n### 16、你使用过 Vuex 吗\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。\n（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) 一个 mutation。这样使得我们可以方便地跟踪每一个状态的变化。\n\n主要包括以下几个模块：\nState：定义了应用状态的数据结构，可以在这里设置默认的初始状态。\nGetter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部(组件)计算属性，相当于方便获取 state。\nMutation：是唯一更改 store 中状态的方法，且必须是同步函数。\nAction：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。\nModule：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。\n\n### 17、使用过 Vue SSR 吗？说说 SSR\n\n\u003e Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些`静态标记(html字符串)` \"激活\"为客户端上完全可交互的应用程序。\n\u003e 即：SSR 大致的意思就是 vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。\n\n**服务端渲染 SSR 的优缺点如下**：\n**（1）服务端渲染的优点**：\n\n- 更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；\n- 更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；\n\n**（2） 服务端渲染的缺点**：\n\n- 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器(apache, tomcat 等)上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；\n- 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。\n\n### 18、vue-router 路由模式有几种\n\nvue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：\n\n```js\nswitch (mode) {\n  case 'history':\n    this.history = new HTML5History(this, options.base)\n    break\n  case 'hash':\n    this.history = new HashHistory(this, options.base, this.fallback)\n    break\n  case 'abstract':\n    this.history = new AbstractHistory(this, options.base)\n    break\n  default:\n    if (process.env.NODE_ENV !== 'production') {\n      assert(false, `invalid mode: ${mode}`)\n    }\n}\n```\n\n其中，3 种路由模式的说明如下：\n\n- hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；缺点是 url 不太美观\n- history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；缺点是当点击浏览器的刷新按钮后，会根据当前 url 去请求服务器端，因此如果服务端没有该资源处理，就需要加个重定向到首页之类的处理。\n- abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.\n\n### 19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗\n\n**（1）hash 模式的实现原理**\n早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：\n\n```html\nhttps://www.word.com#search\n```\n\nhash 路由模式的实现主要是基于下面几个特性：\n\n- URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；\n- hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制 hash 的切换；\n- 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；\n- 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。\n\n**（2）history 模式的实现原理**\nHTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。\n唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：\n\n```js\nwindow.history.pushState(null, null, path);\nwindow.history.replaceState(null, null, path);\n```\n\nhistory 路由模式的实现主要基于存在下面几个特性：\n\n- pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；\n- 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；\n- history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。\n\n### 20、什么是 MVVM\n\nModel–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。\n由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于 2005 年在他的博客上发表\nMVVM 源自于经典的 Model–View–Controller（MVC）模式 ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。\n\n如下图所示：\n![mvvm](http://img.golderbrother.cn/mvvm.webp)\n\n**（1）View 层**\nView 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。\n**（2）Model 层**\nModel 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口响应数据。\n**（3）ViewModel 层**\nViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。\n需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。\nMVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。\n这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，然后将处理好的数据返回给 View 层，进而以正确的方式渲染到页面上，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。\n\n我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：\n（1）View 层\n\n```html\n\u003cdiv id=\"app\"\u003e\n    \u003cp\u003e{{message}}\u003c/p\u003e\n    \u003cbutton v-on:click=\"showMessage()\"\u003eClick me\u003c/button\u003e\n\u003c/div\u003e\n```\n\n（2）ViewModel 层\n\n```js\nvar app = new Vue({\n    el: '#app',\n    data: {  // 用于描述视图状态\n        message: 'Hello Vue!',\n    },\n    methods: {  // 用于描述视图行为\n        showMessage(){\n            let vm = this;\n            alert(vm.message);\n        }\n    },\n    created(){\n        let vm = this;\n        // Ajax 获取 Model 层的数据\n        ajax({\n            url: '/your/server/data/api',\n            success(res){\n                vm.message = res;\n            }\n        });\n    }\n})\n```\n\n（3） Model 层\n\n```js\n{\n    \"url\": \"/your/server/data/api\",\n    \"res\": {\n        \"success\": true,\n        \"name\": \"IoveC\",\n        \"domain\": \"www.cnblogs.com\"\n    }\n}\n```\n\n### 21、Vue 是如何实现数据双向绑定的？\n\nVue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：\n\n![v-model](http://img.golderbrother.cn/v-model.webp)\n\n即：\n\n- 输入框内容变化时，Data 中的数据同步变化。即 View =\u003e Data 的变化。\n- Data 中的数据变化时，文本节点的内容同步变化。即 Data =\u003e View 的变化。\n\n其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。\n\nVue 主要通过以下 4 个步骤来实现数据双向绑定的：\n实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。\n\n实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数(update)，添加监听数据的订阅者(Watcher)，一旦数据有变动(`触发setter函数`)，收到通知(`notify`)，调用更新函数(`dependency里面的update函数`)进行数据更新。\n\n实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时(`notify`)，触发解析器 Compile 中对应的更新函数(`update`)。\n\n实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。\n\n以上四个步骤的流程图表示如下:\n![double-bind](http://img.golderbrother.cn/double-bind.webp)\n\ndemo:\n\n```js\n// 观察者模式(观察者和被观察者是有关系的), vue 就是典型的观察者模式，内部创建了很多个watcher\nclass Subject{ // 被观察者\n    constructor(){\n        this.stack = [];\n        this.state = '开心';\n    }\n    attach(observer){\n        // 观察者和被观察者中，将观察者放入被观察者中，观察者和被观察者直接进行交互\n        this.stack.push(observer);\n    }\n    setState(newState){\n        // 内部做了订阅，只要有更新状态就更新\n        this.state = newState;\n        // 并且通知观察者\n        this.stack.forEach(o=\u003eo.update(newState))\n    }\n}\nclass Observer{ // 观察者\n    constructor(name){ this.name = name }\n    update(newState){\n        console.log(this.name+\"小宝宝\"+newState)\n    }\n}\nlet o1 = new Observer('爸爸');\nlet o2 = new Observer('妈妈');\nlet s = new Subject('小宝宝');\ns.attach(o1);\ns.attach(o2);\ns.setState('不开心');\n```\n\n### 22、Vue 框架怎么实现对象和数组的监听\n\n如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持。\n同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象（已存在的属性）和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：\n\n- Observe a list of Array items.\n\n```js\n  observeArray (items: Array\u003cany\u003e) {\n    for (let i = 0, l = items.length; i \u003c l; i++) {\n        observe(items[i]) // observe 功能为监测数据的变化\n    }\n  }\n```\n\n/\\*\\*\n\n- 对属性进行递归遍历\n  \\*/\n  let childOb = !shallow \u0026\u0026 observe(val) // observe 功能为监测数据的变化\n  通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。\n\n### 23、Proxy 与 Object.defineProperty 优劣对比\n\nProxy 的优势如下:\nProxy 可以直接监听对象而非属性；\nProxy 可以直接监听数组的变化；\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；\nProxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；\nProxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；\nProxy 的缺点:\n\n- 兼容性不好，不能兼容 IE11\n  Object.defineProperty 的优势如下:\n- 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。\n  Object.defineProperty 的缺点:\n- 对于对象类型，默认一开始就递归转换成响应式对象。Proxy 只有在获取或者设置值的时候才会递归,性能上会好很多\n\n### 24、Vue 怎么用 vm.\\$set() 解决对象新增属性不能响应的问题 ？\n\n受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。\n由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。\n但是 Vue 提供了`Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)`来实现为对象添加响应式属性，那框架本身是如何实现的呢？\n我们查看对应的 Vue 源码：`vue/src/core/instance/index.js`\n\n```js\nexport function set (target: Array\u003cany\u003e | Object, key: any, val: any): any {\n  // target 为数组\n  if (Array.isArray(target) \u0026\u0026 isValidArrayIndex(key)) {\n    // 修改数组的长度, 避免索引\u003e数组长度导致splcie()执行有误\n    target.length = Math.max(target.length, key)\n    // 利用数组的splice变异方法触发响应式\n    target.splice(key, 1, val)\n    return val\n  }\n  // key 已经存在，直接修改属性值\n  if (key in target \u0026\u0026 !(key in Object.prototype)) {\n    target[key] = val\n    return val\n  }\n  const ob = (target: any).__ob__\n  // target 本身就不是响应式数据, 直接赋值\n  if (!ob) {\n    target[key] = val\n    return val\n  }\n  // 对属性进行响应式处理\n  defineReactive(ob.value, key, val)\n  ob.dep.notify()\n  return val\n```\n\n我们阅读以上源码可知，vm.\\$set 的实现原理是：\n\n- 如果目标是数组，直接使用数组的 splice 方法触发相应式；\n- 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 函数， 转换成响应式对象所调用的方法）\n\n### 25、虚拟 DOM 的优缺点\n\n优点：\n\n- 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；\n- 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；\n- 跨平台： 虚拟 DOM 本质上是 JavaScript 对象来模拟真实的 DOM 结构，而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如`服务器渲染、weex`开发等等。\n\n缺点:\n\n- 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。\n\n### 26、虚拟 DOM 实现原理\n\n虚拟 DOM 的实现原理主要包括以下 3 部分：\n\n- 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；\n- diff 算法 — 比较两棵虚拟 DOM 树的差异；\n- pach 算法 — 打补丁，将两个虚拟 DOM 对象的差异应用到真正的 DOM 树，然后只更新改变部分的内容。\n\n### 27、Vue 中的 key 有什么作用\n\n```key``` 是为 ```Vue``` 中 ```vnode``` 的唯一标记，通过这个 ```key```，我们的 ```diff``` 操作可以更准确、更快速。\n```Vue``` 的 ```diff``` 过程可以概括为：```oldCh``` 和 ```newCh``` 各有两个头尾的变量 ```oldStartIndex```、```oldEndIndex``` 和 ```newStartIndex```、```newEndIndex```，它们会新节点和旧节点会进行两两对比，即一共有 4 种比较方式：```newStartIndex``` 和 ```oldStartIndex``` 、```newEndIndex``` 和 ```oldEndIndex``` 、```newStartIndex``` 和 ```oldEndIndex``` 、```newEndIndex``` 和 ``oldStartIndex``，如果以上 4 种比较都没匹配，如果设置了 ```key```，就会用 ```key``` 再进行比较，在比较的过程中，遍历会往中间靠，一旦 ```StartIdx``` \u003e ```EndIdx``` 表明 ```oldCh``` 和 ```newCh``` 至少有一个已经遍历完了，就会结束比较。\n具体有无 ```key``` 的 ```diff``` 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《深入剖析：```Vue``` 核心之虚拟 ```DOM```\n所以 ```Vue``` 中 ```key``` 的作用是：```key``` 是为 ```Vue``` 中 vnode 的唯一标记，通过这个 ```key```，我们的 ```diff``` 操作可以更准确、更快速\n\n**更准确**：因为带 ```key``` 就不是就地复用了，在 ```sameNode``` 函数`a.key === b.key`对比中可以避免就地复用的情况。所以会更加准确。\n**更快速**：利用 ```key``` 的唯一性生成 ```map``` 对象来获取对应节点，比遍历方式更快，源码如下：\n\n```js\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  let i, key\n  const map = {}\n  for (i = beginIdx; i \u003c= endIdx; ++i) {\n    key = children[i].key\n    if (isDef(key)) map[key] = i\n  }\n  return map\n}\n```\n\n### 28、你有对 Vue 项目进行哪些优化？\n\n如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章《 Vue 项目性能优化 — 实践指南 》，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。\n\n**（1）代码层面的优化**\n\n- Q: v-if 和 v-show 区分使用场景\n  A: v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景\n- Q: computed 和 watch 区分使用场景\n  A: 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n  当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n- v-for 遍历必须为 item 添加 key，且避免同时使用 v-if\n\n- 长列表性能优化\n\n- Q:事件的销毁\n  在组件销毁前的钩子函数中（`boforeMount`）移除事件监听等\n\n- Q: 图片资源懒加载\n  非可视区域：```src -\u003e data-src```\n  可视区域：```data-src -\u003e src```\n\n- Q: 路由懒加载\n  ```import('xxx').then(res =\u003e res.default);```\n\n- Q: 第三方插件的按需引入\n  A: `antd babel-import-plugin`按需引入组件\n\n- Q: 优化无限列表性能\n  A: 思路，可以在当前可视区域内，对上部分的做个空白的 div，下面的也一样，每次只更新中间的数据\n\n- 服务端渲染 SSR or 预渲染\n  可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染\n\n```js\n\u003clink rel=\"prerender\" href=\"http://example.com\" /\u003e\n```\n\n预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染\n\n（2）Webpack 层面的优化\n\n- Webpack 对图片进行压缩\n  将打包后的图片进行优化\n\n```js\nnpm install image-webpack-loader --save-dev\n// 在file-loader之前使用压缩图片插件\n\nloader: \"image-webpack-loader\",\noptions: {\n  mozjpeg: {\n    progressive: true,\n    quality: 65\n  },\n  // optipng.enabled: false will disable optipng\n  optipng: {\n    enabled: false,\n  },\n  pngquant: {\n    quality: [0.90, 0.95],\n    speed: 4\n  },\n  gifsicle: {\n    interlaced: false,\n  },\n  // the webp option will enable WEBP\n  webp: {\n    quality: 75\n  }\n}\n```\n\n\u003e 可以发现图片大小是有了明显的变化\n\n- 减少 ES6 转为 ES5 的冗余代码\n  使用 transform-runtime A plugin that enables the re-use of Babel's injected helper code to save on codesize.可以帮我们节省代码\n\n```js\nnpm install --save-dev @babel/plugin-transform-runtime @babel/runtime\n// 在.babelrc中配置插件\n\n\"plugins\": [\n    \"@babel/plugin-transform-runtime\"\n]\n```\n\n- 提取公共代码\n  SplitChunks 这个配置，他可以在编译时抽离第三方模块、公共模块\n\n```js\n配置SplitChunks插件\n\n默认配置在此，我一个个描述下含义\n\nsplitChunks: {\n  chunks: 'async', // 分割异步模块\n  minSize: 30000, // 分割的文件最小大小\n  maxSize: 0,\n  minChunks: 1, // 引用次数\n  maxAsyncRequests: 5, // 最大异步请求数\n  maxInitialRequests: 3, // 最大初始化请求数\n  automaticNameDelimiter: '~', // 抽离的命名分隔符\n  automaticNameMaxLength: 30, // 名字最大长度\n  name: true,\n  cacheGroups: { // 缓存组\n    vendors: { // 先抽离第三方\n      test: /[\\\\/]node_modules[\\\\/]/,\n      priority: -10\n    },\n    default: {\n      minChunks: 2,\n      priority: -20, // 优先级\n      reuseExistingChunk: true\n    }\n  }\n}\n```\n\n- 模板预编译\n\n- 提取组件的 CSS\n  默认只在打包时进行样式抽离\n\n```js\nmodule.exports = env =\u003e {\n  let isDev = env.development;\n  const base = {/*source...*/}\n  if (isDev) {\n    return merge(base, dev);\n  } else {\n    return merge(base, prod);\n  }\n};\n\n// 安装抽离插件\n\nnpm install mini-css-extract-plugin --save-dev\n\n// 配置抽离插件\n\n{\n    test: /\\.css$/,\n    use: [\n        !isDev \u0026\u0026 MiniCssExtractPlugin.loader,\n        isDev \u0026\u0026 'style-loader',\n        \"css-loader\"\n    ].filter(Boolean)\n}\n!isDev \u0026\u0026 new MiniCssExtractPlugin({\n    filename: \"css/[name].css\"\n})\n```\n\n- 优化 SourceMap\n\n```js\neval 生成代码 每个模块都被eval执行,每一个打包后的模块后面都增加了包含sourceURL\nsource-map 产生map文件\ninline 不会生成独立的 .map文件,会以dataURL形式插入\ncheap 忽略打包后的列信息，不使用loader中的sourcemap\nmodule 没有列信息，使用loader中的sourcemap(没有列信息)\ndevtool:isDev?'cheap-module-eval-source-map':false\n// 每个库中采用的sourcemap方式不一,可以根据自己的需要自行配置\n```\n\n- 构建结果输出分析\n\n```js\n// 默认就会展现当前应用的分析图表\nconst {BundleAnalyzerPlugin} = require('webpack-bundle-analyzer');\nmode !== \"development\" \u0026\u0026 new BundleAnalyzerPlugin()\n```\n\nVue 项目的编译优化\n（3）基础的 Web 技术的优化\n\n- 开启 gzip 压缩\n  ```nginx``` 配置\n\n- 浏览器缓存\n  (1)**强缓存**\n  实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200\n\n```js\nExpires: Wed, 22 Oct 2018 08:41:00 GMT\n```\n\nExpires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。\n\n```js\nCache-control: max-age=30\n```\n\nCache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。\n\n(2) **协商缓存**\n\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。\n\n协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。\n\n### Last-Modified 和 If-Modified-Since\n\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。\n\n但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag\n\n- CDN 的使用\n  图片等静态资源上传到七牛云等 cdn 服务器\n\n```js\nconst AddAssetHtmlCdnPlugin = require('add-asset-html-cdn-webpack-plugin')\nnew AddAssetHtmlCdnPlugin(true,{\n    'jquery':'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js'\n})\n```\n\n但是在代码中还希望引入 jquery 来获得提示\n\n```js\nimport $ from 'jquery'\nconsole.log('$',$)\n```\n\n但是打包时依然会将 jquery 进行打包\n\n```js\nexternals:{\n  'jquery':'$'\n}\n```\n\n在配置文件中标注 jquery 是外部的，这样打包时就不会将 jquery 进行打包了\n\n- 使用 Chrome Performance 查找性能瓶颈\n\n### 29、对于即将到来的 vue3.0 特性你有什么了解的吗？\n\nVue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：\n\n**（1）监测机制的改变**\n\n3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：\n\n- 只能监测属性，不能监测对象\n- 不能检测属性的添加和删除；\n- 不能检测数组索引和长度的变更；\n- 支持 Map、Set、WeakMap 和 WeakSet。\n  新的 observer 还提供了以下特性\n- 用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。\n- 默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。\n- 更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。\n- 不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。\n- 更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。\n\n**（2）模板**\n模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。\n同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。\n\n**（3）对象式的组件声明方式**\nvue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。\n3.0 修改了组件的声明方式，改成了**类式**的写法，这样使得和`TypeScript`的结合变得很容易。\n此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。\n现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。\n\n**（4）其它方面的更改**\nvue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：\n\n- 支持自定义渲染器，从而使得`weex`可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。\n- 支持`Fragment`（多个根节点）和`Protal`（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。\n- 基于`treeshaking`优化，提供了更多的内置功能。\n\n## 总结\n\n本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。希望对读完本文的你有帮助、有启发，如果有不足之处，欢迎批评指正交流！","like_users":[],"create_time":{"$date":"2019-10-30T01:57:25.076Z"},"update_time":{"$date":"2019-10-30T01:57:25.076Z"},"id":17,"__v":0}
{"_id":{"$oid":"5db96f800459c20030b9ed6e"},"meta":{"views":16,"likes":0,"comments":0},"keyword":["React生命周期("],"desc":"详解React生命周期(包括react16版)","numbers":"4500","img_url":"http://img.golderbrother.cn/react-logo.svg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5cd447d79865305588453109"}],"comments":[],"category":[{"$oid":"5cd44852986530558845310a"}],"title":"详解React生命周期(包括react16版)","author":"golderBrother","content":"## React v16.0 前的生命周期\n\n其实大部分团队不见得会跟进升到 16 版本，所以 16 前的生命周期还是很有必要掌握的，何况 16 也是基于之前的修改\n\n![react15-lifecycle](./images/react15-lifecycle.png)\n\n## 第一个是组件初始化(initialization)阶段\n\n也就是以下代码中类的构造方法( `constructor()` ),`Test` 类继承了 `react Component` 这个**基类**，也就继承这个 · 的**基类**，才能有 `render()`,生命周期等方法可以使用，这也说明为什么`函数组件不能使用这些方法的原因`。\n\n`super(props)`用来调用基类的构造方法( `constructor()` ), 也将父组件的 props 注入给子组件，功子组件读取(组件中 `props` **只读不可变**，· 可变)。\n而`constructor()`用来做一些组件的初始化工作，如定义 this.state 的初始内容。\n\n```js\nimport React, { Component } from 'react';\n\nclass Test extends Component {\n  constructor(props) {\n    super(props);\n  }\n}\n```\n\n## 第二个是组件的挂载(Mounting)阶段\n\n## 此阶段分为 componentWillMount，render，componentDidMount 三个时期。\n\n- `componentWillMount`:\n  在组件挂载到 DOM 前调用，且只会被调用一次，在这边调用 `this.setState` 不会引起组件重新渲染，也可以把写在这边的内容提前到 constructor()中，所以项目中很少用。\n\n- `render`:\n  根据组件的 `props` 和 `state`（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新 `render`） ，return 一个 React 元素（描述组件，即 UI），不负责组件实际渲染工作，之后由 React 自身根据此元素去渲染出页面 DOM。render 是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行 this.setState，会有改变组件状态的副作用。\n\n- `componentDidMount`:\n  组件挂载到 DOM 后调用，且只会被调用一次\n\n## 第三个是组件的更新(update)阶段\n\n在讲述此阶段前需要先明确下 `react` 组件**更新机制**。`setState` 引起的 `state` 更新或父组件重新 `render` 引起的 `props` 更新，更新后的 `state` 和 `props` 相对之前无论是否有变化，都将引起子组件的重新 `render`。[详细可看这篇文章](https://www.cnblogs.com/penghuwan/p/6707254.html)\n\n### 造成组件更新有两类（三种）情况：\n\n1.父组件重新 `render` 引起子组件重新 `render` 的情况有两种，内容及代码修引自[xiaoyann 的回答](https://segmentfault.com/q/1010000006019858)\n\n- a. 直接使用,每当父组件重新 `render` 导致的重传 props，子组件将直接跟着重新渲染，无论 props 是否有变化。可通过 shouldComponentUpdate 方法优化\n\n```js\nclass Child extends Component {\n  shouldComponentUpdate(nextProps) {\n    // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染\n    if (nextProps.someThings === this.props.someThings) {\n      return false;\n    }\n  }\n  render() {\n    return \u003cdiv\u003e{this.props.someThings}\u003c/div\u003e;\n  }\n}\n```\n\n- b.在 `componentWillReceiveProps` 方法中，将 `props` 转换成自己的 `state`\n\n```js\nclass Child extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      someThings: props.someThings\n    };\n  }\n  componentWillReceiveProps(nextProps) {\n    // 父组件重传props时就会调用这个方法\n    this.setState({ someThings: nextProps.someThings });\n  }\n  render() {\n    return \u003cdiv\u003e{this.state.someThings}\u003c/div\u003e;\n  }\n}\n```\n\n根据官网的描述\n\n\u003e 在该函数(componentWillReceiveProps)中调用 this.setState() 将不会引起第二次渲染。\n\n是因为 `componentWillReceiveProps` 中判断 `props` 是否变化了，若变化了，`this.setState` 将引起 `state` 变化，从而引起 render，此时就没必要再做第二次因重传 `props` 引起的 render 了，不然重复做一样的渲染了\n\n- 2.组件本身调用 `setState`，无论 `state` 有没有变化。可通过 `shouldComponentUpdate` 方法优化。\n\n```js\nclass Child extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      someThings: 1\n    };\n  }\n  shouldComponentUpdate(nextStates) {\n    // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染\n    if (nextStates.someThings === this.state.someThings) {\n      return false;\n    }\n  }\n\n  handleClick = () =\u003e {\n    // 虽然调用了setState ，但state并无变化\n    const preSomeThings = this.state.someThings;\n    this.setState({\n      someThings: preSomeThings\n    });\n  };\n\n  render() {\n    return \u003cdiv onClick={this.handleClick}\u003e{this.state.someThings}\u003c/div\u003e;\n  }\n}\n```\n\n### 此阶段分为 componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，render，componentDidUpdate\n\n- `componentWillReceiveProps(nextProps)`\n  此方法只调用于 props 引起的组件更新过程中，参数 nextProps 是父组件传给当前组件的新 `props`。但父组件 `render` 方法的调用不能保证重传给当前组件的 props 是有变化的，所以在此方法中根据 `nextProps` 和 `this.props` 来查明重传的 `props` 是否改变，以及如果改变了要执行啥，比如根据新的 `props` 调用 `this.setState` 出发当前组件的重新 `render`\n- `shouldComponentUpdate(nextProps, nextState)`\n  此方法通过比较 n`extProps`，`nextState` 及当前组件的 `this.props`，`this.state`，返回 `true` 时当前组件将继续执行更新过程，返回 `false` 则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。\n\nps：这边也可以看出，就算 `componentWillReceiveProps()`中执行了 `this.setState`，更新了 `state`，但在 `render` 前（如 `shouldComponentUpdate，componentWillUpdate`），`this.state` 依然指向更新前的 `state`，不然 `nextState` 及当前组件的 `this.state` 的对比就一直是 `false` 了。\n\n- `componentWillUpdate(nextProps, nextState)`\n  此方法在调用 `render` 方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。\n\n- `render`\n  `render` 方法在上文讲过，这边只是重新调用。\n\n- `componentDidUpdate(prevProps, prevState)`\n  此方法在组件更新后被调用，可以操作组件更新的 `DOM`，`prevProps` 和 `prevState` 这两个参数指的是组件更新前的 `props` 和 `state`\n\n### 卸载阶段\n\n此阶段只有一个生命周期方法：`componentWillUnmount`\n\n- `componentWillUnmount`\n  此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚 `componentDidMount` 中手动创建的 `DOM` 元素等，以避免引起**内存泄漏**。\n\n### React v16.4 的生命周期\n\n![react15-lifecycle](./images/react16.4-lifecycle.png)\n\n## 最后\n\n文中若有不准确或错误的地方，欢迎指出，有兴趣可以的关注下[Github](https://github.com/GolderBrother)~\n","like_users":[],"create_time":{"$date":"2019-10-30T11:09:52.696Z"},"update_time":{"$date":"2019-10-30T11:09:52.696Z"},"id":18,"__v":0}
{"_id":{"$oid":"5dbd91be0459c20030b9ed6f"},"meta":{"views":10,"likes":0,"comments":0},"keyword":["HTTP/2与HTTP/3 的新特性"],"desc":"解读HTTP/2与HTTP/3 的新特性（推荐）","numbers":"8705","img_url":"http://img.golderbrother.cn/http1.x.jpg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5db701f50459c20030b9ed6a"}],"comments":[],"category":[{"$oid":"5db702340459c20030b9ed6b"}],"title":"解读HTTP/2与HTTP/3 的新特性（推荐）","author":"golderBrother","content":"## 前言\nHTTP/2 相比于 HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。\n\n虽然 HTTP/2 提高了网页的性能，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。\n\n## 一、HTTP/1.1发明以来发生了哪些变化\n\n如果仔细观察打开那些最流行的网站首页所需要下载的资源的话，会发现一个非常明显的趋势。近年来加载网站首页需要的下载的数据量在逐渐增加，并已经超过了2100K。但在这里我们更应该关心的是：平均每个页面为了完成显示与渲染所需要下载的资源数已经超过了100个。\n\n正如下图所示，从2011年以来,传输数据大小与平均请求资源数量不断持续增长，并没有减缓的迹象。该图表中绿色直线展示了传输数据大小的增长，红色直线展示了平均请求资源数量的增长。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87KJWsiceGg7I8oOvshUePibiaLva1kcoibFTMy2UPzx81FsEA80IpfwM5oQ/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\nHTTP/1.1自从1997年发布以来，我们已经使用HTTP/1.x 相当长一段时间了，但是随着近十年互联网的爆炸式发展，从当初网页内容以文本为主,到现在以富媒体（如图片、声音、视频）为主,而且对页面内容实时性高要求的应用越来越多(比如聊天、视频直播),于是当时协议规定的某些特性，已经无法满足现代网络的需求了。\n\n## 二、HTTP/1.1的缺陷\n### 1.高延迟--带来页面加载速度的降低\n\n虽然近几年来网络带宽增长非常快，然而我们却并没有看到网络延迟有对应程度的降低。**网络延迟问题主要由于队头阻塞(Head-Of-Line Blocking),导致带宽无法被充分利用**。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87ic36NC1Oic6K0e6cfsW9yuCp6t5S19L9YBGbm642xTX4R09tsRZZmVWg/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对队头阻塞,人们尝试过以下办法来解决:\n\n- 将同一页面的资源分散到不同域名下，提升连接上限。 **Chrome有个机制，对于同一个域名，默认允许同时建立 6 个 TCP持久连接**，使用持久连接时，虽然能公用一个TCP管道，**但是在一个管道中同一时刻只能处理一个请求**，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。 \n- ```Spriting```合并多张小图为一张大图,再用JavaScript或者CSS将小图重新“切割”出来的技术。\n- ```内联(Inlining)``是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。\n\n```\n.icon1 {    background: url(data:image/png;base64,\u003cdata\u003e) no-repeat;  }\n.icon2 {    background: url(data:image/png;base64,\u003cdata\u003e) no-repeat;  }\n```\n- 拼接(Concatenation)将多个体积较小的JavaScript使用webpack等工具打包成1个体积更大的JavaScript文件,但如果其中1个文件的改动就会导致大量数据被重新下载多个文件。\n\n### 2.无状态特性--带来的巨大HTTP头部\n由于报文Header一般会携带```\"User Agent\"\"Cookie\"\"Accept\"\"Server\"```等许多固定的头字段（如下图），多达几百字节甚至上千字节，但Body却经常只有几十字节（比如GET请求、\n204/301/304响应），成了不折不扣的“大头儿子”。```Header```里携带的内容过大，在一定程度上增加了传输的成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87NPXnEYJASL6clgG9vcKYBKHBzAWkne6v3CyUKvYdIDBAIEQ1J2AIIA/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n### 3.明文传输--带来的不安全性\nHTTP/1.1在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。\n\n你有没有听说过\"免费WiFi陷阱”之类的新闻呢？黑客就是利用了```HTTP明文传输```的缺点，在公共场所架设一个WiFi热点开始“钓鱼”，诱骗网民上网。一旦你连上了这个WiFi热点，所有的流量都会被截获保存，里面如果有银行卡号、网站密码等敏感信息的话那就危险了，黑客拿到了这些数据就可以冒充你为所欲为。\n\n### 4.不支持服务器推送消息\n\n## 三、SPDY 协议与 HTTP/2 简介\n### 1.SPDY 协议\n上面我们提到,由于HTTP/1.x的缺陷，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到2009年，谷歌公开了自行研发的 SPDY 协议，主要解决HTTP/1.1效率不高的问题。谷歌推出SPDY，才算是正式改造HTTP协议本身。降低延迟，压缩header等等，SPDY的实践证明了这些优化的效果，也最终带来HTTP/2的诞生。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87XkQYkemoujia6ZPNwgibUX6GqnzdlFou0WzTnQibcWa0uTA2vegZPw2IQ/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n**HTTP/1.1有两个主要的缺点：安全不足和性能不高**，由于背负着 HTTP/1.x 庞大的历史包袱,所以协议的修改,兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产。如上图所示,\nSPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。\n\nSPDY 协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。\n\n### 2.HTTP/2 简介\n\n2015年，HTTP/2 发布。HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写，**HTTP方法/状态码/语义都与HTTP/1.x一样。HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）**。从目前的情况来看，国内外一些排名靠前的站点基本都实现了HTTP/2的部署，使用HTTP/2能带来20%~60%的效率提升。\n\nHTTP/2由两个规范（Specification）组成：\n\nHypertext Transfer Protocol version 2 - RFC7540\n\nHPACK - Header Compression for HTTP/2 - RFC7541\n\n## 四、HTTP/2 新特性\n### 1.二进制传输\n```HTTP/2```传输数据量的大幅减少,主要有两个原因:**以二进制方式传输和Header 压缩**。我们先来介绍二进制传输,HTTP/2 采用```二进制格式传输数据```，而非HTTP/1.x 里```纯文本形式的报文``` ，二进制协议解析起来更高效。**HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码**。\n\n它把TCP协议的部分特性挪到了应用层，把原来的\"Header+Body\"的消息\"打散\"为数个小片的二进制\"帧\"(Frame),**用\"HEADERS\"帧存放头数据、\"DATA\"帧存放实体数据**。HTP/2数据分帧后\"Header+Body\"的报文结构就完全消失了，协议看到的只是一个个的\"碎片\"。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87xnwFEkrXZJZ6ORK1qUpNoPNiaHNES7rEsK9XNkP638jiatPA06qYQN0w/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\nHTTP/2 中，同域名下所有通信都在**单个连接**上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个**帧**组成。**多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装**。\n\n### 2.Header 压缩\n\nHTTP/2并没有使用传统的压缩算法，而是开发了专门的**\"HPACK”**算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。\n\n具体来说:\n\n- 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；\n\n- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;\n\n- 每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值\n\n例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87W3C6GXr1CDt3avVmWsURbboBrKJDkPaUbMlKDfQOx1jllg810ibdYiaQ/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n### 3.多路复用\n在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。\n\n大家可以通过 该链接 直观感受下 HTTP/2 比 HTTP/1 到底快了多少。\n\n![image](https://mmbiz.qpic.cn/mmbiz_gif/zewrLkrYfsPJcceCMInZpsVErpdiaXm87NeE80WQfZqqHJHh38s8LGQXPUTR1nkJsl34QMm0QHYjSAqTPBxeDmw/640?wx_fmt=gif\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1)\n\n在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中,\n\n- 同域名下所有通信都在单个连接上完成。\n\n- 单个连接可以承载任意数量的双向数据流。\n\n- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。\n\n这一特性，使性能有了极大提升：\n\n- 同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。\n\n- 并行交错地发送多个请求/响应，请求/响应之间互不影响。\n\n- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm876estnPHia4HT6YYwWJhiaiczPQx6h0SBteHrQSiaoc6sgyDkUqW0HiaNtiag/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。\n\n### 4.Server Push\nHTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为\"服务器推送\"（ Server Push，也叫 Cache push）\n\n例如下图所示,服务端主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87JHJE3JodhOxOwkRzE5J229oJfaGDE1J6wkqhz8GK8h3VRdsHovSOtQ/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n另外需要补充的是,服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。\n\n## 五、提高安全性\n出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。\n\n但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，所以“事实上”的HTTP/2是加密的。也就是说，互联网上通常所能见到的HTTP/2都是使用\"https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2\"表示加密的HTTP/2，“h2c”表示明文的HTTP/2。\n\n\n## 六、HTTP/3 新特性\n1.HTTP/2 的缺点\n虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，**主要是底层支撑的 TCP 协议造成的**。HTTP/2的缺点主要有以下几点：\n\n- TCP 以及 TCP+TLS建立连接的延时\n\nHTTP/2都是使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，**这样就需要有两个握手延迟过程**：\n\n①在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。\n\n②进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT。\n\n总之，在传输数据之前，我们需要花掉 3～4 个 RTT。\n\n- TCP的队头阻塞并没有彻底解决\n\n上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm8757xskRXjrFMvorOX7nrgHoSCpwCO3ib3snD0A9sPEPrxiaeYgSrCUyxQ/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n读到这里，可能就会有人考虑为什么不直接去修改 TCP 协议？其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。\n\n### 2.HTTP/3简介\nGoogle 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87wR2CP66VEj2naiaeTG1glYCJIa7S74tWhjkzAL65FiaYeJHeC9vggkNw/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\nQUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。不过HTTP/3目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。\n\n### 3.QUIC新功能\n上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流\"是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：\n\n- 实现了类似TCP的流量控制、传输可靠性的功能。\n\n虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。\n\n- 实现了快速握手功能。\n\n由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。**0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势**。\n\n- 集成了TLS加密功能。\n\n目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。\n\n- 多路复用，彻底解决TCP中队头阻塞的问题\n\n和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。\n\n![image](https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPJcceCMInZpsVErpdiaXm87dbOJ1DviaxJZrqUjyw86H8J6NjTEJbuWHyxzbYxXQjngBxHI72LIBJA/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n## 七、总结\n- HTTP/1.1有两个主要的缺点：安全不足和性能不高。\n\n- HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS\"，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；\n\n- QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。\n\n**本文章转载自公众号前端工匠**","like_users":[],"create_time":{"$date":"2019-11-02T14:25:02.184Z"},"update_time":{"$date":"2019-11-02T14:25:02.184Z"},"id":19,"__v":0}
{"_id":{"$oid":"5dc03eca0459c20030b9ed72"},"meta":{"views":17,"likes":0,"comments":0},"keyword":["前端性能优化"],"desc":"前端性能优化","numbers":"12420","img_url":"http://img.golderbrother.cn/youhua.jpg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5dc038b50459c20030b9ed71"}],"comments":[],"category":[{"$oid":"5dc038ad0459c20030b9ed70"}],"title":"你必须懂的前端性能优化","author":"golderBrother","content":"## 从输入URL加载起看方向\n从输入 URL 到页面加载完成的过程：\n\n1.首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来\n2.接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n3.TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据\n4.数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件\n5.首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错\n6.浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件\n文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。\n7.初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件\n8.CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西\n9.在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了\n\n我们从输入 URL 到显示页面这个过程中，涉及到网络层面的，有三个主要过程：\n\n- DNS 解析\n- TCP 连接\n- HTTP 请求/响应\n对于 DNS 解析和 TCP 连接两个步骤，我们前端可以做的努力非常有限。相比之下，HTTP 连接这一层面的优化才是我们网络优化的核心。\n\nHTTP 优化有两个大的方向：\n\n- 减少请求次数\n- 减少单次请求所花费的时间\n\n## 浏览器缓存策略\n浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：\n\n- Memory Cache\n- Service Worker Cache\n- HTTP Cache\n- Push Cache\n\n### MemoryCache\nMemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。浏览器秉承的是“节约原则”，我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。\n\n### Service Worker Cache\nService Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。\n\n### HTTP Cache\n它又分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。\n\n对一条http get 报文的基本缓存处理过程包括7个步骤：\n\n1.接收\n2.解析\n3.查询，缓存查看是否有本地副本可用，如果没有，就获取一份副本\n4.新鲜度检测， 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。\n5.创建响应，缓存会用新的首部和已缓存的主体来构建一条响应报文。\n6.发送，缓存通过网络将响应发回给客服端。\n7.日志\n\n![cache](http://blog.zhangbing.club/images/201907/7.png)\n\n### 强缓存\n强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。\n\n是否足够新鲜时期：\n通过 Expires: XXXX XXX XXX GMT （绝对日期时间，http/1.0） 或者 Cache-Control:max-age=XXXX （相对日期时间，http/1.1）在文档标明过期日期。\n\nCache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。\n\n### 关键字理解\n```public``` 与``` private ```是针对资源是否能够被代理服务缓存而存在的一组对立概念。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了``` private```，则该资源只能被浏览器缓存。private 为默认值。\n\n```no-store```与```no-cache```，```no-cache ```绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。\n\n### 协商缓存\n协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。\n\n协商缓存的实现：从``` Last-Modified ```到``` Etag```，详细自己百度，这里不再详细展开。\n\n### HTTP 缓存决策\n\n![cache-policy](http://blog.zhangbing.club/images/201907/66.jpg)\n当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。\n\n### Push Cache\n- Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。\n- Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。\n- Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。\n不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。\n\n### CDN了解一番\n\nCDN 的核心点有两个，一个是缓存，一个是回源。\n\n“缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。\n\nCDN 往往被用来存放静态资源。所谓“静态资源”，就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。而“动态资源”，顾名思义是需要后端实时动态生成的资源，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。\n\n那“非纯静态资源”呢？它是指需要服务器在页面之外作额外计算的 HTML 页面。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它和业务服务器的操作耦合，我们把它丢到CDN 上显然是不合适的。\n\n另外，CDN的域名必须和主业务服务器的域名不一样，要不，同一个域名下面的Cookie各处跑，浪费了性能流量的开销，CDN域名放在不同的域名下，可以完美地避免了不必要的 Cookie 的出现！\n\n### 图片优化\n\n#### 二进制位数与色彩的关系\n\n在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。\n\n一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。\n\n#### 计算图片大小\n\n对于一张 100 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 1 * 4 / 1024）。\n\n但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。\n了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：\n\npng格式的图片是采用**RGBA**形式来存储图片的，也就是说一张png图片上显示的颜色种类越多，图片体积就越大，反之越小，所以对于一张**纯色**的图片，可以优先考虑用png格式来存储，这样会比jpg等其他格式的图片小点。\n\n- 减少像素点\n- 减少每个像素点能够显示的颜色\n\n#### 图片类型要点\n** JPEG/JPG **特点：有损压缩、体积小、加载快、不支持透明,JPG 最大的特点是有损压缩。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。但当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。\n\n** PNG **特点：无损压缩、质量高、体积大、支持透明，PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。8 和 24，这里都是二进制数的位数。按照我们前置知识里提到的对应关系，8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是体积太大。\n\n** SVG **特点：文本文件、体积小、不失真、兼容性好，SVG（可缩放矢量图形）是一种基于``` XML ```语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。\n\n** Base64 **特点：文本文件、依赖编码、小图标解决方案，Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。\n\n** WebP **特点：年轻的全能型选手，WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。但是毕竟年轻，兼容性存在一些问题。\n\n### 渲染优化\n\n#### 客户端渲染\n\n在客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。页面上呈现的内容，你在 html 源文件里里找不到——这正是它的特点。\n\n#### 服务端渲染\n\n在服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成HTML字符串，然后把它返回给客户端。页面上呈现的内容，我们在 html 源文件里也能找到。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢，也解决了SEO搜索引擎的问题。\n\n#### 浏览器渲染过程解析\n\n-浏览器的渲染机制一般分为以下几个步骤：\n\n- 处理 HTML 并构建 DOM 树。\n\n- 处理 CSS 构建 CSSOM 树\n\n- 将 DOM 与 CSSOM 合并（附着：Attachment）成一个渲染树。\n\n- 根据渲染树来**布局**，计算每个节点的位置。\n\n- 调用**GPU 绘制**，合成图层，显示在屏幕上。\n\n在渲染DOM的时候，浏览器所做的工作实际上是：\n\n- 获取DOM后分割为多个图层\n\n- 对每个图层的节点**计算样式结果**（Recalculate style–样式重计算）\n\n- 为每个节点**生成图形和位置**（Layout–回流和重布局）\n\n- 将每个节点**绘制**填充到图层位图中（Paint Setup和RePaint–重绘）\n\n- 图层作为纹理上传至**GPU**\n\n- 复合多个图层到**页面上生成**最终屏幕图像（Composite Layers–图层重组）\n\n基于渲染流程的CSS优化建议\n\nCSS 选择符是从右到左进行匹配的，比如``` #myList li {}```实际开销相当高。\n\n- 避免使用通配符，只对需要用到的元素进行选择。\n\n- 关注可以通过继承实现的属性，避免重复匹配重复定义。\n\n- 少用标签选择器。如果可以，用类选择器替代。错误：```#dataList li{} 正确：.dataList{}```\n\n- 不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。错误：```.dataList#title 正确：#title```\n\n- 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高**不要超过三层**），尽可能使用类来关联每一个标签元素。\n\n#### CSS的阻塞\n\nCSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK，所以说css也是会阻塞页面的构建的。因此我们将 CSS 放在 head 标签里 和尽快 启用 CDN 实现静态资源加载速度的优化。\n\n#### JS的阻塞\n\nJS 引擎是独立于渲染引擎存在的。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。\n\n这边还有script执行的两种情况：\n如果遇到 script 标签的话，会判断是否存在``` async ```或者``` defer ```，前者(async)会并行进行下载并执行 JS，后者(defer)会先下载文件，然后等待 HTML 解析完成后顺序执行\n\n#### DOM渲染优化\n\n**先了解回流和重绘**\n\n回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如获取或者修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。\n\n重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。\n\n重绘不一定导致回流，但是回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。\n\n**例子剖析**\n```\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e\n  \u003ctitle\u003eDOM操作测试\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003cdiv id=\"container\"\u003e\u003c/div\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\nfor(var count=0;count\u003c10000;count++){ \n  document.getElementById('container').innerHTML+='\u003cspan\u003e我是一个小测试\u003c/span\u003e'  //我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，额外开销\n} \n```\n\n进化一：\n\n```\n// 只获取一次container\nlet container = document.getElementById('container')\nfor(let count=0;count\u003c10000;count++){ \n  container.innerHTML += '\u003cspan\u003e我是一个小测试\u003c/span\u003e'\n} \n```\n\n进化二：\n\n```\n//减少不必要的DOM更改\nlet container = document.getElementById('container')\nlet content = ''\nfor(let count=0;count\u003c10000;count++){ \n  // 先对内容进行操作\n  content += '\u003cspan\u003e我是一个小测试\u003c/span\u003e'\n} \n// 内容处理好了,最后再触发DOM的更改\ncontainer.innerHTML = content\n```\n\n事实上，考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。\n\n在 DOM Fragment 中，DocumentFragment 接口表示一个没有父级文件的最小文档对象（文档片段）。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（回流 reflow），且不会导致性能等问题。\n\n进化三：\n\n```\nlet container = document.getElementById('container')\n// 创建一个DOM Fragment对象（文档片段）作为容器\nlet content = document.createDocumentFragment()\nfor(let count=0;count\u003c10000;count++){\n  // span此时可以通过DOM API去创建\n  let oSpan = document.createElement(\"span\")\n  oSpan.innerHTML = '我是一个小测试'\n  // 像操作真实DOM一样操作DOM Fragment对象\n  content.appendChild(oSpan)\n}\n// 内容处理好了,最后再触发真实DOM的更改\ncontainer.appendChild(content)\n```\n\n进化四：\n\n当涉及到过万调数据进行渲染，而且要求不卡住画面，如何解决？\n如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过``` requestAnimationFrame ```来每 16 ms 刷新一次。\n\n```\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n  \u003chead\u003e\n    \u003cmeta charset=\"UTF-8\" /\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e\n    \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /\u003e\n    \u003ctitle\u003eDocument\u003c/title\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cul\u003e\n      控件\n    \u003c/ul\u003e\n    \u003cscript\u003e\n      setTimeout(() =\u003e {\n        // 插入十万条数据\n        const total = 100000\n        // 一次插入 20 条，如果觉得性能不好就减少\n        const once = 20\n        // 渲染数据总共需要几次\n        const loopCount = total / once\n        let countOfRender = 0\n        let ul = document.querySelector('ul')\n        function add() {\n          // 优化性能，插入不会造成回流\n          const fragment = document.createDocumentFragment()\n          for (let i = 0; i \u003c once; i++) {\n            const li = document.createElement('li')\n            li.innerText = Math.floor(Math.random() * total)\n            fragment.appendChild(li)\n          }\n          ul.appendChild(fragment)\n          countOfRender += 1\n          loop()\n        }\n        function loop() {\n          if (countOfRender \u003c loopCount) {\n            window.requestAnimationFrame(add)\n          }\n        }\n        loop()\n      }, 0)\n    \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e\n```\n\nwindow.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。\n注意：若您想要在下次重绘时产生另一个动画画面，您的回调例程必须调用 \nrequestAnimationFrame()。\n\n### Event Loop（事件循环）\n\n我们先了解javascript运行机制，对渲染是大有帮助的。\n\n事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。\n\n常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。\n常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。\n\n例子分析：\n```\n// task是一个用于修改DOM的回调\nsetTimeout(task, 0)\n```\n\n上面代码，现在 task 被推入的 macro 队列。但因为 script 脚本本身是一个 macro 任务，所以本次执行完 script 脚本之后，下一个步骤就要去处理 micro 队列了，再往下就去执行了一次 render,必须等待下一次的loop。\n\n```\nPromise.resolve().then(task)\n```\n\n上面代码，我们结束了对 script 脚本的执行，是不是紧接着就去处理 micro-task 队列了？micro-task 处理完，DOM 修改好了，紧接着就可以走 render 流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。\n\n- 上面说了重绘与回流，Event loop，但很多人不知道的是，重绘和回流其实和 Event loop 有关。\n\n- 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。\n\n- 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。\n\n- 判断是否触发了 media query\n\n- 更新动画并且发送事件\n\n- 判断是否有全屏操作事件\n\n- 执行``` requestAnimationFrame ```回调\n\n- 执行``` IntersectionObserver ```回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好\n\n- 更新界面\n\n- 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。\n\n### 节流与防抖\n\n当用户进行滚动，触发scroll事件，用户的每一次滚动都将触发我们的监听函数。函数执行是吃性能的，频繁地响应某个事件将造成大量不必要的页面计算。因此，我们需要针对那些有可能被频繁触发的事件作进一步地优化。节流与防抖就很有必要了！\n\n防抖与节流函数是一种最常用的 高频触发优化方式，能对性能有较大的帮助。\n\n- **防抖 (debounce):** 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。\n\n```\nfunction defounce(fn, wait = 300, immediate){\n    let timer = null;\n    return function(...args){\n        const context = this;\n        if(immediate \u0026\u0026 !timer) {\n            fn.apply(context, args)\n        }\n        if(timer) clearTimeout(timer)\n        timer = setTimeout(() =\u003e {\n            fn.apply(context, args)\n        }, wait)\n    }\n}\n```\n\n- **节流(throttle): **每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。\n```\nfunction throttle(fn, wait, immediate) {\n    let timer = null\n    let callNow = immediate\n    \n    return function() {\n        let context = this,\n            args = arguments\n\n        if (callNow) {\n            fn.apply(context, args)\n            callNow = false\n        }\n\n        if (!timer) {\n            timer = setTimeout(() =\u003e {\n                fn.apply(context, args)\n                timer = null\n            }, wait)\n        }\n    }\n}\n```\n","like_users":[],"create_time":{"$date":"2019-11-04T15:07:54.845Z"},"update_time":{"$date":"2019-11-04T15:07:54.845Z"},"id":20,"__v":0}
{"_id":{"$oid":"5dc6d67d00f3ab003065e3f9"},"meta":{"views":25,"likes":0,"comments":0},"keyword":["React 面试题"],"desc":"React 面试题","numbers":"15814","img_url":"http://img.golderbrother.cn/react-logo.svg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5cd447d79865305588453109"}],"comments":[],"category":[{"$oid":"5cd44852986530558845310a"}],"title":"35 道咱们必须要清楚的 React 面试题","author":"golderBrother","content":"## 35 道咱们必须要清楚的 React 面试题\n\n### 问题 1：什么是虚拟 DOM\n\n\u003e 主题: React\n\u003e 难度: ⭐\n\n**虚拟 DOM (VDOM)是真实 DOM 在内存中的表示。UI 的表示形式保存在内存中，并与实际的 DOM 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。**\n\n### 问题 2：类组件和函数组件之间的区别是啥？\n\n主题: React\n\n难度: ⭐⭐\n\n- **类组件**可以使用其他特性，如状态 state 和生命周期钩子。\n\n- 当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。\n\n函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。\n\n| 区别               | 函数组件 | 类组件 |\n| ------------------ | -------- | ------ |\n| 是否有 `this`      | 没有     | 有     |\n| 是否有生命周期     | 没有     | 有     |\n| 是否有状态 `state` | 没有     | 有     |\n\n### 问题 3：React 中 refs 干嘛用的？\n\n\u003e 主题: React\n\n\u003e 难度: ⭐⭐\n\n`Refs`提供了一种访问在`render`方法中创建的`DOM`节点或者`React`元素的方法。在典型的数据流中，`props`是父子组件交互的唯一方式，想要修改子组件，需要使用新的`prosp`重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用`Refs`。\n\n咱们可以在组件添加一个`ref`属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层`DOM`元素或组件的挂载实例。\n\n```js\nclass UnControlledForm extends Component {\n  handleSubmit = () =\u003e {\n    console.log(\"Input Value: \", this.input.value);\n  };\n  render() {\n    return (\n      \u003cform onSubmit={this.handleSubmit}\u003e\n        \u003cinput type=\"text\" ref={input =\u003e (this.input = input)} /\u003e\n        \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n      \u003c/form\u003e\n    );\n  }\n}\n```\n\n请注意，`input`元素有一个`ref`属性，它的值是一个函数。该函数接收输入的实际`DOM`元素，然后将其放在实例上，这样就可以在`handleSubmit`函数内部访问它。\n\n经常被误解的只有在类组件中才能使用`refs`，但是 refs 也可以通过利用`JS`中的闭包与函数组件一起使用。\n\n```js\nfunction CustomForm({ handleSubmit }) {\n  let inputElement;\n  return (\n    \u003cform onSubmit={() =\u003e handleSubmit(inputElement.value)}\u003e\n      \u003cinput type=\"text\" ref={input =\u003e (inputElement = input)} /\u003e\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n### 问题 4：在 React 中如何处理事件\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐\n\n为了解决跨浏览器的兼容性问题，`SyntheticEvent`实例将被传递给你的事件处理函数，`SyntheticEvent`是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括`stopPropagation()`和 `preventDefault()`。\n比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。\n\n### 问题 5：state 和 props 区别是啥？\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐\n\n`props`和`state`是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即\n\n- `state`是组件自己管理数据，控制自己的状态，可变；\n- `props`是外部传入的数据参数，不可变；\n- 没有`state`的叫做无状态组件，有 state 的叫做有状态组件；\n- 多用`props`，少用`state`，也就是多写无状态组件。\n\n### 问题 6：如何创建 refs\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐\n\nRefs 是使用 `React.createRef()` 创建的，并通过 `ref` 属性附加到 React 元素上。在构造组件时，通常将 `Refs` 分配给实例属性，以便可以在整个组件中引用它们。\n\n```js\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n  render() {\n    return \u003cdiv ref={this.myRef} /\u003e;\n  }\n}\n```\n\n或者这样用：\n\n\u003e 使用回调函数的形式\n\n```js\nclass UserForm extends Component {\n  handleSubmit = () =\u003e {\n    console.log(\"Input Value is: \", this.input.value);\n  };\n  render() {\n    return (\n      \u003cform onSubmit={this.handleSubmit}\u003e\n        \u003cinput type=\"text\" ref={input =\u003e (this.input = input)} /\u003e // Access DOM\n        input in handle submit\n        \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\n      \u003c/form\u003e\n    );\n  }\n}\n```\n\n### 问题 7：什么是高阶组件\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐\n\n**高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件**，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。\n\n```js\n// 元组件：WrappedComponent EnhancedComponent：增强后的组件\nconst EnhancedComponent = higherOrderComponent(WrappedComponent);\n```\n\nHOC 可以用于以下许多用例\n\n- 代码重用、逻辑和引导抽象\n- 渲染劫持\n- state 抽象和操作\n- props 处理\n\n### 问题 8：在构造函数调用 super 并将 props 作为参数传入的作用是啥\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐\n\n在调用 `super()` 方法之前，子类构造函数无法使用`this`引用，ES6 子类也是如此。将 `props` 参数传递给 `super()` 调用的主要原因是在子构造函数中能够通过`this.props`来获取传入的 `props`。\n\n#### 传递 props\n\n```js\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    console.log(this.props); // { name: 'sudheer',age: 30 }\n  }\n}\n```\n\n#### 没传递 props\n\n```js\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super();\n    console.log(this.props); // undefined\n    // 但是 Props 参数仍然可用\n    console.log(props); // Prints { name: 'sudheer',age: 30 }\n  }\n\n  render() {\n    // 构造函数外部不受影响\n    console.log(this.props); // { name: 'sudheer',age: 30 }\n  }\n}\n```\n\n\u003e 上面示例揭示了一点。`props` 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。\n\n### 问题 9：什么是控制组件\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n在 HTML 中，表单元素如 ·`\u003cinput\u003e、\u003ctextarea\u003e和\u003cselect\u003e`通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。\n\n而 React 的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数(例如`onChange`)触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为**受控组件**。\n\n### 问题 10：如何 React.createElement\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n#### 问题\n\n```js\nconst element = \u003ch1 className=\"greeting\"\u003eHello, world!\u003c/h1\u003e;\n```\n\n上述代码如何使用 `React.createElement` 来实现:\n\n```js\nconst element = React.createElement(\n  \"h1\",\n  {\n    className: \"greeting\"\n  },\n  \"Hello, world!\"\n);\n```\n\n### 问题 11：讲讲什么是 JSX\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n当 `Facebook` 第一次发布 React 时，他们还引入了一种新的 JS 方言 `JSX`，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用`Babel`和`webpack`等工具将其转换为传统的 JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一起了。\n\n```js\nclass MyComponent extends React.Component {\n  render() {\n    let props = this.props;\n    return (\n      \u003cdiv className=\"my-component\"\u003e\n        \u003ca href={props.url}\u003e{props.name}\u003c/a\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n```\n\n### 问题 12：根据下面定义的代码，可以找出存在的两个问题吗\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n请看下面的代码：\n\n![image](http://img.golderbrother.cn/react-interview.png)\n\n答案：\n\n1.在构造函数没有将 `props` 传递给 `super`，准确点说是没有调用`super`函数来**初始化父类**, 它应该包括以下行\n\n```js\nconstructor(props) {\n  super(props);\n  // ...\n}\n```\n\n2.事件监听器(通过`addEventListener()`分配时)的作用域不正确，因为 ES6 不提供自动绑定。因此，开发人员可以在构造函数中重新分配`clickHandler`来包含正确的绑定:\n\n```js\nconstructor(props) {\n  super(props);\n  this.clickHandler = this.clickHandler.bind(this);\n  // ...\n}\n```\n\n### 问题 13：为什么不直接更新 state 呢\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n如果试图直接更新 `state` ，则不会重新渲染组件\n\n\u003e 如果我们了解 setState 的原理的话，可能就能解答这个问题了，`setState` 做的事情不仅仅只是修改了 this.state 的\u003e 值，另外最重要的是它会触发 `React 的更新机制`，会进行 `diff` ，然后将`patch部分`更新到`真实dom`里。\n\n```js\n// 错误\nThis.state.message = \"Hello world\";\n```\n\n需要使用`setState()`方法来更新 `state`。它调度对组件`state`对象的更新。当`state`改变时，组件通过重新渲染来响应：\n\n```js\n// 正确做法\nThis.setState({message: ‘Hello World’});\n```\n\n### 问题 14：React 组件生命周期有哪些不同阶段\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n在组件生命周期中有四个不同的阶段：\n\n1. Initialization：在这个阶段，组件准备设置初始化状态和默认属性。\n\n2. Mounting：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括`componentWillMount`和`componentDidMount`生命周期方法。\n\n3. Updating：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括`shouldComponentUpdate`、`componentWillUpdate`和`componentDidUpdate`生命周期方法。\n\n4. Unmounting：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 `componentWillUnmount` 生命周期方法。\n\n除以上四个常用生命周期外，还有一个错误处理的阶段：\n\n**Error Handling**：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 `componentDidCatch` 生命周期方法。\n\n![image](http://img.golderbrother.cn/react-lifecycle.png)\n\n### 问题 15：React 的生命周期方法有哪些\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n- `componentWillMount`:在渲染之前执行，用于根组件中的 App 级配置。\n\n- `componentDidMount`：在第一次渲染之后执行，可以在这里做 AJAX 请求，DOM 的操作或状态更新以及设置事件监听器。\n\n- `componentWillReceiveProps`：在初始化 render 的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染\n\n- `shouldComponentUpdate`：确定是否更新组件。默认情况下，它返回`true`。如果确定在 `state` 或 `props` 更新后组件不需要在重新渲染，则可以返回 false，这是一个提高性能的方法。\n\n- `componentWillUpdate`：在`shouldComponentUpdate`返回 `true` 确定要更新组件之前件之前执行。\n\n- `componentDidUpdate`：它主要用于更新 DOM 以响应`props`或 `state`更改。\n\n- `componentWillUnmount`：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。\n\n### 问题 16：这三个点(...)在 React 干嘛用的\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n... 在 React（使用 JSX）代码中做什么？它叫什么？\n\n```js\n\u003cModal {...this.props} title=\"Modal heading\" animation={false} /\u003e\n```\n\n这个叫**扩展运算符**或者**展开操作符**,属于`ES2018`的语法，例如，如果`this.props`包含`a：1`和`b：2`，则\n\n```js\n\u003cModal {...this.props} title='Modal heading' animation={false}\u003e\n```\n\n等价于下面内容：\n\n```js\n\u003cModal a={this.props.a} b={this.props.b} title='Modal heading' animation={false}\u003e\n```\n\n扩展符号不仅适用于该用例，而且对于创建具有现有对象的大多数（或全部）属性的新对象非常方便，在更新`state` 咱们就经常这么做：\n\n```js\nthis.setState(prevState =\u003e {\n  return { foo: { ...prevState.foo, a: \"updated\" } };\n});\n```\n\n### 问题 17：使用 React Hooks 好处是啥\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。\n\nHooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount`。相反，使用像 useEffect 这样的内置钩子。\n\n代码如下：\n\n```js\nuseEffect(() =\u003e {\n  // update xxx =\u003e componentDidUpdate:每次state或者props更新后都会执行一次（默认会先执行上次return函数(也就是下面的函数)里面的逻辑，然后再执行这里面的逻辑）\n  return () =\u003e {\n    // remove listener xxx =\u003e componentWillUnmount:在挂载后执行一次\n  };\n}, []); // =\u003e componentDidMount 在挂在后执行一次\n```\n\n### 问题 18：什么是 React Hooks？\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n**Hooks**是 React 16.8 中的新添加内容。它们允许在不编写类的情况下使用`state`和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。\n\n### 问题 19：React 中的 useState() 是什么？\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n下面说明 useState(0)的用途：\n\n```js\nconst [count, setCounter] = useState(0);\nconst [moreStuff, setMoreStuff] = useState(...);\n\n\nconst setCount = () =\u003e {\n    setCounter(count + 1);\n    setMoreStuff(...);\n    ...\n};\n```\n\n`useState` 是一个内置的 React Hook。`useState(0)` 返回一个元组，其中第一个参数`count`是计数器的当前状态，`setCounter` 提供更新计数器状态的方法。\n\n咱们可以在任何地方使用`setCounter`方法更新计数状态-在这种情况下，咱们在 setCount 函数内部使用它可以做更多的事情，使用 `Hooks`，能够使咱们的代码保持更多功能,并购且更加简洁易读，还可以避免过多使用基于类的组件。\n\n### 问题 20：React 中的 StrictMode(严格模式)是什么？？\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\nReact 的`StrictMode`是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用`\u003cStrictMode /\u003e`包装一组组件，并且可以帮咱们以下检查：\n\n- 验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。\n\n- 验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。\n\n- 通过识别潜在的风险预防一些副作用。\n\n### 问题 21：为什么类方法需要绑定到类实例\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n在 JS 中，this 值会根据当前上下文变化。因为在 react 内部处理事件的特殊性。\n\n简单的理解 react 如何处理事件的，React 在组件加载(`mount`)和更新(`update`)时，将事件通过`addEventListener`统一注册到 `document`上，然后会有一个**事件池**存储了所有的事件，当事件触发的时候，通过`dispatchEvent`进行事件分发。\n\n所以你可以简单的理解为，最终`this.handleClick`会作为一个**回调函数**调用。\n\n**如何解决**\n在 React 类组件方法中，开发人员通常希望 this 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:\n\n以下展示了四种方法：\n\n```js\nclass SubmitButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isFormSubmitted: false\n    };\n    // 2. constuctor 手动 bind 型\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit() {\n    this.setState({\n      isFormSubmitted: true\n    });\n  }\n\n  // 4. 方法定义成箭头函数型(推荐!)\n  /* handleSubmit = () =\u003e {\n    this.setState({\n      isFormSubmitted: true\n    });\n  } */\n\n  render() {\n    return (\n      // 1. 直接 bind this 型\n      // \u003cbutton onClick={this.handleSubmit.bind(this)}\u003eSubmit\u003c/button\u003e\n      // 3. 内部直接绑定箭头函数型\n      // \u003cbutton onClick={() =\u003e this.handleSubmit()}\u003eSubmit\u003c/button\u003e\n      \u003cbutton onClick={this.handleSubmit}\u003eSubmit\u003c/button\u003e\n    );\n  }\n}\n```\n\n### 问题 22：什么是 prop drilling，如何避免\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 prop 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做 prop drilling。\n\n`prop drilling`的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。\n\n为了避免`prop drilling`，一种常用的方法是使用**React Context**。通过定义提供数据的`Provider`组件，并允许嵌套的组件通过`Consumer`组件或`useContext` Hook 使用上下文数据。\n\n### 问题 23：描述 Flux 与 MVC\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n传统的 MVC 模式在分离数据(Model)、UI(View 和逻辑(Controller)方面工作得很好，但是 MVC 架构经常遇到两个主要问题:\n\n**数据流不够清晰**:跨视图发生的级联更新常常会导致混乱的事件网络，难于调试。\n\n**缺乏数据完整性**:模型数据可以在任何地方发生突变，从而在整个 UI 中产生不可预测的结果。\n\n使用 Flux 模式的复杂用户界面不再遭受级联更新，任何给定的 React 组件都能够根据 store 提供的数据重建其状态。Flux 模式还通过限制对共享数据的直接访问来加强数据完整性。\n\n### 问题 24：受控组件和非受控组件区别是啥\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐\n\n- **受控组件**是 React 控制中的组件，并且是表单数据真实的唯一来源。\n- **非受控组件**是由 DOM 处理表单数据的地方，而不是在 React 组件中。\n\n尽管非受控组件通常更易于实现，因为只需使用`refs`即可从 DOM 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。\n这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用/启用按钮，强制输入格式。\n\n### 问题 25：这段代码有什么问题吗\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐\n\n这段代码有什么问题:\n\n```js\nthis.setState((prevState, props) =\u003e {\n  return {\n    streak: prevState.streak + props.count\n  };\n});\n```\n\n答案：\n没有什么问题。这种方式很少被使用，咱们可以将一个函数传递给`setState`，该函数接收上一个 `state` 的值和当前的`props`，并返回一个新的状态，如果咱们需要根据以前的状态重新设置状态，推荐使用这种方式，并且这种方式来更新状态，在**下一行**可以直接获取更新后的状态。\n\n### 问题 26：什么是 React Context\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐\n\n`Context` 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 `props` 属性。\n\n### 问题 27：什么是 React Fiber\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐\n\n**Fiber** 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟 DOM 的增量渲染。**React Fiber** 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。\n\nReact Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。\n\n### 问题 28：如何在 ReactJS 的 Props 上应用验证\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐\n\n当应用程序在开发模式下运行时，React 将自动检查咱们在组件上设置的所有 `props`，以确保它们具有正确的数据类型。对于不正确的类型，开发模式下会在控制台中生成警告消息，而在生产模式中由于性能影响而禁用它。强制的 `props` 用 `isRequired`定义的。\n\n下面是一组预定义的 prop 类型:\n\n- React.PropTypes.string\n- React.PropTypes.number\n- React.PropTypes.func\n- React.PropTypes.node\n- React.PropTypes.bool\n\n例如，咱们为用户组件定义了如下的`propTypes`\n\n```js\nimport PropTypes from 'prop-types';\n\nclass User extends React.Component {\n  render() {\n    return (\n      \u003ch1\u003eWelcome, {this.props.name}\u003c/h1\u003e\n      \u003ch2\u003eAge, {this.props.age}\n    );\n  }\n}\n\nUser.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number.isRequired\n};\n```\n\n### 问题 29：在 React 中使用构造函数和 getInitialState 有什么区别？\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐\n\n构造函数和`getInitialState`之间的区别就是`ES6`和`ES5`本身的区别。在使用 ES6 类时，应该在构造函数中初始化`state`，并在使用`React.createClass`时定义`getInitialState`方法。\n\n```js\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      /* initial state */\n    };\n  }\n}\n```\n\n等价于：\n\n```js\nvar MyComponent = React.createClass({\n  getInitialState() {\n    return {\n      /* initial state */\n    };\n  }\n});\n```\n\n### 问题 30：如何有条件地向 React 组件添加属性\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐\n\n对于某些属性，React 非常聪明，如果传递给它的值是虚值(假值)，会**省略**该属性。例如：\n\n```js\nvar InputComponent = React.createClass({\n  render: function() {\n    var required = true;\n    var disabled = false;\n\n    return \u003cinput type=\"text\" disabled={disabled} required={required} /\u003e;\n  }\n});\n```\n\n渲染结果：\n\n```js\n\u003cinput type=\"text\" required\u003e\n```\n\n另一种可能的方法是：\n\n```js\nvar condition = true;\n\nvar component = \u003cdiv value=\"foo\" {...(condition \u0026\u0026 { disabled: true })} /\u003e;\n```\n\n### 问题 31：Hooks 会取代 render props 和高阶组件吗\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐\n\n通常，`render props`和高阶组件仅渲染一个子组件。React 团队认为，Hooks 是服务此用例的更简单方法。\n\n这两种模式仍然有一席之地(例如，一个虚拟的 `scroller` 组件可能有一个 `renderItem prop`，或者一个可视化的容器组件可能有它自己的 DOM 结构)。但在大多数情况下，Hooks 就足够了，可以帮助减少树中的嵌套。\n\n### 问题 32：如何避免组件的重新渲染\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐\n\nReact 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：\n\n- `React.memo()`:这可以防止不必要地重新渲染函数组件\n\n- `PureComponent`:这可以防止不必要地重新渲染类组件\n\n这两种方法都依赖于对传递给组件的`props`的**浅比较**，如果 `props` 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。\n\n通过使用 **React Profiler**，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。\n\n### 问题 33：什么是纯函数\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐⭐\n\n纯函数是不依赖并且不会在其作用域之外修改变量状态的函数。本质上，纯函数始终在给定相同参数的情况下返回相同结果。也就是说，只要是同样的输入，必定得到同样的输出。\n\n纯函数是函数式编程的概念，必须遵守以下一些约束。\n\n- 不得改写参数\n- 不能调用系统 I/O 的 API\n- 不能调用 Date.now()或者 Math.random()等不纯的方法，因为每次会得到不一样的结果\n\n### 问题 34：当调用 setState 时，React render 是如何工作的？\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐⭐\n\n咱们可以将\"`render`\"分为两个步骤：\n\n- 虚拟 DOM 渲染:当`render`方法被调用时，它返回一个新的组件的虚拟 `DOM` 结构。当调用`setState()`时，`render`会被再次调用，因为默认情况下`shouldComponentUpdate`总是返回`true`，所以默认情况下 `React` 是没有优化的。\n\n- 原生 DOM 渲染:React 只会在虚拟 DOM 中修改真实 DOM 节点，而且修改的次数非常少——这是很棒的 React 特性，它优化了真实 DOM 的变化，使 React 变得更快。\n\n### 问题 35：如何避免在 React 重新绑定实例\n\n\u003e 主题: React\n\u003e 难度: ⭐⭐⭐⭐⭐\n\n有几种常用方法可以避免在 React 中绑定方法：\n\n1.将事件处理程序定义为内联箭头函数\n\n```js\nclass SubmitButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      isFormSubmitted: false\n    };\n  }\n\n  render() {\n    return (\n      \u003cbutton\n        onClick={() =\u003e {\n          this.setState({ isFormSubmitted: true });\n        }}\n      \u003e\n        Submit\n      \u003c/button\u003e\n    );\n  }\n}\n```\n\n2.使用箭头函数来定义方法(**推荐**)：\n\n```js\nclass SubmitButton extends React.Component {\n  state = {\n    isFormSubmitted: false\n  };\n\n  handleSubmit = () =\u003e {\n    this.setState({\n      isFormSubmitted: true\n    });\n  };\n\n  render() {\n    return \u003cbutton onClick={this.handleSubmit}\u003eSubmit\u003c/button\u003e;\n  }\n}\n```\n\n3.使用带有 Hooks 的函数组件\n\n```js\nconst SubmitButton = () =\u003e {\n  const [isFormSubmitted, setIsFormSubmitted] = useState(false);\n\n  return (\n    \u003cbutton onClick={() =\u003e {\n        setIsFormSubmitted(true);\n    }}\u003eSubmit\u003c/button\u003e\n  )\n};\n```\n\n**代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具** [Fundebug](https://www.fundebug.com/?utm_source=xiaozhi)\n\n### 总结\n\n[小菜鸡的github](https://github.com/GolderBrother), 觉得这篇文章不多的可以给个 [star](https://github.com/GolderBrother)","like_users":[],"create_time":{"$date":"2019-11-09T15:08:45.192Z"},"update_time":{"$date":"2019-11-09T15:08:45.192Z"},"id":21,"__v":0}
{"_id":{"$oid":"5dca6d9a00f3ab003065e3fc"},"meta":{"views":11,"likes":0,"comments":0},"keyword":["JS模块化规范"],"desc":"JS模块化规范总结","numbers":"4019","img_url":"http://img.golderbrother.cn/module.jpg","type":1,"state":1,"origin":0,"tags":[{"$oid":"5dca62b000f3ab003065e3fa"}],"comments":[],"category":[{"$oid":"5dca62b600f3ab003065e3fb"}],"title":"JS模块化规范总结","author":"golderBrother","content":"### 简介\n\n\u003e 规范JavaScript的模块定义和加载机制,降低了学习和使用各种框架的门槛，能够以一种统一的方式去定义和使用模块，提高开发效率，降低了应用维护成本。\n\u003e 模块化解决的问题：\n\u003e\n\u003e - 命名冲突\n\u003e - 文件依赖\n\n### commonJS\n\n1. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\n2. 模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行——同步加载。\n\n**适用场景**：服务器环境，nodejs的模块规范是参照commonJS实现的。\n\n#### 用法：\n\n1、导入：```require('路径')```\n2、导出：```module.exports和exports```\n\n```js\n// a.js\n// 相当于这里还有一行：var exports = module.exports;代码\nexports.a = 'Hello world';  // 相当于：module.exports.a = 'Hello world';\n\n// b.js\nvar moduleA = require('./a.js');\nconsole.log(moduleA.a);     // 打印出hello world\n```\n\n注意：module.exports和exports的区别是exports只是对module.exports的一个引用，相当于Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行```js var exports = module.exports;```这样的命令。\n\n### AMD\n\n1、异步加载\n2、管理模块之间的依赖性，便于代码的编写和维护。\n\n**适用场景**：浏览器环境，**requireJS**是参照AMD规范实现的\n\n#### 用法：\n1、导入：```require(['模块名称'], function ('模块变量引用'){// 代码})```;\n2、导出：```define(function (){return '值')```;\n\n```js\n// a.js\ndefine(function (){\n　　return {\n　　　a:'hello world'\n　　}\n});\n// b.js\nrequire(['./a.js'], function (moduleA){\n    console.log(moduleA.a); // 打印出：hello world\n});\n```\n\n### CMD\n1、CMD是在AMD基础上改进的一种规范，和AMD不同在于对依赖模块的执行时机处理不同，CMD是**依赖就近**，而AMD是**依赖前置**。\n\n**适用场景**：浏览器环境，**seajs**是参照CMD规范实现的，**requireJS**的**最新**的几个版本也是部分参照了CMD规范的实现。\n\n用法：\n\n1、导入：```define(function(require, exports, module) {})```;\n2、导出：```define(function (){return '值')```;\n\n```js\n// a.js\ndefine(function (require, exports, module){\n　　exports.a = 'hello world';\n});\n// b.js\ndefine(function (require, exports, module){\n    var moduleA = require('./a.js');\n    console.log(moduleA.a); // 打印出：hello world\n});\n```\n\n### AMD与CMD区别\n最明显的区别就是在模块定义时对依赖的处理不同\n\n1. AMD推崇**依赖前置**，在定义模块的时候就要声明其依赖的模块\n2. CMD推崇**依赖就近**，只有在用到某个模块的时候再去require\n\nAMD和CMD最大的区别是**对依赖模块的执行时机处理不同**\n\n很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用时把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略\n\n为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）\n\n同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，这个类似加载script的属性 **async**, ，**所有模块都加载并执行完后**会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行\n\nCMD加载完某个依赖模块后并不执行，只是**下载**而已，这个类似加载script的属性 **defer**, 在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的\n\n这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因\n\n### UMD\n\n1、兼容AMD和commonJS规范的同时，还兼容全局引用的方式。\n\n**适用场景**：浏览器或服务器环境\n\n**用法**：\n\n无导入导出规范，只有如下的一个常规写法：\n\n```js\n(function (root, factory) {\n    if (typeof define === 'function' \u0026\u0026 define.amd) {\n        //AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        //Node, CommonJS之类的\n        module.exports = factory(require('jquery'));\n    } else {\n        //浏览器全局变量(root 即 window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //方法\n    function myFunc(){};\n    //暴露公共方法\n    return myFunc;\n}));\n```\n\n### ESM(ES6 Module)\n\n1、按需加载（编译时加载）\n2、import和export命令只能在模块的顶层，不能在代码块之中（如：if语句中）,import()语句可以在代码块中实现异步动态按需动态加载\n\n**适用场景**：浏览器或服务器环境（以后可能支持）\n\n**用法**：\n\n1、导入：```import {模块名A，模块名B…} from '模块路径'```\n2、导出：```export和export default```\n3、```import('模块路径').then()方法```\n\n```js\n/*错误的写法*/\n// 写法一\nexport 1;\n\n// 写法二\nvar m = 1;\nexport m;\n\n// 写法三\nif (x === 2) {\n  import MyModual from './myModual';\n}\n\n/*正确的三种写法*/\n// 写法一(具名导出)\nexport var m = 1;\n\n// 写法二(按需具名导出)\nvar m = 1;\nexport {m};\n\n// 写法三(重命名导出)\nvar n = 1;\nexport {n as m};\n\n// 写法四(默认导出)\nvar n = 1;\nexport default n;\n\n// 写法五\nif (true) {\n    // es6草案，返回Promise，模块值在promise.then的参数中\n    import('./myModule.js')\n    .then(({export1, export2}) =\u003e {\n      // ...·\n    });\n}\n\n// 写法六\nPromise.all([\n  import('./module1.js'),\n  import('./module2.js'),\n  import('./module3.js'),\n])\n.then(([module1, module2, module3]) =\u003e {\n   ···\n});\n```\n\n注意：export只支持对象形式导出，不支持值的导出，export default命令用于指定模块的默认导出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做default的变量或方法，然后我们可以重命名后导入\n\n```js\n// aaa.js\nlet a = \"aaa\";\nexport default a\n```\n\n```js\n// bbb.js\nimport {default as aaa} from './aaa.js'\nconsole.log(aaa); // \"aaa\"\n```","like_users":[],"create_time":{"$date":"2019-11-12T08:30:18.138Z"},"update_time":{"$date":"2019-11-12T08:30:18.138Z"},"id":22,"__v":0}
{"_id":{"$oid":"5dd6007200f3ab003065e3ff"},"meta":{"views":15,"likes":0,"comments":0},"keyword":["前端开发应知网站"],"desc":"前端开发应知网站","numbers":"8019","img_url":"http://img.golderbrother.cn/front-logo.jfif","type":1,"state":1,"origin":1,"tags":[{"$oid":"5dd6004100f3ab003065e3fd"}],"comments":[],"category":[{"$oid":"5dd6004b00f3ab003065e3fe"}],"title":"前端开发应知网站(强烈推荐！)","author":"golderBrother","content":"# 前端开发应知网站(强烈推荐！)\n\n## 作为一名前端开发者（所有程序员）最起码遇到 bug 就算不会解决也应该会搜解决问题的答案\n\n一般笔者会先在百度搜（关键词一定要输入正确）\n\n1. 如果没搜到会再去 bing 里面看看\n2. 还没有的话就去 github 的 Issues 里面再看看\n3. 如果还不行就只能自己去看官方文档然后自己研究了。\n4. 建议学习一下这个搜索技巧。\n\n\u003e 搜索技巧：\u003chttps://blog.csdn.net/weixin_43606158/article/details/100531733\u003e\n\n### 只是知道搜解决问题的方法这是最基础的，遇到问题才会去想办法解决，而作为一名积极进取的程序员应该随时跟着时代的潮流走，不断的拓展自己的知识面，这样你会发现你遇到问题的时候大部分情况你都能准确定位问题的原因，在哪里去搜解决方案，或者你早就自学过了，分分钟解决。\n\n---\n\n### 接下来笔者与大家分享一下我个人积累的网站\n\n- MDN 开发者文档：\u003chttps://developer.mozilla.org/zh-CN/\u003e\n- 菜鸟教程：\u003chttps://www.runoob.com/\u003e\n- W3CSchool：\u003chttp://www.w3school.com.cn/\u003e\n- JavaScript 教程网：\u003chttps://zh.javascript.info/\u003e\n- 一行代码搞定 bug 监控：\u003chttps://www.fundebug.com/?tdsourcetag=s_pcqq_aiomsg\u003e\n- web 开发人员必备工具包（实现快速敲代码）:\u003chttps://docs.emmet.io/\u003e\n- 让代码提交的时候先执行一次代码，如果有报错不让提交：\u003chttps://www.npmjs.com/package/eslint-config-airbnb\u003e\n- 阿里巴巴图标库：\u003chttps://www.iconfont.cn/\u003e\n- UI 颜色布料：\u003chttps://www.materialui.co/colors\u003e\n- UI 必备颜色表（色块+色码）:\u003chttps://blog.csdn.net/weixin_43606158/article/details/97569176\u003e\n- logo 在线制作，有很多：\u003chttp://www.logofree.cn/\u003e\n- 免费设计图，有很多：\u003chttps://www.chuangkit.com/designtools/designindex\u003e\n- 图片试别转换各种格式，有很多，只列举了一个:\u003chttps://zhcn.109876543210.com/\u003e\n- 在线开发工具：\u003chttps://tool.lu/c/developer\u003e\n- 在线编辑器：\u003chttps://codesandbox.io/\u003e\n- 在线做图【ProcessOn 支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图】：\u003chttps://www.processon.com/\u003e\n- 项目部署流程：\u003chttps://cloud.tencent.com/developer/information/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%AD%A5%E9%AA%A4\u003e\n- 网站 SEO： \u003chttp://www.jj3721.com/\u003e\n- 验证正则表达式的可视化工具：\u003chttps://regexper.com/\u003e\n- 开源、免费、企业级 CMS 系统：\u003chttps://www.siteserver.cn/\u003e\n- 前端开发必备 JS 功能函数总结（上）：\u003chttps://blog.csdn.net/weixin_43606158/article/details/94590474\u003e\n- 前端开发必备 JS 功能函数总结（下）：\u003chttps://blog.csdn.net/weixin_43606158/article/details/94660402\u003e\n- 渐进式 web 应用程序核对表：\u003chttps://developers.google.cn/web/progressive-web-apps/checklist\u003e\n- 在线存放图片的地址：\u003chttps://sm.ms/\u003e\n- 代码变漂亮图片：\u003chttps://carbon.now.sh\u003e\n- MintUI：\u003chttps://mint-ui.github.io/#!/zh-cn\u003e\n- ElementUI：\u003chttps://element.eleme.cn/#/zh-CN\u003e\n- iViewUI：\u003chttps://www.iviewui.com/\u003e\n- Layui：\u003chttps://www.layui.com/\u003e\n- cubeUI：\u003chttps://didi.github.io/cube-ui/#/zh-CN\u003e\n- Antd：\u003chttps://ant.design/index-cn\u003e\n- MUI：\u003chttp://dev.dcloud.net.cn/mui/\u003e\n- Animate.CSS:\u003chttps://daneden.github.io/animate.css/\u003e\n- ECharts：\u003chttps://www.echartsjs.com/index.html\u003e\n- HighCharts：\u003chttps://www.highcharts.com.cn/\u003e\n- 富文本编辑器 wangEditor： \u003chttp://www.wangeditor.com/\u003e\n- 富文本编辑器 UEditor： \u003chttps://ueditor.baidu.com/website/onlinedemo.html\u003e\n- 蚂蚁数据可视化：\u003chttp://antv.alipay.com/zh-cn/index.html\u003e\n- 热力图插件：\u003chttps://www.patrick-wied.at/static/heatmapjs/\u003e\n- 视频监控直播的插件 VLC：\u003chttps://www.videolan.org/\u003e\n- 直播软件开发：\u003chttp://www.nodemedia.cn/\u003e\n- 网易云信：\u003chttps://netease.im/\u003e\n- 聊天开放软件：\u003chttps://www.oschina.net/p/keybase\u003e\n- 有道翻译 API：\u003chttp://fanyi.youdao.com/openapi?path=data-mode\u003e\n- 游戏开发：\u003chttp://phaser.io/\u003e\n- 力扣 JS 题库：\u003chttps://leetcode-cn.com/\u003e\n- 刷算法题:\u003chttps://www.lintcode.com/\u003e\n- ES6 入门（阮一峰大佬的）：\u003chttp://es6.ruanyifeng.com/\u003e\n- babel（将 ES6 代码转为 ES5 代码）：\u003chttps://babeljs.io/\u003e\n- 处理时间与日期的 JS 库：\u003chttp://momentjs.cn/\u003e\n- Lodash：\u003chttps://www.lodashjs.com/\u003e\n- 你可能不需要 jQuery：\u003chttp://youmightnotneedjquery.com/\u003e\n- 云小蜜智能机器人 API：\u003chttps://help.aliyun.com/product/59495.html?spm=a2c4g.11186623.3.1.7dad1b005dRM5F\u003e\n- 易万维源接口：\u003chttps://www.showapi.com/api/apiList\u003e\n- 短信验证码接口：\u003chttps://www.mysubmail.com/sms/api?tag=jq22\u003e\n- 榛子短信验证码接口： \u003chttp://smsow.zhenzikj.com/\u003e\n- 草料二维码生成器：\u003chttps://cli.im/\u003e\n- 二维码\n- RAP2 假数据接口：\u003chttp://rap2.taobao.org/\u003e\n- 可扒的真实电商数据：\u003chttp://www.xiongmaoyouxuan.com/#/\u003e\n- 易文档接口：\u003chttps://easydoc.xyz\u003e - - 感谢旅行呱大佬帮助我们丰富资源，他的 CSDN 主页为：https://me.csdn.net/atsoar\n- 免费接口：\u003chttp://www.bejson.com/knownjson/webInterface/\u003e\n- 假数据接口（测试用）：\u003chttp://jsonplaceholder.typicode.com/\u003e\n- 上传文件转进制的 formData: \u003chttps://developer.mozilla.org/zh-CN/docs/Web/API/FormData\u003e\n- jQuery 插件库：\u003chttp://www.jq22.com/search\u003e\n- 轮播图插件：\u003chttps://www.swiper.com.cn/\u003e\n- 放大镜插件：\u003chttp://www.elevateweb.co.uk/image-zoom/examples\u003e\n- 响应式瀑布流插件：\u003chttp://www.jq22.com/jquery-info20261\u003e\n- art-template 模板引擎：\u003chttps://aui.github.io/art-template/zh-cn/docs/\u003e\n- ejs 模板引擎：\u003chttps://ejs.bootcss.com/\u003e\n- 小表情的 emoji：\u003chttps://emojipedia.org/\u003e\n- Postman 测试前端请求后端接口：\u003chttps://www.getpostman.com/\u003e\n- coding 代码托管平台：\u003chttps://coding.net/\u003e\n- 码云代码托管平台：\u003chttps://gitee.com/\u003e\n- github 代码托管平台：\u003chttps://github.com/\u003e\n- SVN 代码托管平台：\u003chttps://svnbucket.com/?ADTAG=bdss#/\u003e\n- SVN 代码托管中心：\u003chttp://www.svnchina.com/\u003e\n- 禅道：\u003chttps://www.zentao.net/\u003e\n- 蓝湖（ps 切图）：\u003chttps://lanhuapp.com/\u003e\n- git 官网：\u003chttps://git-scm.com/\u003e\n- npm 官网：\u003chttps://www.npmjs.com/\u003e\n- npm 模块管理器介绍：\u003chttps://javascript.ruanyifeng.com/nodejs/npm.html#toc18\u003e\n- 码神岛： \u003chttps://msd.misuland.com/\u003e\n- 掘金网：\u003chttps://juejin.im/\u003e\n- 思否：\u003chttps://segmentfault.com/\u003e\n- 知乎：\u003chttps://www.zhihu.com\u003e\n- stack Overflow：\u003chttps://stackoverflow.com/\u003e\n- v2ex 社区：\u003chttps://www.v2ex.com/\u003e\n- CtoLib 码库： \u003chttps://www.ctolib.com\u003e\n- 牛客网：\u003chttps://www.nowcoder.com\u003e\n- FCC 中文网：https://www.freecodecamp.one/\n- Web 开发练习题：\u003chttps://www.freecodecamp.org/\u003e\n- 百度前端技术学院 — 前端开发项目库：\u003chttp://ife.baidu.com/\u003e\n- FCC 的 Medium 频道：\u003chttps://www.freecodecamp.org/news/\u003e\n- 阿里云：\u003chttps://www.aliyun.com\u003e\n- 腾讯云：\u003chttps://cloud.tencent.com/\u003e\n- GitBook：\u003chttps://legacy.gitbook.com/@llh911001\u003e\n- 妙味课堂：\u003chttps://miaov.com/\u003e\n- 慕课网：\u003chttps://www.imooc.com/\u003e\n- html 中文网：\u003chttps://www.html.cn/\u003e\n- hCoder：\u003chttp://www.hcoder.net/\u003e\n- 扣丁学堂：\u003chttp://www.codingke.com/\u003e\n- 开课吧： \u003chttps://www.kaikeba.com/\u003e\n- gitbook： \u003chttps://legacy.gitbook.com/\u003e\n- 各种语言的书：\u003chttps://www.laojiyou.com/[由于此网站里的书非正版，所以会提示有风险，请点击详细信息后继续访问即可看到内容（PS：此链接由\u003e JuJuBoyll 友情提供，此博主链接：\u003chttps://me.csdn.net/blog/JuJuBoyII）]\u003e\n- React 官网：\u003chttps://reactjs.org/\u003e\n- React 中文官网：\u003chttps://react.docschina.org/\u003e\n- Redux 官网：\u003chttps://react-redux.js.org/\u003e\n- React Router：\u003chttps://reacttraining.com/react-router/\u003e\n- React 源码解析：\u003chttps://react.jokcy.me/\u003e\n- React.js 小书：\u003chttp://huziketang.mangojuice.top/books/react/\u003e\n- Vue 官网：\u003chttps://cn.vuejs.org/\u003e\n- NodeJS 官网：\u003chttp://nodejs.cn/\u003e\n- React Native: \u003chttps://reactnative.cn/\u003e\n- uni-app：https://uniapp.dcloud.io/\n- Mui: \u003chttps://dev.dcloud.net.cn/mui/\u003e\n- Taro: \u003chttps://taro.aotu.io/?tdsourcetag=s_pcqq_aiomsg\u003e\n- 微信小程序开发者平台：\u003chttps://developers.weixin.qq.com/\u003e\n- 微信开发者平台： \u003chttps://open.weixin.qq.com/\u003e\n- 钉钉开发者平台: \u003chttps://ding-doc.dingtalk.com/\u003e\n- 百度地图开发者平台：\u003chttps://passport.baidu.com\u003e\n- UmiJS 中文官网：\u003chttps://umijs.org/zh/guide/\u003e\n- DvaJS：\u003chttps://dvajs.com/\u003e\n- jQuery 官网：\u003chttps://jquery.com/\u003e\n- jQuery API 中文文档【在线手册】：\u003chttp://jquery.cuishifeng.cn/\u003e\n- ZeptoJS 官网：\u003chttps://zeptojs.com/\u003e\n- cheerioJS 安装地址：\u003chttps://www.npmjs.com/package/cheerio\u003e\n- RequireJS 官网：\u003chttps://requirejs.org/\u003e\n- Sass 官网（CSS 预处理器，通过编程的方式来开发 CSS）：\u003chttps://sass-lang.com/\u003e\n- Less 官网（同上）：\u003chttp://lesscss.org/\u003e\n- CSS 参考笔记：\u003chttp://css.doyoe.com/\u003e\n- Bootstrap 官网：\u003chttps://www.bootcss.com/\u003e\n- CSS 优质内容网站：\u003chttps://css-tricks.com/\u003e\n- CSS 优质内容网站：\u003chttps://css-weekly.com/\u003e\n- HTML 优质内容网站：\u003chttps://www.html5rocks.com/en/\u003e\n- JS 优质内容：\u003chttp://www.echojs.com/\u003e\n- 移动端 Web 开发：\u003chttps://mobiledevweekly.com/\u003e\n- VScode 快捷键介绍：\u003chttps://www.cnblogs.com/bindong/p/6045957.html\u003e\n- Socket 通信：\u003chttps://socket.io/\u003e\n- JSONPlaceholder：\u003chttp://jsonplaceholder.typicode.com/\u003e\n- 拉勾网：\u003chttps://www.lagou.com/\u003e\n- Boss 直聘：\u003chttps://www.zhipin.com/?sid=sem_pz_bdpc_dasou_title\u003e\n- 猎聘网：\u003chttps://www.liepin.com/\u003e\n- 智联招聘：\u003chttp://landing.zhaopin.com/register\u003e\n- 一早一晚（国内远程工程师招聘）：\u003chttps://yizaoyiwan.com/\u003e\n- 接项目接私活的网站总结：\u003chttps://blog.csdn.net/weixin_43606158/article/details/90728142\u003e\n- web 开发互助网：\u003chttp://hz.uyi2.com/\u003e\n- 前端面试题一到三年： \u003chttps://blog.csdn.net/weixin_43606158/article/details/89811189\u003e\n- 前端面试题三到五年：\u003chttps://blog.csdn.net/weixin_43606158/article/details/89640672\u003e\n- 项目中常用插件：\u003chttps://blog.csdn.net/weixin_43606158/article/details/90136700\u003e\n- React 新闻订阅：\u003chttp://reactjsnewsletter.com/issues\u003e\n- 社区：\u003chttps://hashnode.com/\u003e\n- 节点周刊：\u003chttps://nodeweekly.com/\u003e\n- 前端焦点：\u003chttps://frontendfoc.us/\u003e\n- JavaScript 周刊:\u003chttps://javascriptweekly.com/\u003e\n- 各种书籍：\u003chttps://www.sitepoint.com/\u003e\n- 各种书籍文章：\u003chttps://www.smashingmagazine.com/\u003e\n- 资源数据：\u003chttps://www.ceicdata.com\u003e\n- 99 藏书网【非 IT 行业图书】：\u003chttps://www.99lib.net/book/\u003e\n- 投资界新闻：\u003chttps://news.pedaily.cn/\u003e\n- 百度网盘免费超级会员列表（不建议在此网站购买，等他每日更新的账号就可以）：\u003chttps://www.vipleyuan.com/bdy\u003e\n- 开发者中心： \u003chttps://dev.dcloud.net.cn/\u003e\n","like_users":[],"create_time":{"$date":"2019-11-21T03:11:46.434Z"},"update_time":{"$date":"2019-11-21T03:11:46.434Z"},"id":23,"__v":0}
{"_id":{"$oid":"5dde14b400f3ab003065e403"},"meta":{"views":9,"likes":0,"comments":0},"keyword":["如何优雅处理前端异常"],"desc":"如何优雅处理前端异常？(史上最全前端异常处理方案)","numbers":"11183","img_url":"https://upload-images.jianshu.io/upload_images/12890819-80fa7517ab3f2783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","type":1,"state":1,"origin":1,"tags":[{"$oid":"5dde0b9500f3ab003065e402"}],"comments":[],"category":[{"$oid":"5dde0b8900f3ab003065e401"}],"title":"如何优雅处理前端异常？(史上最全前端异常处理方案)","author":"golderBrother","content":"\u003e 前端一直是距离用户最近的一层，随着产品的日益完善，我们会更加注重用户体验，而前端异常却如鲠在喉，甚是烦人。\n\n## 一、为什么要处理异常？\n\n异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。\n\n1. 增强用户体验； \n2. 远程定位问题； \n3. 未雨绸缪，及早发现问题； \n4. 无法复线问题，尤其是移动端，机型，系统都是问题； \n5. 完善的前端方案，前端监控系统；\n\n对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。\n\n二、需要处理哪些异常？\n对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：\n\n- JS 语法错误、代码异常\n- AJAX 请求异常\n- 静态资源加载异常\n- Promise 异常\n- Iframe 异常\n- 跨域 Script error\n- 崩溃和卡顿\n\n下面我会针对每种具体情况来说明如何处理这些异常。\n\n## 三、Try-Catch 的误区\ntry-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。\n\n1. 同步运行时错误：\n```js\ntry {\n  let name = 'jartto';\n  console.log(nam);\n} catch(e) {\n  console.log('捕获到异常：',e);\n}\n```\n输出：\n```\n捕获到异常：ReferenceError: nam is not defined\n    at \u003canonymous\u003e:3:15\n```\n\n2. 不能捕获到具体的语法错误，只有一个语法错误提示。我们修改一下代码，删掉一个单引号：\n\n```js\ntry {\n  let name = 'jartto;\n  console.log(nam);\n} catch(e) {\n\n  console.log('捕获到异常：',e);\n}\n\n```\n输出：\n\n```\nUncaught SyntaxError: Invalid or unexpected token\n\n```\n不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。\n\n3. 异步错误\n```js\ntry {\n  setTimeout(() =\u003e {\n    undefined.map(v =\u003e v);\n  }, 1000)\n} catch(e) {\n  console.log('捕获到异常：',e);\n}\n```\n我们看看日志：\n\n```js\nUncaught TypeError: Cannot read property 'map' of undefined\n    at setTimeout (\u003canonymous\u003e:3:11)\n```\n并没有捕获到异常，这是需要我们特别注意的地方。\n\n## 四、window.onerror 不是万能的\n\n当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。\n\n```js\n/**\n* @param {String}  message    错误信息\n* @param {String}  source    出错文件\n* @param {Number}  lineno    行号\n* @param {Number}  colno    列号\n* @param {Object}  error  Error对象（对象）\n*/\n\nwindow.onerror = function(message, source, lineno, colno, error) {\n   console.log('捕获到异常：',{message, source, lineno, colno, error});\n}\n```\n\n1. 首先试试同步运行时错误\n\n```js\nwindow.onerror = function(message, source, lineno, colno, error) {\n// message：错误信息（字符串）。\n// source：发生错误的脚本URL（字符串）\n// lineno：发生错误的行号（数字）\n// colno：发生错误的列号（数字）\n// error：Error对象（对象）\nconsole.log('捕获到异常：',{message, source, lineno, colno, error});\n}\nJartto;\n```\n可以看到，我们捕获到了异常：\n\n2. 再试试语法错误呢？\n\n```js\nwindow.onerror = function(message, source, lineno, colno, error) {\nconsole.log('捕获到异常：',{message, source, lineno, colno, error});\n}\nlet name = 'Jartto\n```\n控制台打印出了这样的异常：\n\n```js\nUncaught SyntaxError: Invalid or unexpected token\n```\n\n什么，竟然没有捕获到语法错误？\n\n3. 怀着忐忑的心，我们最后来试试异步运行时错误：\n\n```js\nwindow.onerror = function(message, source, lineno, colno, error) {\n    console.log('捕获到异常：',{message, source, lineno, colno, error});\n}\nsetTimeout(() =\u003e {\n    Jartto;\n});\n```\n控制台输出了：\n\n```js\n捕获到异常：{message: \"Uncaught ReferenceError: Jartto is not defined\", source: \"http://127.0.0.1:8001/\", lineno: 36, colno: 5, error: ReferenceError: Jartto is not defined\n    at setTimeout (http://127.0.0.1:8001/:36:5)}\n```\n\n4. 接着，我们试试网络请求异常的情况：\n\n```js\n\u003cscript\u003e\nwindow.onerror = function(message, source, lineno, colno, error) {\n    console.log('捕获到异常：',{message, source, lineno, colno, error});\n    return true;\n}\n\u003c/script\u003e\n\u003cimg src=\"./jartto.png\"\u003e\n```\n\n**我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。**\n\n补充一点：window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx\n\n```js\nwindow.onerror = function(message, source, lineno, colno, error) {\n    console.log('捕获到异常：',{message, source, lineno, colno, error});\n    return true;\n}\nsetTimeout(() =\u003e {\n    Jartto;\n});\n```\n\n控制台就不会再有这样的错误了：\n\n```js\nUncaught ReferenceError: Jartto is not defined\n    at setTimeout ((index):36)\n```\n\n需要注意：\n\n- onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；\n- onerror 无法捕获语法错误；\n\n到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。\n\n问题又来了，捕获不到静态资源加载异常怎么办？\n\n## 五、window.addEventListener\n当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的window.addEventListener 捕获。\n\n```js\n\u003cscritp\u003e\nwindow.addEventListener('error', (error) =\u003e {\n    console.log('捕获到异常：', error);\n}, true)\n\u003c/script\u003e\n\u003cimg src=\"./jartto.png\"\u003e\n```\n\n控制台输出：\n\n```js\n捕获到异常： Event {isTrusted: true, type: \"error\", target: img, currentTarget: Window, eventPhase: 1, …}\n```\n\n由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。\n\n### 需要注意：\n\n- 不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。\n- 需要注意避免 addEventListener 重复监听。\n\n$$ 六、Promise Catch\n在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。\n\n没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。\n\n解决方案：为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：\n\n```js\nwindow.addEventListener(\"unhandledrejection\", function(e){\n  console.log(e);\n});\n```\n我们继续来尝试一下：\n\n```js\nwindow.addEventListener(\"unhandledrejection\", function(e){\n  e.preventDefault()\n  console.log('捕获到异常：', e);\n  return true;\n});\nPromise.reject('promise error');\n```\n\n可以看到如下输出：\n\n```js\n捕获到异常： PromiseRejectionEvent {isTrusted: true, promise: Promise, reason: \"promise error\", type: \"unhandledrejection\", target: Window, …}\n```\n\n那如果对 Promise 不进行 catch 呢？\n\n```js\nwindow.addEventListener(\"unhandledrejection\", function(e){\n  e.preventDefault()\n  console.log('捕获到异常：', e);\n  return true;\n});\nnew Promise((resolve, reject) =\u003e {\n  reject('jartto: promise error');\n});\n```\n嗯，事实证明，也是会被正常捕获到的。\n\n所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。\n\n补充一点：如果去掉控制台的异常显示，需要加上：\n\n```js\nevent.preventDefault();\n```\n\n## VUE errorHandler\n这个是vue的全局异常捕获器\n\n```js\nVue.config.errorHandler = (err, vm, info) =\u003e {\n  console.error('通过vue errorHandler捕获的错误');\n  console.error(err);\n  console.error(vm);\n  console.error(info);\n}\n```\n\n## 八、React 异常捕获 React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息\n\n```js\ncomponentDidCatch(error, info) {\n    console.log(error, info);\n}\n```\n\n除此之外，我们可以了解一下：error boundary UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。\n\n需要注意的是：error boundaries 并不会捕捉下面这些错误。\n\n1. 事件处理器\n2. 异步代码\n3. 服务端的渲染代码\n4. 在 error boundaries 区域内的错误\n我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary：\n\n```js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n \n  componentDidCatch(error, info) {\n    // Display fallback UI\n    this.setState({ hasError: true });\n    // You can also log the error to an error reporting service\n    logErrorToMyService(error, info);\n  }\n \n  render() {\n    if (this.state.hasError) {\n      // You can render any custom fallback UI\n      return \u003ch1\u003eSomething went wrong.\u003c/h1\u003e;\n    }\n    return this.props.children;\n  }\n}\n```\n\n然后我们像使用普通组件那样使用它：\n\n```js\n\u003cErrorBoundary\u003e\n  \u003cMyWidget /\u003e\n\u003c/ErrorBoundary\u003e\n```\n\ncomponentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。\n\n实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！\n\n## 九、iframe 异常\n对于 iframe 的异常捕获，我们还得借力 window.onerror：\n\n```js\nwindow.onerror = function(message, source, lineno, colno, error) {\n  console.log('捕获到异常：',{message, source, lineno, colno, error});\n}\n```\n\n一个简单的例子可能如下：\n\n```js\n\u003ciframe src=\"./iframe.html\" frameborder=\"0\"\u003e\u003c/iframe\u003e\n\u003cscript\u003e\n  window.frames[0].onerror = function (message, source, lineno, colno, error) {\n    console.log('捕获到 iframe 异常：',{message, source, lineno, colno, error});\n    return true;\n  };\n\u003c/script\u003e\n```\n\n## 十、Script error\n一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：\n\n跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。\n```js\n\u003cscript src=\"http://jartto.wang/main.js\" crossorigin\u003e\u003c/script\u003e\n```\n或者动态去添加 js 脚本：\n\n```js\nconst script = document.createElement('script');\nscript.crossOrigin = 'anonymous';\nscript.src = url;\ndocument.body.appendChild(script);\n```\n\n特别注意，服务器端需要设置：Access-Control-Allow-Origin\n\n此外，我们也可以试试这个-解决 Script Error 的另类思路：\n\n```js\nconst originAddEventListener = EventTarget.prototype.addEventListener;\nEventTarget.prototype.addEventListener = function (type, listener, options) {\n  const wrappedListener = function (...args) {\n    try {\n      return listener.apply(this, args);\n    }\n    catch (err) {\n      throw err;\n    }\n  }\n  return originAddEventListener.call(this, type, wrappedListener, options);\n}\n```\n简单解释一下：\n\n改写了 EventTarget 的 addEventListener 方法；对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：\n\n```\n(() =\u003e {\n   const originAddEventListener = EventTarget.prototype.addEventListener;\n   EventTarget.prototype.addEventListener = function (type, listener, options) {\n    // 捕获添加事件时的堆栈\n    const addStack = new Error(`Event (${type})`).stack;\n     const wrappedListener = function (...args) {\n       try {\n         return listener.apply(this, args);\n       }\n       catch (err) {\n            // 异常发生时，扩展堆栈\n            err.stack += '\\n' + addStack;\n            throw err;\n       }\n     }\n     return originAddEventListener.call(this, type, wrappedListener, options);\n   }\n })();\n```\n\n## 十一、崩溃和卡顿\n卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？\n\n崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。\n\n利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。不错的文章，推荐阅读：Logging Information on Browser Crashes。\n\n```js\nwindow.addEventListener(\"load\", function() {\n    sessionStorage.setItem(\"good_exit\", \"pending\");\n    setInterval(function() {\n      sessionStorage.setItem(\"time_before_crash\", new Date().toString());\n    }, 1000);\n  });\n\n  window.addEventListener(\"beforeunload\", function() {\n    sessionStorage.setItem(\"good_exit\", \"true\");\n  });\n\n  if (\n    sessionStorage.getItem(\"good_exit\") \u0026\u0026\n    sessionStorage.getItem(\"good_exit\") !== \"true\"\n  ) {\n    /*\n    insert crash logging code here\n*/\n    alert(\n      \"Hey, welcome back from your crash, looks like you crashed on: \" +\n        sessionStorage.getItem(\"time_before_crash\")\n    );\n  }\n```\n\n基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控：\n```Service Worker``` 有自己独立的工作线程，与网页区分开，网页崩溃了，```Service Worker``` 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 ```navigator.serviceWorker.controller.postMessage``` API 向掌管自己的 SW 发送消息。\n\n## 十二、错误上报\n1.通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。\n\n2.动态创建 img 标签的形式\n```js\nfunction report(error) {\n  let reportUrl = 'http://jartto.wang/report';\n  new Image().src = `${reportUrl}?logs=${error}`;\n}\n```\n\n收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：\n\n```js\nReporter.send = function(data) {\n  // 只采集 30%\n  if(Math.random() \u003c 0.3) {\n    send(data)      // 上报错误信息\n  }\n}\n```\n采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。\n\n## 十三、总结\n回到我们开头提出的那个问题，如何优雅的处理异常呢？\n\n1. 可疑区域增加 Try-Catch\n2. 全局监控 JS 异常 window.onerror\n3. 全局监控静态资源异常 window.addEventListener\n4. 捕获没有 Catch 的 Promise 异常：unhandledrejection\n5. VUE errorHandler 和 React componentDidCatch\n6. 监控网页崩溃：window 对象的 load 和 beforeunload\n7. 跨域 crossOrigin 解决\n\n其实很简单，正如上文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。\n\n十四、参考\n- Logging Information on Browser Crashes http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/\n- 前端代码异常监控实战 https://github.com/happylindz/blog/issues/5\n- Error Boundaries https://blog.csdn.net/a986597353/article/details/78469979\n- 前端监控知识点 https://github.com/RicardoCao-Biker/Front-End-Monitoring/blob/master/BasicKnowledge.md\n- Capture and report JavaScript errors with window.onerror https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror\n","like_users":[],"create_time":{"$date":"2019-11-27T06:16:20.123Z"},"update_time":{"$date":"2019-11-27T06:16:20.123Z"},"id":24,"__v":0}
{"_id":{"$oid":"5ded0da400f3ab003065e406"},"meta":{"views":10,"likes":0,"comments":0},"keyword":["前端跨域"],"desc":"前端跨域解决方案","numbers":"14585","img_url":"https://upload-images.jianshu.io/upload_images/12890819-80fa7517ab3f2783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","type":1,"state":1,"origin":0,"tags":[{"$oid":"5ded0d6100f3ab003065e404"}],"comments":[],"category":[{"$oid":"5ded0d7b00f3ab003065e405"}],"title":"前端跨域解决方案","author":"golderBrother","content":"# 前端跨域解决方案\n\n## 跨域背景\n\n- 同域 同域：**协议、域名、端口号**均相同\n\n- 跨域：\n跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。\n\n- 同源策略：\n同源策略由Netscape公司1995年引入浏览器，协助浏览器免受到XSS、CSFR等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n\n| URL | 说明 | 是否允许通信 |\n| ------ | ------ | ------ |\n| http://www.demo.com/a.js | 同一域名，不同文件或路径 | 允许 |\n| http://www.demo.com/b.js |||\n| http://www.demo.com/lab/c.js |||\n| http://www.demo.com:8000/a.js | 同一域名，不同端口 | 不允许 |\n| http://www.demo.com/b.js |||\n| http://www.demo.com/a.js | 同一域名，不同协议 | 不允许 |\n| https://www.demo.com/b.js |||\n| http://www.demo.com/a.js | 域名和域名对应相同ip | 不允许 |\n| http://127.0.0.1/b.js |||\n| http://www.demo.com/a.js | 主域相同，子域不同 | 不允许 |\n| http://x.demo.com/b.js |||\n| http://demo.com/c.js |||\n| http://www.demo1.com/a.js | 不同域名 | 不允许 |\n| http://www.demo2.com/a.js |||\n\n## 跨域行为\n\n**ajax请求 XMLHttpRequest；**\n\n注意：浏览器并不会限制跨域请求的发出，即服务端再未做其他限制的情况下仍可收到跨域请求，浏览器只是限制了ajax请求返回信息的读取、cookie写入等操作\n扩展：服务端如何限制仅接收指定域名请求? refer?\n\n**fetch；**\n非同域窗体之间（比如iframe引入的情况的父子窗体）不能直接进行数据通讯或共享\nWeb 字体 (CSS 中通过 @font-face 使用跨域字体资源)\n\n**WebGL 贴图；**\n\n使用 drawImage 将 Images/video 画面绘制到 canvas\n\n跨域报错：\n```\nNo 'Access-Control-Allow-Origin' header is present on the requested resource\n// 并且The response had HTTP status code 404\n```\n\n### 1、通过jsonp跨域\n\nJSONP 的原理很简单，就是利用 script 标签没有跨域限制的漏洞。通过script 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。JSONP 使用简单且兼容性不错，但是只限于 get 请求，不可能支持post请求。在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现：\n\n```\nfunction jsonp(url, jsonpCallback, success) {\n  let script = document.createElement(\"script\");\n  script.src = url;\n  script.async = true;\n  script.type = \"text/javascript\";\n  window[jsonpCallback] = function(data) {\n    success \u0026 success(data);\n  };\n  document.body.appendChild(script);\n}\njsonp(\n  \"http://xxx\",\n  \"callback\",\n  function(value) {\n    console.log(value);\n  }\n);\n```\n\n应用场景：淘宝和天猫通过jsonp跨域共享cookie，在淘宝(www.taobao.com)登录后，切换到天猫(www.tmall.com)，会看到顶栏已经有登录用户信息。打开控制台，刷新tmall页面，可以看到如下jsonp请求。\n\n```\n// Jquery jsonp\n$.ajax({\n    url: 'http://www.domain2.com:8080/login',\n    type: 'get',\n    dataType: 'jsonp',  // 请求方式为jsonp\n    jsonpCallback: \"onBack\",    // 自定义回调函数名\n    data: {}\n});\n\n// vue 中jsonp用法\nthis.$http.jsonp('http://www.domain2.com:8080/login', {\n    params: {},\n    jsonp: 'onBack'\n}).then((res) =\u003e {\n    console.log(res); \n})\n```\n\n优点：简单（不推荐此方法）\n\n缺点：如果动态脚本插入有效，就执行调用；如果无效，就静默失败：不能从服务器捕捉到 404 错误，也不能取消或重新开始请求。（自行设置定时器，超时后没有进入回调即判定为请求失败 ）。\n\n### 2、 CORS\n\n服务端设置 Access-Control-Allow-Origin 即可，前端无须设置，若要带cookie请求，前后端都需要设置，CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了CORS，就实现了跨域。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。\n\n```\n前端设置\n// JS\nvar xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容\n\n// 前端设置是否带cookie\nxhr.withCredentials = true;\n\nxhr.open('post', 'http://www.domain2.com:8080/login', true);\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\nxhr.send('user=admin');\n\nxhr.onreadystatechange = function() {\n    if (xhr.readyState == 4 \u0026\u0026 xhr.status == 200) {\n        alert(xhr.responseText);\n    }\n};\n\n// 或 jquery\n$.ajax({\n    ...\n   xhrFields: {\n       withCredentials: true    // 前端设置是否带cookie\n   },\n   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie\n    ...\n});\n\n// 或vue.axios\naxios.defaults.withCredentials = true\n\n// 或vue-resource\nVue.http.options.credentials = true\n\n// 服务端设置\n// java\n/*\n * 导入包：import javax.servlet.http.HttpServletResponse;\n * 接口参数中定义：HttpServletResponse response\n */\n\n// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/'\nresponse.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); \n\n// 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示\nresponse.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); \n\n// 提示OPTIONS预检时，后端需要设置的两个常用自定义头\nresponse.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type,X-Requested-With\");\n\n// 或node 后端\nvar http = require('http');\nvar server = http.createServer();\nvar qs = require('querystring');\n\nserver.on('request', function(req, res) {\n    var postData = '';\n\n    // 数据块接收中\n    req.addListener('data', function(chunk) {\n        postData += chunk;\n    });\n\n    // 数据接收完毕\n    req.addListener('end', function() {\n        postData = qs.parse(postData);\n\n        // 跨域后台设置\n        res.writeHead(200, {\n            'Access-Control-Allow-Credentials': 'true',     // 后端允许发送Cookie\n            'Access-Control-Allow-Origin': 'http://www.domain1.com',    // 允许访问的域（协议+域名+端口）\n            /* \n             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，\n             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问\n             */\n            'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie\n        });\n\n        res.write(JSON.stringify(postData));\n        res.end();\n    });\n});\n\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n```\n\n优点：所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。\n\n缺点: CORS 可以使用 XDomainRequest 来支持 IE8/9。但是，并不支持带上 cookies。所以在需要兼容 IE8/9 的情况下，CORS 用不了。\n\n### 3、 document.domain + iframe跨域\n\n该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域。\n\n```\n// 父级(http://www.domain.com/a.html)\n\u003ciframe id=\"iframe\" src=\"http://child.domain.com/b.html\"\u003e\u003c/iframe\u003e\n\u003cscript\u003e\n    document.domain = 'domain.com';\n    var user = 'admin';\n\u003c/script\u003e\n\n// 子级(http://child.domain.com/b.html)\n\u003cscript\u003e\n    document.domain = 'domain.com';\n    // 获取父窗口中变量\n    alert('get js data from parent ---\u003e ' + window.parent.user);\n\u003c/script\u003e\n```\n\n优点：同类业务场景内跨域方便快捷。\n\n缺点: 仅限主域相同，子域不同的跨域应用场景，适用范围小。\n\n### 4、 location.hash + iframe\n\n该方案是依赖消息通信机制实现，原理是在目标服务器放置一个代理文件(proxy_frame.html)，通过加载该代理文件和服务端进行数据交互（同域请求），返回数据通过消息通讯(如post message)返回给上层应用以实现跨域数据交互a.b.com域页面。实际上是利用窗体之间通讯方式 将跨域请求转化为同域请求。\n\n```\n// 父级(http://www.domain1.com/a.html)\n\u003ciframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"\u003e\u003c/iframe\u003e\n\u003cscript\u003e\n    var iframe = document.getElementById('iframe');\n\n    // 向b.html传hash值\n    setTimeout(function() {\n        iframe.src = iframe.src + '#user=admin';\n    }, 1000);\n\n    // 开放给同域c.html的回调方法\n    function onCallback(res) {\n        alert('data from c.html ---\u003e ' + res);\n    }\n\u003c/script\u003e\n\n// 子级(http://www.domain2.com/b.html)\n\u003ciframe id=\"iframe\" src=\"http://www.domain1.com/c.html\" style=\"display:none;\"\u003e\u003c/iframe\u003e\n\u003cscript\u003e\n    var iframe = document.getElementById('iframe');\n\n    // 监听a.html传来的hash值，再传给c.html\n    window.onhashchange = function () {\n        iframe.src = iframe.src + location.hash;\n    };\n\u003c/script\u003e\n```\n\n优点：利用iframe的location.hash传值，相同域之间直接js访问来通信。\n\n缺点：适用范围小。\n\n### 5、 window.name + iframe跨域\n\n该方案也是依赖消息通信机制实现，window.name属性的神奇之处在于name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。\n\n```\n// a 页面(http://www.domain1.com/a.html)\nvar proxy = function(url, callback) {\n    var state = 0;\n    var iframe = document.createElement('iframe');\n\n    // 加载跨域页面\n    iframe.src = url;\n\n    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload = function() {\n        if (state === 1) {\n            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n\n        } else if (state === 0) {\n            // 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';\n            state = 1;\n        }\n    };\n\n    document.body.appendChild(iframe);\n\n    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() {\n        iframe.contentWindow.document.write('');\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    }\n};\n\n// 请求跨域b页面数据\nproxy('http://www.domain2.com/b.html', function(data){\n    alert(data);\n});\n\n// proxy 页面(http://www.domain1.com/proxy....\n// 中间代理页，与a.html同域，内容为空即可\n// proxy代理页面可以没有这个文件，会报404但是不影响功能（但是路径一定要和index页面同源）。\n\n// b 页面(http://www.domain2.com/b.html)\n\u003cscript\u003e\n    window.name = 'This is domain2 data!';\n\u003c/script\u003e\n```\n\n优点：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\n\n缺点：iframe在现实中的表现是一直不停地刷新，每次触发onload事件后，重置src，相当于重新载入页面，又触发onload事件，于是就不停地刷新了。另外还有IE兼容问题。\n\n### 6、 postMessage跨域\n\n该方案也是依赖消息通信机制实现，这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。\n\n```\n// 发送消息端\nwindow.parent.postMessage('message', 'http://test.com');\n// 接收消息端\nvar mc = new MessageChannel();\nmc.addEventListener('message', (event) =\u003e {\n  var origin = event.origin || event.originalEvent.origin;\n    if (origin === 'http://test.com') {\n      console.log('验证通过')\n    }\n});\n```\n\n优点：```postMessage是```HTML5 ```XMLHttpRequest Level 2```中的API，且是为数不多可以跨域操作的window属性之一。\n\n缺点: 部分浏览器只支持字符串，所以传参时最好用```JSON.stringify()```序列化。\n\n### 7、 nginx代理跨域\n\n将本域服务端配置成 需要跨域获取的资源的 反向代理服务器，比如：使用Nginx配置请求转发：proxy_pass。此时可在nginx的静态资源服务器中加入以下配置：\n```\nlocation / {\n  add_header Access-Control-Allow-Origin *;\n}\n```\n\nnginx 反向代理接口跨域，通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。\n\n```\n// nginx 配置\n#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #要反向代理到的服务端\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true; # 跨域是否允许携带cookie\n    }\n}\n\n// 前端代码\nvar xhr = new XMLHttpRequest();\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n\n// 访问nginx中的代理服务器\nxhr.open('get', 'http://www.domain1.com:81/?user=admin', true);\nxhr.send();\n\n// node 代码\nvar http = require('http');\nvar server = http.createServer();\nvar qs = require('querystring');\n\nserver.on('request', function(req, res) {\n    var params = qs.parse(req.url.substring(2));\n\n    // 向前台写cookie\n    res.writeHead(200, {\n        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取\n    });\n\n    res.write(JSON.stringify(params));\n    res.end();\n});\n\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n```\n\n应用场景：nginx反向代理代理的是服务器,nginx和真正的服务端是一起的，正向代理代理的是客户端，客户端和代理服务器是一起的。\n\n优点：反向代理，负载均衡，占有内存少，并发能力强。\n\n缺点：无。\n\n### 8、nodejs中间件代理跨域\n\nnode中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。\n\n**vue框架1次跨域(开发环境)**\n\n利用```node + webpack + webpack-dev-server```代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是```webpack-dev-server```同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。\n\n```\n// webpack.config.js\nmodule.exports = {\n    entry: {},\n    module: {},\n    ...\n    devServer: {\n        historyApiFallback: true,\n        proxy: [{\n            context: '/login',\n            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口\n            changeOrigin: true, // 是否允许更改源\n            secure: false,  // 当代理某些https服务报错时用\n            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n        }],\n        noInfo: true\n    }\n}\n```\n\n**非vue 2次跨域(生产环境)**\n\n利用node + express + http-proxy-middleware搭建一个proxy服务器。\n\n```\n// 前端代码\nvar xhr = new XMLHttpRequest();\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n\n// 访问http-proxy-middleware代理服务器\nxhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);\nxhr.send();\n\n// 中间件服务器\nvar express = require('express');\nvar proxy = require('http-proxy-middleware');\nvar app = express();\n\napp.use('/', proxy({\n    // 代理跨域的目标接口(真正的服务器接口地址)\n    target: 'http://www.domain2.com:8080',\n    changeOrigin: true,\n\n    // 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) {\n        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');\n        res.header('Access-Control-Allow-Credentials', 'true');\n    },\n\n    // 修改响应信息中的cookie域名\n    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改\n}));\n\napp.listen(3000);\nconsole.log('Proxy server is listen at port 3000...');\n```\n\n### 9、WebSocket协议跨域\n\nWebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，但建立socket长连接，需要验证，本质上可以视为安全，不存在跨域限制,由于资源消耗较大，除了一些特殊场景，一般不使用。\n\n```\n// 前端代码\n\u003cdiv\u003euser input：\u003cinput type=\"text\"\u003e\u003c/div\u003e\n\u003cscript src=\"./socket.io.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\nvar socket = io('http://www.domain2.com:8080');\n\n// 连接成功处理\nsocket.on('connect', function() {\n    // 监听服务端消息\n    socket.on('message', function(msg) {\n        console.log('data from server: ---\u003e ' + msg); \n    });\n\n    // 监听服务端关闭\n    socket.on('disconnect', function() { \n        console.log('Server socket has closed.'); \n    });\n});\n\ndocument.getElementsByTagName('input')[0].onblur = function() {\n    socket.send(this.value);\n};\n\u003c/script\u003e\n\n// Nodejs socket\nvar http = require('http');\nvar socket = require('socket.io');\n\n// 启http服务\nvar server = http.createServer(function(req, res) {\n    res.writeHead(200, {\n        'Content-type': 'text/html'\n    });\n    res.end();\n});\n\nserver.listen('8080');\nconsole.log('Server is running at port 8080...');\n\n// 监听socket连接\nsocket.listen(server).on('connection', function(client) {\n    // 接收信息\n    client.on('message', function(msg) {\n        client.send('hello：' + msg);\n        console.log('data from client: ---\u003e ' + msg);\n    });\n\n    // 断开处理\n    client.on('disconnect', function() {\n        console.log('Client socket has closed.'); \n    });\n});\n```\n\n### 10、Flash代理跨域\n\n与 frame 代理模式类似，请求通过 Flash 来发送 ( proxy_flash.swf 放置在同源站)，利用 Flash 的策略文件 crossdomain.xml 来控制资源的共享权限，获取目标服务器请求返回数据---相当于把 iframe 改成 flash 。\n\n前提条件：你必须有权限管理所跨域的那片域上的文件，因为需要放置一个通行文件。如果你是跨域调图片、视频一类的，可以用通行文件的方法。通行文件制作方法，请将以下代码存为 crossdomain.xml ，并放到要跨域的目标站点根目录下面。就是说，你的FLASH在 a.com ，你要访问 b.com 上的资源，你就要确定 http://b.com/crossdomain.xml 能访问到。\n\n```\n\u003c?xml version=\"1.0\"?\u003e\n\u003ccross-domain-policy\u003e\n\u003callow-access-from domain=\"*\" /\u003e\n\u003c/cross-domain-policy\u003e\n```\n\n　上面是允许全部网站调用，如果要限制某个网站可以用下面的：\n　\n```\n\u003c?xml version=\"1.0\"?\u003e\n\u003c!DOCTYPE cross-domain-policy SYSTEM \"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd\"\u003e\n\u003ccross-domain-policy\u003e\n\u003callow-access-from domain=\"www.mayax.net\" /\u003e\n\u003callow-access-from domain=\"*.vkcms.com\" /\u003e\n\u003c/cross-domain-policy\u003e\n```\n\n上面代码中，允许了 www.mayax.net 进行跨域调用。但 bbs.mayax.net 不行；同时也允许了 vkcms.com 进行跨域， bbs.vkcms.com 也可以， vkflash.vkcms.com 也行！但，别的如 zhi.in 、 www.zhoujingsong.com 都不能跨域访问了。\n　　如果你跨域访问JS，或给跨域的JS传数据，那就要在通行文件的基础上，再作如下处理。如果你的FLASH文件要给JS文件传数据，调用Flash的SWF文件的HTML代码，要加上这一行参数：\n　　\n```\n\u003cparam name=\"allowScriptAccess\" value=\"always\" /\u003e\n```\n\n参数说明：always 允许随时执行脚本操作；never 禁止所有脚本执行操作。如果你的FLASH是读取JS发送的数据，那就在FLASH的AS代码中，加上：\n\n```\nSystem.security.allowDomain(\"*\");\n```\n\n还有一个常见问题，提示 import flash.display.BitmapData 失效，把下面这行代码加在AS里面就可以了：\n\n```\nSystem.security.loadPolicyFile(http://yoursite.com/crossdomain.xml);\n```\n\ncrossdomain.xml 的内容同上。\n　　\n　　","like_users":[],"create_time":{"$date":"2019-12-08T14:50:12.480Z"},"update_time":{"$date":"2019-12-08T14:50:12.480Z"},"id":25,"__v":0}
{"_id":{"$oid":"5ded133400f3ab003065e409"},"meta":{"views":10,"likes":0,"comments":0},"keyword":["NPM"],"desc":"NPM 快速使用开发技巧","numbers":"7886","img_url":"https://upload-images.jianshu.io/upload_images/12890819-80fa7517ab3f2783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","type":1,"state":1,"origin":1,"tags":[{"$oid":"5ded12eb00f3ab003065e408"}],"comments":[],"category":[{"$oid":"5ded12e500f3ab003065e407"}],"title":"NPM 快速使用开发技巧","author":"golderBrother","content":"## 0 前言\n\n每天，数以百万计的开发人员使用 npm 或 yarn 来构建项目。运行npm init或npx create- response -app等命令几乎构建JS项目的首选方式，无论是为客户端或服务器端，还是桌面应用程序。\n但是npm不仅仅是初始化项目或安装包。在本文中，我们将会介绍 npm 的13个技巧来最大限度地利用npm:从简单的快捷方式到自定义脚本。\n由于我们中的许多人每天都使用npm，从长远来看，即使节省少量的时间也会产生显著的影响。这些技巧是针对初学者和中级开发人员的，但是即使您是一位经验丰富的开发人员，我希望你仍然能够找到一到两个你以前没有遇到过的特性。\n\n### 1 学习基本快捷方式\n\n我们从最基本的开始,学习最常见的npm快捷方式从长远来将会节省很多时间。\n\n- 安装  —  常规：```npm install```，简写：```npm i```。\n- 测试  —  常规：```npm test```，简写：```npm t```。\n- 帮助  —  常规：```npm --help```，简写：```npm -h```。\n- 全局标志 —  常规： ```--global```，简写：```-g```。\n- 保存为开发依赖 - 常规： ```-- save-dev```，简写：```-D```。\n- npm init 默认值 - 常规：```npm init --yes``` 或 ```npm init --force```，简写：```npm init -y```或``` npm init -f```\n- \n我们知道使用-save或-S来保存包，但现在这是个已经是默认值。要安装一个包而不保存它，可以使用 ```--no-save```标志。\n不太常见的快捷键\n还有一些不常见的快捷方式，如下：\n安装包信息将加入到```optionalDependencies（可选阶段的依赖```）- 常规：```--save-optional```， 简写：```O```。\n精确安装指定模块版本 - 常规：```--save-optional```， 简写：```-O```。\n如果需要在本地保存一个npm包，或者通过单个文件下载选择一组可用的包，可以使用--save-bundle或-B将它们捆绑在一起，并使用npm pack获得捆绑包。\n根的快捷方式\n. 符号通常用于表示应用程序的根目录，npm术语中的应用程序入口点，即package.json中指定为```“main”```的值\n```{  \"main\": \"index.js\"}```\n这个快捷方式也可以用于像```npx create-react-app``` . 这样的命令。因此，可以运行```npx create-react-app .```，而不是使用 ```npx create-react-app my-app``` 创建一个新的```my-app```目录。\n\n\n### 2 设置默认npm init属性\n\n当运行```npm init```开始一个新项目时，你可能会发现自己一次又一次地输入配置细节。假如，你可能是项目的主要负责人。有时为了节省时间，可以为这些字段设置默认值，如下所示：\n\n```\nnpm config set init.author.name \"Joe Bloggs\"\nnpm config set init.author.email \"JoebLoggs@gmail.com\"\nnpm config set init.author.url \"Joebloggs.com\"\nnpm config set init.license \"MIT\"\n```\n\n要检查是否正确添加了这些属性，在终端输入 ```npm config edit```查看配置文件信息。当然也j可以通过直接在打开的配置文件编辑信息。 如果要编辑全局npm设置，使用```npm config edit -g```。\n\n要重新初始化默认设置，可以使用以下脚本。第一行用空字符串替换配置文件，第二行用默认设置重新填充配置文件。\n\n```\necho \"\" \u003e $(npm config get userconfig)\nnpm config edit\n```\n\n上面的脚本将重置用户默认值，下面的脚本将重置全局默认值\n\n```\necho \"\" \u003e $(npm config get globalconfig)\nnpm config --global edit\n```\n\n### 3 让脚本跨平台兼容\n\n任何在命令行上运行的代码都有兼容性问题的风险，特别是在Windows和基于unix的系统(包括Mac和Linux)之间。如果你只处理特定的项目，那么这不是问题，但是在许多情况下，跨平台兼容性很有必要的:任何开放源码或协作项目，以及示例和教程项目，都应该能够工作，而不管操作系统是什么。\n谢天谢地，解决方案很简单。有几个选项可供选择，但效果最好的是cross-env。使用npm i -D cross-env将其作为开发依赖项安装。然后在任何环境变量之前包括关键字cross-env，就像这样：\n\n```\n{\n  \"scripts\": {\n    \"build\": \"cross-env NODE_ENV=production webpack --config build/wepack.config.js\"\n  }\n}\n```\n\ncross-env是 实现跨平台兼容性的最无缝的方法，但还有其他两个流行的工具，它们可以帮助实现跨平台兼容性：\n\n- rimraf 可以安装在全球运行跨平台脚本\n- ShellJS 是Unix shell命令在Node.js API上的可移植实现。\n\n### 4 并行运行脚本\n\n可以使用```\u0026\u0026```来依次运行两个或多个进程。但是并行运行脚本呢?为此，我们可以从各种npm包中进行选择。```concurrent``` 和 ```npm-run-all``` 是最流行的解决方案。\n首先通过 ```npm i -D concurrently``` 安装开发依赖。然后按照以下格式将其添加到脚本中：\n\n```\n{  \"start\": \"concurrently \\\"command1 arg\\\" \\\"command2 arg\\\"\"}\n```\n\n### 5 在不同的目录中运行脚本\n\n有时，在不同的文件夹中拥有一个包含多个package.json文件的应用程序。 从根目录访问这些脚本会很方便，而不是每次要运行脚本时导航到不同的文件夹，有两种方法可以执行此操作。\n第一种是手动 cd 并运行对应的命令：\n\n```\ncd folder \u0026\u0026 npm start \u0026\u0026 cd ..\n```\n\n但还有一个更优雅的解决方案，即使用--prefix标志指定路径:\n\n```\nnpm start --prefix path/to/your/folder\n```\n\n下面是一个工作应用程序中此解决方案的示例，我们希望在前端(在客户机目录中)和后端(在服务器目录中)运行 npm start。\n\n```\n\"start\": \"concurrently \\\"(npm start --prefix client)\\\" \\\"(npm start --prefix server)\\\"\"\n```\n\n### 6 延迟运行脚本直到端口准备就绪\n\n通常，在开发全堆栈应用程序期间，咱们可能希望同时启动服务器和客户端。wait-on 节点模块提供了一种方便的方法来确保进程只在某些进程就绪时发生:在我们的例子中，我们有一个特定的端口。\n例如，这是我在使用React前端的Electron项目中使用的dev脚本。 同时使用，脚本并行加载表示层和Electron窗口。 但是，使用wait-on，只有在 http://localhost:3000 启动好，才会打开Electron窗口。\n\n```\n\"dev\": \"concurrently \\\"cross-env BROWSER=none npm run start\\\" \\\"wait-on http://localhost:3000 \u0026\u0026 electron .\\\"\",\n```\n\n此外，React默认情况下会打开一个浏览器窗口，但对于 Electron 开发来说，这是不必要的。咱们可以通过传递环境变量BROWSER=none来禁用此行为。\n\n### 7 列出并选择可用脚本\n列出package.json文件中可用的脚本很简单：只需转到项目的根目录并在终端中输入```npm run```。\n\n但是有一种更方便的方法可以获得脚本列表，可以立即运行该列表:为此，全局安装 NTL (npm任务列表)模块:\n\n```\nnpm i -g ntl\n```\n\n然后在项目文件夹中运行ntl命令，可以获得一个可用脚本列表，并可以选择其中一个运行。\n\n### 8 运行前后脚本\n你可能熟悉prebuild和postbuild这样的脚本，它们允许你定义在构建脚本之前或之后运行的代码。但事实上，pre和post可以在任何脚本之前添加，包括自定义脚本。\n\n这不仅使你的代码更干净，而且还允许你单独运行pre和post脚本\n\n### 9 控制应用程序版本\n与手动更改应用程序的版本相比，npm 提供了一些有用的快捷方式来完成这一点。 要增加版本，请在运行 ```npm version加上major，minor或patch```：\n\n```\n// 1.0.0\nnpm version patch\n// 1.0.1\nnpm version minor\n// 1.1.0\nnpm version major\n// 2.0.0\n```\n\n根据更新应用程序的频率，可以通过在每次部署时增加版本号来节省时间，使用以下脚本:\n\n```\n{  \"predeploy\": \"npm version patch\"}\n```\n\n### 10 从命令行编辑package.json\n\npackage.json是一个常规的json文件，因此可以使用工具库json从命令行进行编辑。这在修改package.json提供另外一种新的方式，允许w你q创建超出默认值的快捷方式。全局安装：\n\n```\nnpm install -g json\n```\n\n然后，可以使用它来使用-I进行就地编辑。 例如，要添加值为“bar”的新脚本“foo”，这样写：\n\n```\njson -I -f package.json -e 'this.scripts.foo=\"bar\"'\n```\n\n### 11 自动设置和打开你的github库\n\n如果package.json文件中有“repository”，则可以通过输入 npm repo在默认浏览器中打开它。\n如果你的项目已经连接到远程存储库，并且已经在命令行上安装了git，那您可以使用这个命令找到你的连接存储库\n\n```\ngit config --get remote.origin.url\n```\n\n更好的是，如果你按照上面的提示并安装了json模块，可以使用下面的脚本自动将正确的存储库添加到 package.json\n\n```\njson -I -f package.json -e \"this.repository=\\\"$(git config --get remote.origin.url)\\\"\"\n```\n\n### 12 自定义npm init脚本\n\n让我们更进一步，使用我们自己的npm init脚本，它接受GitHub存储库URL并自动推送我们的第一个提交。在本技巧中，我们将讨论如何创建自定义npm init脚本。在下一个(也是最后一个)技巧中，我们将合并git。\n\n可以通过重定向到主目录中的.npm-init.js文件来编辑npm init脚本。（在Windows上，通常是 c/Users/\u003c用户名\u003e，在 Mac 上，它是/Users/\u003c用户名\u003e）。\n\n让我们首先在我们的主目录中创建一个.nmm-init.js文件。为了确保npm init被指向正确的文件，可以运行:\n\n```\nnpm config set init-module ~\\.npm-init.js\n```\n\n在集成git之前，这里有一个简单的```.npm-init.js```文件，它模拟了默认npm init的问题。\n\n```\nmodule.exports = {\n  name: prompt('package name', basename || package.name),\n  version: prompt('version', '0.0.0'),\n  decription: prompt('description', ''),\n  main: prompt('entry point', 'index.js'),\n  repository: prompt('git repository', ''),\n  keywords: prompt(function (s) { return s.split(/\\s+/) }),\n  author: prompt('author', 'Joe Bloggs \u003cjoe.bloggs@gmail.com\u003e (joebloggs.com)'),\n  license: prompt('license', 'ISC')\n}\n```\n\n每个问题都遵循nameInPackage模式:prompt('nameInPrompt','defaultValue')。要在缺省情况下设置值而不带问题，只需删除prompt方法。\n如果要返回默认设置，只需删除.npm-init.js。\n\n### 13 使用自定义npm init脚本将你的第一个 Commit 提交到 GitHub\n\n为了将git命令合并到.npm-init.js文件中，需要一种方法来控制命令行。为此，我们可以使用child_process 模块。在文件的顶部引入它，因为我们只需要execSync函数，所以可以使用析构赋值语法自己获取它：\n\n```\nconst { execSync } = require('child_process');\n```\n\n我还创建了一个helper函数，它将函数的结果打印到控制台：\n\n```\nfunction run(func) {\n  console.log(execSync(func).toString())\n}\n```\n\n最后，我们将提示输入GitHub存储库URL，如果提供，我们将生README.md文件，并启动我们的第一次提交。\n\n```\nrepository: prompt('github repository url', '', function (url) {\n  if (url) {\n    run('touch README.md');\n    run('git init');\n    run('git add README.md');\n    run('git commit -m \"first commit\"');\n    run(`git remote add origin ${url}`);\n    run('git push -u origin master');\n  }\n  return url;\n})\n```\n\n总的来说，```.npm-init.js```文件大概如下：\n\n```\nconst { execSync } = require('child_process');\n\nfunction run(func) {\n  console.log(execSync(func).toString())\n}\n\nmodule.exports = {\n  name: prompt('package name', basename || package.name),\n  version: prompt('version', '0.0.0'),\n  decription: prompt('description', ''),\n  main: prompt('entry point', 'index.js'),\n  keywords: prompt(function (s) { return s.split(/\\s+/) }),\n  author: prompt('author', 'Joe Bloggs \u003cjoe.bloggs@gmail.com\u003e (joebloggs.com)'),\n  license: prompt('license', 'ISC'),\n  repository: prompt('github repository url', '', function (url) {\n    if (url) {\n      run('touch README.md');\n      run('git init');\n      run('git add README.md');\n      run('git commit -m \"first commit\"');\n      run(`git remote add origin ${url}`);\n      run('git push -u origin master');\n    }\n    return url;\n  }),\n}\n```\n\npackage.json文件：\n\n```\n{\n  \"name\": \"Custom npm init\",\n  \"version\": \"0.0.0\",\n  \"decription\": \"A test project, to demonstrate a custom npm init script.\",\n  \"main\": \"index.js\",\n  \"keywords\": [],\n  \"author\": \"Joe Bloggs \u003cjoe.bloggs@gmail.com\u003e (joebloggs.com)\",\n  \"license\": \"ISC\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/JoeBloggs/custom.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/JoeBloggs/custom/issues\"\n  },\n  \"homepage\": \"https://github.com/JoeBloggs/custom#readme\"\n}\n\n你也可以通过合并GitHub API进一步实现这一点，这样就不需要创建一个新的存储库，这部分留给你们自己完成。\n\n总的来说，希望这篇文章能够让你了解npm可以实现的目标，并展示了一些提高工作效率的方法 - 无论是你知道常见的快捷方式，还是通过充分利用脚本 package.json，或编写自定义版本的npm init。","like_users":[],"create_time":{"$date":"2019-12-08T15:13:56.538Z"},"update_time":{"$date":"2019-12-08T15:13:56.538Z"},"id":26,"__v":0}
{"_id":{"$oid":"5df9f9d700f3ab003065e40a"},"meta":{"views":18,"likes":0,"comments":0},"keyword":["TypeScript"],"desc":"TypeScript高级用法详解","numbers":"19514","img_url":"http://img.golderbrother.cn/typescript-logo.jpg","type":1,"state":1,"origin":1,"tags":[{"$oid":"5d9de00955bcb9003009ed7e"}],"comments":[],"category":[{"$oid":"5d9de03455bcb9003009ed7f"}],"title":"TypeScript高级用法详解","author":"golderBrother","content":"## 引言\n\n作为一门强大的静态类型检查工具，如今在许多中大型应用程序以及流行的JS库中均能看到TypeScript的身影。JS作为一门弱类型语言，在我们写代码的过程中稍不留神便会修改掉变量的类型，从而导致一些出乎意料的运行时错误。然而TypeScript在编译过程中便能帮我们解决这个难题，不仅在JS中引入了强类型检查，并且编译后的JS代码能够运行在任何浏览器环境，Node环境和任何支持ECMAScript 3(或更高版本)的JS引擎中。\n\n### 1、类继承\n在ES5中，我们一般通过函数或者基于原型的继承来封装一些组件公共的部分方便复用，然而在TypeScript中，我们可以像类似Java语言中以面向对象的方式使用类继承来创建可复用的组件。我们可以通过**class**关键字来创建类，并基于它使用**new**操作符来实例化一个对象。为了将多个类的公共部分进行抽象，我们可以创建一个父类并让子类通过**extends**关键字来继承父类，从而减少一些冗余代码的编写增加代码的可复用性和可维护性。示例如下：\n\n```js\nclass Parent {\n    readonly x: number;\n    constructor() {\n        this.x = 1;\n    }\n    \n    print() {\n        console.log(this.x);\n    }\n}\n\nclass Child extends Parent {\n    readonly y: number;\n    constructor() {\n        // 注意此处必须优先调用super()方法,相当于先实例化父类，子类才能使用this\n        super();\n        this.y = 2;\n    }\n    \n    print() {\n        // 通过super调用父类原型上的方法，但是方法中的this指向的是子类的实例\n        super.print();\n        console.log(this.y);\n    }\n}\n\nconst child = new Child();\nconsole.log(child.print()) // -\u003e 1 2\n\n```\n\n在上述示例中，```Child```子类中对父类的```print```方法进行重写，同时在内部使用```super.print()```来调用父类的公共逻辑，从而实现逻辑复用。```class```关键字作为构造函数的语法糖，在经过TypeScript编译后，最终会被转换为兼容性好的浏览器可识别的ES5代码。c```lass```在面向对象的编程范式中非常常见，因此为了弄清楚其背后的实现机制，我们不妨多花点时间来看下经过编译转换之后的代码是什么样子的\n\n```js\nvar __extends = (this \u0026\u0026 this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array \u0026\u0026 function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar Parent = /** @class */ (function () {\n    function Parent() {\n        this.x = 1;\n    }\n    Parent.prototype.print = function () {\n        console.log(this.x);\n    };\n    return Parent;\n}());\nvar Child = /** @class */ (function (_super) {\n    __extends(Child, _super);\n    function Child() {\n        var _this = \n        // 注意此处必须优先调用super()方法\n        _super.call(this) || this;\n        _this.y = 2;\n        return _this;\n    }\n    Child.prototype.print = function () {\n        // 通过super调用父类原型上的方法，但是方法中的this指向的是子类的实例\n        _super.prototype.print.call(this);\n        console.log(this.y);\n    };\n    return Child;\n}(Parent));\nvar child = new Child();\nconsole.log(child.print()); // -\u003e 1 2\n\n```\n\n以上就是转换后的完整代码，为了方便对比，这里将原来的注释信息保留，仔细研究这段代码我们会发现以下几个要点：\n\n1. 子类```Child```的构造函数中```super()```方法被转换成了```var _this = _super.call(this) || this```，这里的```_super```指的就是父类Parent，因此这句代码的含义就是调用父类构造函数并将this绑定到子类的实例上，这样的话子类实例便可拥有父类的x属性。因此为了实现属性继承，我们必须在子类构造函数中调用```super()```方法，如果不调用会编译不通过。\n\n2. 子类```Child```的```print```方法中```super.print()```方法被转换成了```_super.prototype.print.call(this)```，这句代码的含义就是调用父类原型上的```print```方法并将方法中的```this```指向子类实例，由于在上一步操作中我们已经继承到父类的x属性，因此这里我们将直接打印出子类实例的x属性的值。\n\n3. extends关键字最终被转换为```__extends(Child, _super)```方法，其中```_super```指的是父类```Parent```，为了方便查看，这里将```_extends```方法单独提出来进行研究。\n\n```js\nvar __extends = (this \u0026\u0026 this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array \u0026\u0026 function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        // 第一部分\n        extendStatics(d, b);\n        \n        // 第二部分\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n```\n\n在以上代码中，主要可以分为两个部分来进行理解，第一部分为```extendStatics(d, b)```方法，第二部分为该方法后面的两行代码。\n\n**第一部分**：\n\n在```extendStatics```方法内部虽然代码量相对较多，但是不难发现其实还是主要为了兼容ES5版本的执行环境。在ES6中新增了```Object.setPrototypeOf```方法用于手动设置对象的原型，但是在ES5的环境中我们一般通过一个非标准的```__proto__```属性来进行设置，```Object.setPrototypeOf```方法的原理其实也是通过该属性来设置对象的原型，其实现方式如下：\n\n```js\nObject.setPrototypeOf = function(obj, proto) {\n    obj.__proto__ = proto;\n    return obj;\n}\n```\n\n在```extendStatics(d, b)```方法中，```d```指子类```Child```，```b```指父类```Parent```，因此该方法的作用可以解释为：\n\n```js\n// 将子类Child的__proto__属性指向父类Parent\nChild.__proto__ = Parent;\n```\n\n可以将这行代码理解为构造函数的继承，或者叫静态属性和静态方法的继承，即属性和方法不是挂载到构造函数的```prototype```原型上的，而是直接挂载到构造函数本身，因为在JS中函数本身也可以作为一个对象，并可以为其赋予任何其他的属性，示例如下：\n\n```js\nfunction Foo() {\n  this.x = 1;\n  this.y = 2;\n}\n\nFoo.bar = function() {\n  console.log(3);\n}\n\nFoo.baz = 4;\nconsole.log(Foo.bar()) // -\u003e 3\nconsole.log(Foo.baz) // -\u003e 4\n```\n\n因此当我们在子类```Child```中以```Child.someProperty```访问属性时，如果子类中不存在就会通过```Child.__proto__```寻找父类的同名属性，通过这种方式来实现静态属性和静态方法的路径查找。\n\n**第二部分**：\n\n在第二部分中仅包含以下两行代码：\n\n```js\nfunction __() { this.constructor = d; }\nd.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\n```\n\n其中```d```指子类```Child```，```b```指父类Parent，这里对于JS中实现继承的几种方式比较熟悉的同学可以一眼看出，这里使用了寄生组合式继承的方式，通过借用一个中间函数```__()```来避免当修改子类的```prototype```上的方法时对父类的```prototype```所造成的影响。我们知道，在JS中通过构造函数实例化一个对象之后，该对象会拥有一个```__proto__```属性并指向其构造函数的```prototype```属性，示例如下：\n\n```js\nfunction Foo() {\n  this.x = 1;\n  this.y = 2;\n}\n\nconst foo = new Foo();\nfoo.__proto__ === Foo.prototype; // -\u003e true\n\n```\n\n对于本例中，如果通过子类```Child```来实例化一个对象之后，会产生如下关联：\n\n```js\nconst child = new Child();\nchild.__proto__ === (Child.prototype = new __());\nchild.__proto__.__proto__ === __.prototype === Parent.prototype; \n\n// 上述代码等价于下面这种方式\nChild.prototype.__proto__ === Parent.prototype;\n```\n\n因此当我们在子类```Child```的实例```child```对象中通过```child.someMethod()```调用某个方法时，如果在实例中不存在该方法，则会沿着```__proto__```继续往上查找，最终会经过父类```Parent```的```prototype```原型，即通过这种方式来实现方法的继承。\n\n因此当我们在子类```Child```的实例```child```对象中通过```child.someMethod()```调用某个方法时，如果在实例中不存在该方法，则会沿着```__proto__```继续往上查找，最终会经过父类```Parent```的```prototype```原型，如果父类```Parent```的```prototype```原型上也找不到，就会返回```undefined```，即通过这种方式来实现方法的继承。\n\n```js\n// 表示构造函数的继承，或者叫做静态属性和静态方法的继承，总是指向父类\n1. Child.__proto__ === Parent;\n\n// 表示方法的继承，总是指向父类的prototype属性\n2. Child.prototype.__proto__ === Parent.prototype;\n\n```\n\n2、访问修饰符\nTypeScript为我们提供了访问修饰符(Access Modifiers)来限制在```class```外部对内部属性的访问，访问修饰符主要包含以下三种：\n\n- ```public```：公共修饰符，其修饰的属性和方法都是公有的，可以在任何地方被访问到，默认情况下所有属性和方法都是```public```的。\n- ```private```：私有修饰符，其修饰的属性和方法在class外部不可见。\n- ```protected```：受保护修饰符，和private比较相似，但是其修饰的属性和方法**在子类内部是被允许访问的**。\n\n我们通过一些示例来对几种修饰符进行对比：\n\n```\nclass Human {\n    public name: string;\n    public age: number;\n    public constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nconst man = new Human('tom', 20);\nconsole.log(man.name, man.age); // -\u003e tom 20\nman.age = 21;\nconsole.log(man.age); // -\u003e 21\n\n```\n\n在上述示例中，由于我们将访问修饰符设置为```public```，因此我们通过实例```man```来访问```name```和```age```属性是被允许的，同时对```age```属性重新赋值也是允许的。但是在某些情况下，我们希望某些属性是对外不可见的，同时不允许被修改，那么我们就可以使用```private```修饰符：\n\n```\nclass Human {\n    public name: string;\n    private age: number; // 此处修改为使用private修饰符\n    public constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nconst man = new Human('tom', 20);\nconsole.log(man.name); // -\u003e tom\nconsole.log(man.age);\n// -\u003e Property 'age' is private and only accessible within class 'Human'.\n\n我们将age属性的修饰符修改为private后，在外部通过man.age对其进行访问，TypeScript在编译阶段就会发现其是一个私有属性并最终将会报错。\n```\n\n我们将```age```属性的修饰符修改为```private```后，在外部通过```man.age```对其进行访问，TypeScript在编译阶段就会发现其是一个私有属性并最终将会报错。\n\n\u003e 注意：在TypeScript编译之后的代码中并没有限制对私有属性的存取操作。\n\n编译后的代码如下：\n\n```js\nvar Human = /** @class */ (function () {\n    function Human(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n    return Human;\n}());\nvar man = new Human('tom', 20);\nconsole.log(man.name); // -\u003e tom\nconsole.log(man.age); // -\u003e 20\n\n```\n\n使用```private```修饰符修饰的属性或者方法**在子类中也是不允许访问的**\n\n，示例如下：\n\n```js\nclass Human {\n    public name: string;\n    private age: number;\n    public constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nclass Woman extends Human {\n    private gender: number = 0;\n    public constructor(name: string, age: number) {\n        super(name, age);\n        console.log(this.age);\n    }\n}\n\nconst woman = new Woman('Alice', 18);\n// -\u003e Property 'age' is private and only accessible within class 'Human'.\n\n```\n\n```js\nclass Human {\n    public name: string;\n    private age: number;\n    public constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nclass Woman extends Human {\n    private gender: number = 0;\n    public constructor(name: string, age: number) {\n        super(name, age);\n        console.log(this.age);\n    }\n}\n\nconst woman = new Woman('Alice', 18);\n// -\u003e Property 'age' is private and only accessible within class 'Human'.\n```\n\n在上述示例中由于在父类```Human```中```age```属性被设置为```private```，因此在子类```Woman```中无法访问到```age```属性，为了让在子类中允许访问```age```属性，我们可以使用```protected```修饰符来对其进行修饰：\n\n```js\nclass Human {\n    public name: string;\n    protected age: number; // 此处修改为使用protected修饰符\n    public constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nclass Woman extends Human {\n    private gender: number = 0;\n    public constructor(name: string, age: number) {\n        super(name, age);\n        console.log(this.age);\n    }\n}\n\nconst woman = new Woman('Alice', 18); // -\u003e 18\n\n\n当我们将private修饰符用于构造函数时，则表示该类不允许被继承或实例化，示例如下：\n```\n\n当我们将```private```修饰符用于构造函数时，则表示该类**不允许被继承或实例化**，示例如下：\n\n```js\nclass Human {\n    public name: string;\n    public age: number;\n    \n    // 此处修改为使用private修饰符\n    private constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nclass Woman extends Human {\n    private gender: number = 0;\n    public constructor(name: string, age: number) {\n        super(name, age);\n    }\n}\n\nconst man = new Human('Alice', 18);\n// -\u003e Cannot extend a class 'Human'. Class constructor is marked as private.\n// -\u003e Constructor of class 'Human' is private and only accessible within the class declaration.\n\n```\n\n当我们将```protected```修饰符用于构造函数时，则表示该类**只允许被继承**，示例如下：\n\n```js\nclass Human {\n    public name: string;\n    public age: number;\n    \n    // 此处修改为使用protected修饰符\n    protected constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nclass Woman extends Human {\n    private gender: number = 0;\n    public constructor(name: string, age: number) {\n        super(name, age);\n    }\n}\n\nconst man = new Human('Alice', 18);\n// -\u003e Constructor of class 'Human' is protected and only accessible within the class declaration.\n\n```\n\n另外我们还可以直接将修饰符放到构造函数的参数中，示例如下：\n\n```js\nclass Human {\n    // public name: string;\n    // private age: number;\n    \n    public constructor(public name: string, private age: number) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nconst man = new Human('tom', 20);\nconsole.log(man.name); // -\u003e tom\nconsole.log(man.age);\n// -\u003e Property 'age' is private and only accessible within class 'Human'.\n\n```\n\n### 3、接口与构造器签名\n\n当我们的项目中拥有很多不同的类时并且这些类之间可能存在某方面的共同点，为了描述这种共同点，我们可以将其提取到一个接口(interface)中用于集中维护，并使用```implements```关键字来实现这个接口，示例如下：\n\n```js\ninterface IHuman {\n    name: string;\n    age: number;\n    walk(): void;\n}\n\nclass Human implements IHuman {\n    \n    public constructor(public name: string, public age: number) {\n        this.name = name;\n        this.age = age;\n    }\n\n    walk(): void {\n        console.log('I am walking...');\n    }\n}\n```\n\n上述代码在编译阶段能顺利通过，但是我们注意到在```Human```类中包含```constructor```构造函数，如果我们想在接口中为该构造函数定义一个签名并让```Human```类来实现这个接口，看会发生什么：\n\n```js\ninterface HumanConstructor {\n  new (name: string, age: number);    \n}\n\nclass Human implements HumanConstructor {\n    \n    public constructor(public name: string, public age: number) {\n        this.name = name;\n        this.age = age;\n    }\n\n    walk(): void {\n        console.log('I am walking...');\n    }\n}\n// -\u003e Class 'Human' incorrectly implements interface 'HumanConstructor'.\n// -\u003e Type 'Human' provides no match for the signature 'new (name: string, age: number): any'.\n\n```\n\n然而TypeScript会编译出错，告诉我们错误地实现了```HumanConstructor```接口，这是因为当一个类实现一个接口时，只会对实例部分进行编译检查，类的静态部分是不会被编译器检查的。因此这里我们尝试换种方式，直接操作类的静态部分，示例如下：\n\n```js\ninterface HumanConstructor {\n  new (name: string, age: number);    \n}\n\ninterface IHuman {\n    name: string;\n    age: number;\n    walk(): void;\n}\n\nclass Human implements IHuman {\n    \n    public constructor(public name: string, public age: number) {\n        this.name = name;\n        this.age = age;\n    }\n\n    walk(): void {\n        console.log('I am walking...');\n    }\n}\n\n// 定义一个工厂方法\nfunction createHuman(constructor: HumanConstructor, name: string, age: number): IHuman {\n    return new constructor(name, age);\n}\n\nconst man = createHuman(Human, 'tom', 18);\nconsole.log(man.name, man.age); // -\u003e tom 18\n\n```\n\n在上述示例中通过额外创建一个工厂方法```createHuman```并将构造函数作为第一个参数传入，此时当我们调用```createHuman(Human, 'tom', 18)```时编译器便会检查第一个参数是否符合```HumanConstructor```接口的构造器签名。\n\n### 4、声明合并\n在声明合并中最常见的合并类型就是接口了，因此这里先从接口开始介绍几种比较常见的合并方式。\n\n#### 4.1 接口合并\n示例代码如下：\n\n```js\ninterface A {\n    name: string;\n}\n\ninterface A {\n    age: number;\n}\n\n// 等价于\ninterface A {\n    name: string;\n    age: number;\n}\n\nconst a: A = {name: 'tom', age: 18};\n\n```\n\n接口合并的方式比较容易理解，即声明多个同名的接口，每个接口中包含不同的属性声明，最终这些来自多个接口的属性声明会被合并到同一个接口中。\n\n\u003e 注意：所有同名接口中的非函数成员必须唯一，如果不唯一则必须保证类型相同，否则编译器会报错。对于函数成员，后声明的同名接口会覆盖掉之前声明的同名接口，即后声明的同名接口中的函数相当于一次重载，具有更高的优先级。\n\n#### 4.2 函数合并\n函数的合并可以简单理解为函数的重载，即通过同时定义多个不同类型参数或不同类型返回值的同名函数来实现，示例代码如下：\n\n```js\n// 函数定义\nfunction foo(x: number): number;\nfunction foo(x: string): string;\n\n// 函数具体实现\nfunction foo(x: number | string): number | string {\n    if (typeof x === 'number') {\n        return (x).toFixed(2);\n    }\n    \n    return x.substring(0, x.length - 1);\n}\n\n```\n\n在上述示例中，我们对```foo```函数进行多次定义，每次定义的函数参数类型不同，返回值类型不同，最后一次为函数的具体实现，在实现中只有在兼容到前面的所有定义时，编译器才不会报错。\n\n\u003e 注意：TypeScript编译器会优先从最开始的函数定义进行匹配，因此如果多个函数定义存在包含关系，则需要将最精确的函数定义放到最前面，否则将始终不会被匹配到。\n\n#### 4.3 类型别名联合\n类型别名联合与接口合并有所区别，类型别名不会新建一个类型，只是创建一个新的别名来对多个类型进行引用，同时不能像接口一样被```实现(implements)```和```继承(extends)```，示例如下：\n\n```js\ntype HumanProperty = {\n    name: string;\n    age: number;\n    gender: number;\n};\n\ntype HumanBehavior = {\n    eat(): void;\n    walk(): void;\n}\n\ntype Human = HumanProperty \u0026 HumanBehavior;\n\nlet woman: Human = {\n    name: 'tom',\n    age: 18,\n    gender: 0,\n    eat() {\n        console.log('I can eat.');\n    },\n    walk() {\n        console.log('I can walk.');\n    }\n}\n\nclass HumanComponent extends Human {\n    constructor(public name: string, public age: number, public gender: number) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n    }\n    \n    eat() {\n        console.log('I can eat.');\n    }\n    \n    walk() {\n        console.log('I can walk.');\n    }\n}\n// -\u003e 'Human' only refers to a type, but is being used as a value here.\n\n```\n\n### 5、keyof 索引查询\n在TypeScript中的```keyof```有点类似于JS中的```Object.keys()```方法，但是区别在于前者遍历的是类型中的字符串索引，后者遍历的是对象中的键名，示例如下：\n\n```js\ninterface Rectangle {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\ntype keys = keyof Rectangle;\n// 等价于\ntype keys = \"x\" | \"y\" | \"width\" | \"height\";\n\n// 这里使用了泛型，强制要求第二个参数的参数名必须包含在第一个参数的所有字符串索引中\nfunction getRectProperty\u003cT extends object, K extends keyof T\u003e(rect: T, property: K): T[K] {\n    return rect[property];\n} \n\nlet rect: Rectangle = {\n    x: 50,\n    y: 50,\n    width: 100,\n    height: 200\n};\n\nconsole.log(getRectProperty(rect, 'width')); // -\u003e 100\nconsole.log(getRectProperty(rect, 'notExist'));\n// -\u003e Argument of type '\"notExist\"' is not assignable to parameter of type '\"width\" | \"x\" | \"y\" | \"height\"'.\n\n```\n\n在上述示例中我们通过使用```keyof```来限制函数的参数名```property```必须被包含在类型```Rectangle```的所有字符串索引中，如果没有被包含则编译器会报错，可以用来在编译时检测对象的属性名是否书写有误。\n\n### 6、Partial 可选属性\n在某些情况下，我们希望类型中的所有属性都不是必需的，只有在某些条件下才存在，我们就可以使用```Partial```来将已声明的类型中的所有属性标识为可选的，示例如下：\n\n```js\n// 该类型已内置在TypeScript中\ntype Partial\u003cT\u003e = {\n    [P in keyof T]?: T[P]\n};\n\ninterface Rectangle {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}\n\ntype PartialRectangle = Partial\u003cRectangle\u003e;\n// 等价于\ntype PartialRectangle = {\n    x?: number;\n    y?: number;\n    width?: number;\n    height?: number;\n}\n\nlet rect: PartialRectangle = {\n    width: 100,\n    height: 200\n};\n\n```\n\n在上述示例中由于我们使用```Partial```将所有属性标识为可选的，因此最终```rect```对象中虽然只包含```width```和```height```属性，但是编译器依旧没有报错，当我们不能明确地确定对象中包含哪些属性时，我们就可以通过```Partial```来声明。\n\n### 7、Pick 部分选择\n在某些应用场景下，我们可能需要从一个已声明的类型中抽取出一个子类型，在子类型中包含父类型中的部分或全部属性，这时我们可以使用```Pick```来实现，示例代码如下：\n\n```js\n// 该类型已内置在TypeScript中\ntype Pick\u003cT, K extends keyof T\u003e = {\n    [P in K]: T[P]\n};\n\ninterface User {\n    id: number;\n    name: string;\n    age: number;\n    gender: number;\n    email: string;\n}\n\ntype PickUser = Pick\u003cUser, \"id\" | \"name\" | \"gender\"\u003e;\n// 等价于\ntype PickUser = {\n    id: number;\n    name: string;\n    gender: number;\n};\n\nlet user: PickUser = {\n    id: 1,\n    name: 'tom',\n    gender: 1\n};\n\n```\n\n在上述示例中，由于我们只关心```user```对象中的```id，name```和```gender```是否存在，其他属性不做明确规定，因此我们就可以使用```Pick```从```User```接口中拣选出我们关心的属性而忽略其他属性的编译检查。\n\n### 8、never 永不存在\n\n```never```表示的是那些永不存在的值的类型，比如在函数中抛出异常或者无限循环，```never```类型可以是任何类型的子类型，也可以赋值给任何类型，但是相反却没有一个类型可以作为```never```类型的子类型，示例如下：\n\n```js\n// 函数抛出异常\nfunction throwError(message: string): never {\n    throw new Error(message);\n}\n\n// 函数自动推断出返回值为never类型\nfunction reportError(message: string) {\n    return throwError(message);\n}\n\n// 无限循环\nfunction loop(): never {\n    while(true) {\n        console.log(1);\n    }\n}\n\n// never类型可以是任何类型的子类型\nlet n: never;\nlet a: string = n;\nlet b: number = n;\nlet c: boolean = n;\nlet d: null = n;\nlet e: undefined = n;\nlet f: any = n;\n\n// 任何类型都不能赋值给never类型\nlet a: string = '123';\nlet b: number = 0;\nlet c: boolean = true;\nlet d: null = null;\nlet e: undefined = undefined;\nlet f: any = [];\n\nlet n: never = a;\n// -\u003e Type 'string' is not assignable to type 'never'.\n\nlet n: never = b;\n// -\u003e Type 'number' is not assignable to type 'never'.\n\nlet n: never = c;\n// -\u003e Type 'true' is not assignable to type 'never'.\n\nlet n: never = d;\n// -\u003e Type 'null' is not assignable to type 'never'.\n\nlet n: never = e;\n// -\u003e Type 'undefined' is not assignable to type 'never'.\n\nlet n: never = f;\n// -\u003e Type 'any' is not assignable to type 'never'.\n\n```\n\n### 9、Exclude 属性排除\n与Pick相反，Pick用于拣选出我们需要关心的属性，而Exclude用于排除掉我们不需要关心的属性，示例如下：\n\n```js\n// 该类型已内置在TypeScript中\n// 这里使用了条件类型(Conditional Type)，和JS中的三目运算符效果一致\ntype Exclude\u003cT, U\u003e = T extends U ? never : T;\n\ninterface User {\n    id: number;\n    name: string;\n    age: number;\n    gender: number;\n    email: string;\n}\n\ntype keys = keyof User; // -\u003e \"id\" | \"name\" | \"age\" | \"gender\" | \"email\"\n\ntype ExcludeUser = Exclude\u003ckeys, \"age\" | \"email\"\u003e;\n// 等价于\ntype ExcludeUser = \"id\" | \"name\" | \"gender\";\n````\n\n在上述示例中我们通过在```ExcludeUser```中传入我们不需要关心的```age```和```email```属性，```Exclude```会帮助我们将不需要的属性进行剔除，留下的属性```id，name```和```gender```即为我们需要关心的属性。一般来说，```Exclude```很少单独使用，可以与其他类型配合实现更复杂更有用的功能。\n\n### 10、Omit 属性忽略\n在上一个用法中，我们使用Exclude来排除掉其他不需要的属性，但是在上述示例中的写法耦合度较高，当有其他类型也需要这样处理时，就必须再实现一遍相同的逻辑，不妨我们再进一步封装，隐藏这些底层的处理细节，只对外暴露简单的公共接口，示例如下：\n\n```js\n// 使用Pick和Exclude组合实现\ntype Omit\u003cT, K extends keyof T\u003e = Pick\u003cT, Exclude\u003ckeyof T, K\u003e\u003e;\n\ninterface User {\n    id: number;\n    name: string;\n    age: number;\n    gender: number;\n    email: string;\n}\n\n// 表示忽略掉User接口中的age和email属性\ntype OmitUser = Omit\u003cUser, \"age\" | \"email\"\u003e;\n// 等价于\ntype OmitUser = {\n  id: number;\n  name: string;\n  gender: number;\n};\n\nlet user: OmitUser = {\n    id: 1,\n    name: 'tom',\n    gender: 1\n};\n```\n\n在上述示例中，我们需要忽略掉```User```接口中的```age```和```email```属性，则只需要将接口名和属性传入```Omit```即可，对于其他类型也是如此，大大提高了类型的可扩展能力，方便复用。\n\n### 总结\n在本文中总结了几种```TypeScript```的使用技巧，如果在我们的```TypeScript```项目中发现有很多类型声明的地方具有共性，那么不妨可以使用文中的几种技巧来对其进行优化改善，增加代码的可维护性和可复用性。\n\n\n","like_users":[],"create_time":{"$date":"2019-12-18T10:05:11.427Z"},"update_time":{"$date":"2019-12-18T10:05:11.427Z"},"id":27,"__v":0}
{"_id":{"$oid":"5e07092500f3ab003065e40d"},"meta":{"views":37,"likes":0,"comments":0},"keyword":["前端面试"],"desc":"一线大厂前端面试题训练营（一）","numbers":"7055","img_url":"https://upload-images.jianshu.io/upload_images/12890819-80fa7517ab3f2783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","type":1,"state":1,"origin":0,"tags":[],"comments":[],"category":[],"title":"一线大厂前端面试题训练营（一）","author":"golderBrother","content":"# 一线大厂前端面试题 4 天训练营（一）\n\n\u003e 先来几道开胃菜\n\n## 1. 对象(数组)的深克隆和浅克隆（头条）\n\n### JSON.parse(JSON.stringify())缺陷:\n\n- `function、symbol、undefined`会默认被忽略;\n- 正则会被转换成`{}`\n- 日期对象 `Date` 会被转换成 时间传 `\"2019-12-28T06:23:36.880Z\"`\n\n### 深克隆函数\n\n```js\nlet obj = {\n  a: 100,\n  b: [10, 20, 30],\n  c: {\n    x: 10\n  },\n  d: /^\\d+$/,\n  e: function() {\n    console.log(\"e\");\n  },\n  f: undefined,\n  g: Symbol(\"g\"),\n  h: new Date()\n};\n\nlet arr = [\n  10,\n  [100, 200],\n  {\n    x: 10,\n    y: 20\n  }\n];\n\n//=\u003e深克隆\nfunction deepClone(obj) {\n  //过滤特殊情况\n  if (obj === null) return null;\n  if (typeof obj === \"function\")\n    return new Function(\"return \" + obj.toString())();\n  if (typeof obj === \"symbol\") return Symbol(obj.description);\n  if (typeof obj !== \"object\") return obj;\n  if (obj instanceof RegExp) return new RegExp(obj);\n  if (obj instanceof Date) return new Date(obj);\n  // 不直接创建空对象目的：克隆的结果和之前保持相同的所属类\n  let cloneObj = new obj.constructor();\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      cloneObj[key] = deepClone(obj[key]);\n    }\n  }\n  return cloneObj;\n}\n```\n\n**执行结果：**\n\n```js\nobj === obj2; // false\n\nobj.b.push(4); // 4\n\nobj;\n// a: 100\n// b: (4) [10, 20, 30, 4]\n// c: {x: 10}\n// d: /^\\d+$/\n// e: ƒ ()\n// f: undefined\n// g: Symbol(g)\n// h: Sat Dec 28 2019 14:30:21 GMT+0800 (中国标准时间) {}\n\nobj2;\n// a: 100\n// b: (3) [10, 20, 30]\n// c: {x: 10}\n// d: /^\\d+$/\n// e: ƒ ()\n// f: undefined\n// g: Symbol(g)\n// h: Sat Dec 28 2019 14:30:21 GMT+0800 (中国标准时间) {}\n```\n\n## 2. BAT 笔试题中几道关于堆栈内存和闭包作用域的题\n\n### One\n\n```js\n//example 1\nlet a={}, b='0', c=0;\na[b]='前端';\na[c]='超神';\nconsole.log(a[b]); // '超神'\n​\n---------------------\n//example 2\nlet a={}, b=Symbol('1'), c=Symbol('1');\na[b]='前端';\na[c]='超神';\nconsole.log(a[b]); // '前端'\n​\n---------------------\n//example 3\nlet a={}, b={n:'1'}, c={m:'2'};\na[b]='前端';\na[c]='超神';\nconsole.log(a[b]); // '超神'\n```\n\n**分析**：\n\n#### example 1\n\n对象的属性类型一般是字符串类型，非字符串的正常会被转换成`字符串`，所以数值类型的`0`和字符串类型的`'0'`,\n是一样的，所以后面的`'超神'`会覆盖前面的。\n数组是特殊的对象，它的属性是索引，类型是`数值(number)`\n\n#### example 2\n\nSymbol 类型的值就都是独一无二的，可以保证不会与其他属性名产生冲突\n\n#### example 3\n\n这题可以验证 `example 1`, 对象的属性, 如果是非字符串的类型正常会被转换成`字符串`, `object`类型转换成字符串, 会调用愿原型上的 `toString`方法\n\n```js\nlet obj = {};\nobj.toString(); // \"[object Object]\"\n```\n\n所以上面的代码相当于:\n\n```js\nlet a = {},\n  b = { n: \"1\" },\n  c = { m: \"2\" };\na[\"[object Object]\"] = \"前端\";\na[\"[object Object]\"] = \"超神\";\nconsole.log(a[b]); // '超神'\nconsole.log(a); // {[object Object]: \"超神\"}\n```\n\n### Two\n\n```js\nvar test = (function(i) {\n  return function() {\n    alert((i *= 2));\n  };\n})(2);\ntest(5); // 4\n```\n\n**分析**：\n\n`test`接受一个`自执行匿名函数(IIFE)`表达式, 这个 `IIFE` 执行后返回一个新的匿名函数 `function(){alert(i*=2);`, 并且外层 IIFE 构成了一个`闭包`, 因为返回的匿名函数引用外层的变量 `i`, 也就是使用了外层函数的`执行上下文(Executor Context)`,\n所以 test 的值为`function(){alert(i*=2)}`, 并在闭包中声明了一个私有变量`i=2`, 也就是`形参初始化`;\n\n接下来我们执行`test(5)`, 相当于执行 `alert(i*=2)`, 也即是`alert(i = i * 2)`, 所以返回计算后的值`2 * 2 = 4`, 弹出字符串 `4`, 因为 alert 弹出来的值都会被转换成`字符串`;\n\n#### Three\n\n```js\nvar a = 0,\n  b = 0;\nfunction A(a) {\n  // 执行A(1)后,A函数被重写为下面的了\n  A = function(b) {\n    console.log(a + b++);\n  };\n  console.log(a++);\n}\nA(1); // 1 a++ a先返回后自增\nA(2); // 2 + 2 = 4; b++ b先返回后自增\n```\n\n## 3.一道关于面向对象面试题所引发的血案（阿里）\n\n[运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n\n```js\nfunction Foo() {\n  getName = function() {\n    console.log(1);\n  };\n  return this; // 指向window\n}\nFoo.getName = function() {\n  console.log(2);\n};\nFoo.prototype.getName = function() {\n  console.log(3);\n};\nvar getName = function() {\n  console.log(4);\n};\nfunction getName() {\n  console.log(5);\n}\nFoo.getName(); // 2\ngetName(); // 4\nFoo().getName(); // 1 执行 Foo() 后, 函数 getName 被重写为function () {console.log(1);}\ngetName(); // 1\nnew Foo.getName(); // 2\nnew Foo().getName(); // 3 -\u003e (new Foo()).getName() 从左到右执行\nnew new Foo().getName(); // 3 -\u003e new (((new Foo()).getName)()) 从左往右 new (带参数列表) new Foo() -\u003e 成员访问(.getName) -\u003e 函数调用(.getName()) -\u003e new (无参数列表 new )\n```\n\n总结下优先级:\n\n`圆括号 \u003e 成员访问(xxx.xxx) \u003e new (带参数列表 new xxx ( xxx )) \u003e 函数调用(xxx(xxx)) \u003e new (无参数列表 new xxx)`\n优先级相同, **从左到右执行**。\n\n## 4.一道面试题让你彻底掌握 JS 中的 EventLoop（头条）\n\n```js\nasync function async1() {\n  console.log(\"async1 start\");\n  await async2();\n  console.log(\"async1 end\");\n}\nasync function async2() {\n  console.log(\"async2\");\n}\nconsole.log(\"script start\");\nsetTimeout(function() {\n  console.log(\"setTimeout\");\n}, 0);\nasync1();\nnew Promise(function(resolve) {\n  console.log(\"promise1\");\n  resolve();\n}).then(function() {\n  console.log(\"promise2\");\n});\nconsole.log(\"script end\");\n\n// script start\n// async1 start\n// async2\n// promise1\n// script end\n// async1 end\n// promise2\n// setTimeout\n```\n\n**分析**：\n\n这道题考到了`事件循环(Event Loop)`的运行机制(顺序)，可以总结成 `同步任务(主线程) \u003e 异步任务(任务队列：宏任务+微任务)`\n\n这边盗张图\n\n![image](https://img-blog.csdn.net/2018041120124254?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjMjM3NDIzNTUx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n还有一张：\n\n![image](https://img-blog.csdn.net/20180411202638415?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjMjM3NDIzNTUx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n**微任务**有哪些:\n\n- `Promise.then`\n- `process.nextTick(Nodejs)`\n- `MutationObserver`\n- `Object.observe` (废弃)\n- `await下面的代码`, 比如：\n\n  ```js\n  await 1;\n  console.log(\"end\");\n  ```\n\n**宏任务**有哪些:\n\n- `setTimeout、setInterval、setImmediate(Nodejs)`\n- `postMessage、MessageChannel`\n- `IO流、UI 渲染`\n\n\u003e 开胃菜吃完了，是不是得来**实战**几道呢?\n\n### Practice One\n\n```js\nvar x = 2;\nvar y = {\n  x: 3,\n  z: (function(x) {\n    this.x *= x;\n    x += 2;\n    return function(n) {\n      this.x *= n;\n      x += 3;\n      console.log(x);\n    };\n  })(x)\n};\nvar m = y.z;\nm(4); // 7\ny.z(5); // 10\nconsole.log(x, y.x); // 16 15\n```\n\n**分析**：\n\n1. `var m = y.z;`\n   匿名函数 `function(){this.x*=n;x+=3;console.log(x);}`\n\n2. `m(4)`\n   匿名函数的 x 来源于全局中的 x, `x+=3 -\u003e x=x+3 -\u003e 7`,这边是直接执行的，所以 this 执行 window，因此里面的 this.x*=x 相当于更改了全局的 x, ```thix.x = 4 * 4 = 16```\n\n3. `y.z(5)`\n   这边通过`y.z`来调用 `function(){this.x*=n;x+=3;console.log(x);}` 这个函数，所以这里面的`this隐式指向了y`，并且这边构成了`闭包`，引用了外层函数的 x，也就是 7, 7+3=10;然后 this.x*=x 相当于更改了 y 对象的 x, thix.x = 3 * 5 = 15\n\n### Practice Two\n\n```js\nvar x = 0,\n  y = 1;\nfunction fn() {\n  x += 2;\n  fn = function(y) {\n    console.log(y + --x);\n  };\n  console.log(x, y);\n}\nfn(3); // 2 1\nfn(4); // 4 + (--2) =\u003e 4 + 1 =\u003e 5；注意：这边fn重新赋值了个新的函数，里面的y是私有变量，不要跟全局的y搞混淆了;并且这边 --x，所以全局的x更新为1\nconsole.log(x, y); // 1 1\n```\n\n### Practice Three\n\n```js\nsetTimeout(() =\u003e {\n  console.log(1);\n}, 20);\nconsole.log(2);\nsetTimeout(() =\u003e {\n  console.log(3);\n}, 10);\nconsole.log(4);\nconsole.time(\"AA\");\nfor (let i = 0; i \u003c 90000000; i++) {\n  // do soming\n}\nconsole.timeEnd(\"AA\"); //=\u003eAA: 79ms 左右\nconsole.log(5);\nsetTimeout(() =\u003e {\n  console.log(6);\n}, 8);\nconsole.log(7);\nsetTimeout(() =\u003e {\n  console.log(8);\n}, 15);\nconsole.log(9);\n\n// 2 4 AA: 38.399169921875ms 5 7 9\n// 3 1 6 8\n```\n\n**分析**：\n这是一道很简单的`事件循环`机制问题:\n这么记住就行，**同步任务 \u003e 异步任务(setTimeout)**\n\n**扩展知识**\nHTML5 标准规定\n\n- `setTimeout`的最短时间间隔是`4毫秒`；\n- `setInterval`的最短间隔时间是`10毫秒`，也就是说，小于 10 毫秒的时间间隔会被调整到 10 毫秒\n\n## 9. 最后\n\n文中所有的代码及测试事例都已经放到我的 [GitHub](https://github.com/GolderBrother/learn-and-collect/blob/master/FE-Interview/demo1.md) 上了。\n\n觉得有用 ？喜欢就收藏，顺便点个赞吧，你的支持是我最大的鼓励！\n","like_users":[],"create_time":{"$date":"2019-12-28T07:49:57.053Z"},"update_time":{"$date":"2019-12-28T07:49:57.054Z"},"id":28,"__v":0}
{"_id":{"$oid":"5e0b6abf00f3ab003065e410"},"meta":{"views":89,"likes":0,"comments":0},"keyword":["2019年终总结 "],"desc":"菜鸡的2019年终总结 - 牢记使命，始终不渝，何以解忧，唯有暴富","numbers":"6842","img_url":"https://upload-images.jianshu.io/upload_images/12890819-d2f96122f7248ee9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","type":1,"state":1,"origin":0,"tags":[{"$oid":"5e0b6a1f00f3ab003065e40e"}],"comments":[],"category":[{"$oid":"5e0b6a2700f3ab003065e40f"}],"title":"菜鸡的2019年终总结 - 牢记使命，始终不渝，何以解忧，唯有暴富","author":"golderBrother","content":"# 菜鸡的2019年终总结 - 牢记使命，始终不渝，何以解忧，唯有暴富\n\n![img](http://img.golderbrother.cn/img1.png)\n\n这是我首次想写年终总结，所以内容可能还包含去年的，因为没得写...\n各位靓仔靓妹，不喜勿喷😅。\n\n岁月更迭，四季轮回，不知不觉，2019就要过去。\n\n这人呐，就是这样，越长大，越觉得时间飞速，时光总是在推着我们不断前进。\n\n又到总结一年成长的时刻，我 2019 的关键词是：牢记使命，始终不渝，何以解忧，唯有暴富。\n\n## 为什么想写年终总结\n\n我之所以坚持写是有原因的，特别是要写自己已经做成功的事情。\n\n那些在所成就的人，很多都有纪录自己做成功的事情的习惯，有些是每天都纪录，也些是每月或者每年纪录一次。\n\n因为自己每做成一件事，会给自己增加自信心，自己做成的事情越来越多，自信心就越足。\n\n而且当自己遇到困难、或者感觉做不成某些事件的时候，自己就可以从以往的成功事件中找到信心，做成某些困难事情的成功率就越高。\n\n而且人越自信，做成功的事情会越多，这样形成了一个正向循环。\n\n## 回顾 2019 计划所做的事(技术方面的)\n\n### 1. 完成了自己的个人博客[完成]\n在平常的技术学习中，主要的学习途径为一些优秀大佬们的博客、公众号之类的，真心觉得写的不错，很好理解入门，对我的帮助挺大，只不过得动手实操。于是乎，我就萌生了做博客的想法，一方面为自己学习的技术做个实战应用，另一方面方便记录平常的疑点问题和新技术等。技术栈采用了**eggjs+react+antd**，用了**nginx**和**docker**来部署，使用**github**的**webhook**实现了**CI/CD**。\n\n[博客传送门,来吧](http://golderbrother.cn/)\n\n### 2.深入vue技术栈源码和底层实现(40%)\n这是在这个月开始的，跟着某位**一年多经验大佬**的[逐行剖析 Vue.js 源码](https://nlrx-wjc.github.io/Learn-Vue-Source-Code/start/#_1-%E5%89%8D%E8%A8%80)学习的，站在巨人的肩膀就是不一样，虽然不能完全掌握，起码作为初学者还是很容易入门的。\n\n### 3.node技术学习与实战(60%)\n其实从2018年下半年就开始踏上node之路，断断续续的学着，主要是做api数据服务层，从刚开始的express，到koa2，再到egg.js，深切感受到nodejs技术栈发展快速，做了几个demo放到[github](https://github.com/GolderBrother/blog-node-egg)上，就算学会了的赶脚😅，为以后快速开发当个模型参考吧哈哈。 \n\n### 4. github 修炼之路\n从19年3月份开始，由于前端的**寒冬**，一没**背景**，二没**颜值**的我，促使我不得不开始经营下[github](https://github.com/GolderBrother)。\n我的 2019 GitHub 年度报告: [快，你的 2019  GitHub 年度报告还没领取！](https://githubreport.mdnice.com/?username=GolderBrother\u0026from=timeline)\n\n如果你想看自己的 GitHub详解报告，可以通过上面的文章中获取到报告地址，还有各种数据分析的地址哦。\n\n做前端这几年，今年是在 GitHub 上最活跃的一年。对于所学技术的一个实战应用，做了很多个demo提交上去了，虽然Star很少，主要是为了自己以后的模型参考做积累。\n\n数据如下：\n\n![img](http://img.golderbrother.cn/github_commit.png)\n\n但我的技术还很弱，还有很长很长的路要走。\n\n对的事情，只要你坚持，就一定会有收获。\n\n![image](http://img.golderbrother.cn/img2-1.webp)\n\n### 5. 学习Java，并做个demo[打脸]\n由于工作项目中完全用不到，平时时间也都集中在前端方面，因此只是简单的看了下**某马**的**JavaSE**视频，然后假装学过了，讨个心理安慰。。\n\n## 工作\n\n![img](http://img.golderbrother.cn/img2-2.webp)\n\n今年 11 月份的时候，换了东家，因为在原来的东家，技术氛围不是很满意，我能提升的空间真的不大。但是老东家的好处是，我做的项目都是从0到1开始，这给了我很大的锻炼机会。\n\n这次换工作，我的 **个人博客** 和 以及**项目经验**的积累 给了我很大的助力。\n\n现在的公司，还可以，发现身边很多优秀的人，很多先行者，能学习到的东西很多。\n\n虽然离当初想找的公司还有一点点差距，最主要当初的自己还是比较心急了，实力还是不太够，还是得一步一个脚印的稳定前行。\n\n![img](https://mmbiz.qpic.cn/sz_mmbiz_png/icLlxzKkLGIed1LWB3EicP1XibM9XpcMMibD4UYR1uVMsl7ibGl6u2XU8l3nJkOQk7wmhFs0FAOqukibcfNq565ib8UVQ/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n现在公司用到的前端技术栈是前端三大框架 + egg 中间层 ，也是我想专注的方向。\n\n总的来说，项目不是很急，还是比较满意的。\n\n这边要感谢 2019 年里给过我帮助的所有人，相信一切都是最好的选择。\n\n![img](http://img.golderbrother.cn/img3_new.webp)\n\n当你越来越优秀，看到的风景也会越来越不一样，你的格局也会不一样。\n\n![img](http://img.golderbrother.cn/img4_new.webp)\n\n## 阅读\n很失败，我是一个名副其实的**收藏=看完**党，收藏多了，看的并不多，看看我收藏了多少书籍：\n\n![img](http://img.golderbrother.cn/book1.jpg)\n\n![img](http://img.golderbrother.cn/book2.jpg)\n\n但其实也是有略微看了一点，悟出了一些道理。\n\n今年是意识到读书有用，非常有用的一年，早点知道，就会少走很多弯路。\n\n读书对于开放格局非常有帮助，很多前人，历史的经验都在里面。\n\n很多聪明人经常把这两句话挂在嘴边：**选择大于努力**。\n\n但在我看来，**正确选择的本身就需要十倍的努力！**\n\n- 请不要用战术上的勤奋代替战略上的懒惰！努力提升自己的认知才是王道。\n\n- 很多人都是这样，坚持不了短期吃苦，但坚持长期吃苦却坚持的很好。\n\n- 多读书，多开拓思维，提高认知，不要人生过半才发现一手好牌被自己打的稀巴烂。\n\n## 花小钱学习买时间\n\n今年总是觉得时间不够用，真的不够用，所以花钱小来学习买时间。\n\n- 珠峰视频课程, 花了300块\n- 掘金上，买了几本小册，花了几十块\n- 其他，不记得了\n\n在如今信息泛滥的时代，你接收到的有效信息越多，提升的认知越多，你拥有的财富就越多。\n\n\u003e ★ 你永远赚不到，超出你认知范围外的钱，除非你靠运气，但是靠运气赚到的钱，最后往往又会靠实力亏掉，这是一种必然。\n\n\u003e 你所赚的每一分钱，都是你对这个世界认知的变现，你所亏的每一分钱，都是因为对这个世界的认知有缺陷。\n\n\u003e 这个世界最大的公平在于：当一个人的财富大于自己的认知时，这个社会有100种方法收割你，直到你的认知和财富相匹配为止。\n\n学习、挣钱、花钱再到学习，形成一个正向循环。\n\n年轻人最值钱的是时间，最缺的也是时间！当然很多人的时间并不值钱。\n\n所以我总是投资我自己，精进自己的专业技能。\n\n在经济允许的范围内，在自己身上投资不要省钱，把自己当做一个产品，你是你这一生最好的产品。\n\n有这个意识，其实哪些钱该花，哪些钱不该花你就清楚了。\n\n![img](https://mmbiz.qpic.cn/sz_mmbiz_jpg/icLlxzKkLGIed1LWB3EicP1XibM9XpcMMibDD5x55ib5GXBTrIcW7bQI3NyndKcq8gMHEHDvvOdkq8qzzlo8xZibgOew/640?wx_fmt=jpeg\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n## 恣意生长\n\n我总觉得反正还年轻，我非常不愿意过早的定义自己是个干啥的。\n\n做为一个前端开发技术人员，技术对我来说重要吗 ？重要！非常重要！毕竟这是我谋生的技能！\n\n技术一般也只能用 5 - 10 年而已，但是相比于人的一生，真的非常短。\n\n我业余时间的 80% 都花在技术的精进上，其余的 20% 花在提升自己的软技能上，花在有时间复利效应的事情上，比如 读书、学习理财、提升认知、健身、运动 等等。\n\n所以花自己业余时间的 20% 的时间来培养一个能长期有用并且有复利效应的技能非常重要。\n\n\u003e ★ 把时间拉短，你现在所做的事情，其实没你想像的那么重要！把时间拉长，你现在所做的事情，其实比你想象的更加重要!\n\n这两年，35 岁危机不绝于耳，我觉得没有拥有一个长期有用的技能是其中一个重要原因！\n\n真的到了 35 岁了，我觉得那时的我有足够的资本，根本不用担心所谓的 35 岁中年危机。\n\n我觉得 35 岁应该是财富积累最容易的时候，因为那时的你，拥有了自己的人脉，应该对你所在的行业或者这个社会的规则有了一定的了解，想挣钱应该是比较容易的事，\n\n一定要告诉自己：现在才刚开始，别太着急给自己定型，别太着急给自己设限，多发掘自己的兴趣和才能，恣意生长，世界很大，路还很长\n\n![img](http://img.golderbrother.cn/img6.webp)\n\n其实说了那么多，我都是在瞎 BB 啦，其实我想的是下图的，哈哈哈~\n\n![img](http://img.golderbrother.cn/img7.webp)\n\n![img](http://img.golderbrother.cn/img8.webp)\n\n\u003e ★ 有人住高楼，有人在深沟，有人光万丈，有人一身锈， 世人万千种，浮云莫去求，斯人若彩虹，遇上方知有。—— 韩寒\n\n在没有遇到那个属于你的彩虹之前，修炼自己，不为迎合谁，按自己心之所向扎扎实实去努力，积累来自于心底的自信，待那个人出现之时，能以势均力敌的姿态站在 TA 身旁，毕竟，棋逢对手才好玩儿，才会走得更长远，不是吗 ？\n\n![img](https://mmbiz.qpic.cn/sz_mmbiz_png/icLlxzKkLGIed1LWB3EicP1XibM9XpcMMibDSdsMicKHCoN32nyyGOWjyZRrdpleribFOTxDVWcl5UlbCrm0jtepmh6g/640?wx_fmt=png\u0026tp=webp\u0026wxfrom=5\u0026wx_lazy=1\u0026wx_co=1)\n\n## 运动\n\n\u003e ★ 身体是一，金钱、地位、荣誉则是零。只有有了前面的一，后面的零才会有用。反之，则都是做了无用功。\n\n2019 年，996 和修改福报的话题不绝于耳，大家对工作与家庭与健康的重视程度都加深了。\n\n我一直都把健康放在第一位，可以看下我写的那篇：程序员不止眼前的逻辑和代码，还应有健康的体魄和精气神。\n\n这一年来，还是和往年一样，时不时会进行各种运动。\n\n- 跑步平均 5 次 / 每月，5 公里左右 / 每次；\n\n- 在新东家，上下班基本是骑单车：\n  - 骑行平均 2 次 / 每天。\n\n今年总共跑了**250公里**，感觉并不多\n\n![img](http://img.golderbrother.cn/running.jpg)\n\n不间断的运动已经成为了一种习惯，或者可以说是一项兴趣了，非常棒。\n\n正因为一直有不间断的运动，所以这一年来几乎没有感冒过，身体健康，真的很棒。\n\n2019 年跑步最远的一次：\n\n![img](http://img.golderbrother.cn/running1.jpg)\n\n这是当时发的朋友圈，哈哈哈~\n\n![img](http://img.golderbrother.cn/running2.jpg)\n\n听到一次次的打破记录，哈哈哈，贼激动的，\n\n我的朋友圈里一堆跑步忒快的人，耐力贼好，还有参加马拉松的人(话说我明年的厦马可以尝试下了)。\n\n不过我还是坚持自己，只要以保持身体健康为目的，不用太刻意，身体自然健康、好身材也自然会来。\n\n2019 结束了，良好的身材也还在，哈哈哈~\n\n那个，因为颜值太高，身材太好了，朋友说不放出来的好，所以完美的健身照就不放出来了，不然酸了屏幕就不好了。\n\n![img](http://img.golderbrother.cn/img10.webp)\n\n当运动成为一种习惯，终将会是受益一生的事情。\n\n一个身心健康的人，对待这个世界才会更平和。\n\n当一个男生开始早睡早起，开始投资自己，戒烟戒酒，每天健身学习，走路开始抬头挺胸，一心向前，你猜他是为了什么 ？\n\n- 泡妞 ？\n- 泡更靓的妞 ？\n- 为了配上更好的她 ？\n- 为了家庭无后顾之忧 ？\n- 为了下一代 ？\n- 为了将来不因为钱而必须作出取舍 ？\n- 为了做更好的自己 ？\n- 为了自己的梦想，作出最大的努力 ？\n- 以上部分 ？\n- 以上全部 ？\n我的答案很简单，想知道是什么吗 ？\n\n就不告诉你，你猜，嘻嘻 😉。\n\n## 旅游\n\n今年压根算不上什么旅游，但是也总结下吧\n\n国庆前几天回老家，跟老友相聚泉州，逛了下闽台缘，重温泉州故事，铭记历史, 珍惜现在~~\n\n![img](http://img.golderbrother.cn/mintaiyuan1.jpg)\n\n![img](http://img.golderbrother.cn/mintaiyuan2.jpg)\n\n\n后面几天重游鼓浪屿，上次是4年前上大三的时候，此次重游另有风味~\n\n![img](http://img.golderbrother.cn/gulangyu1.jpg)\n\n![img](http://img.golderbrother.cn/gulangyu2.jpg)\n\n![img](http://img.golderbrother.cn/gulangyu3.jpg)\n\n## 期望 2020\n\n2020 的目标\n\n- 继续深入 ```Vue``` 技术栈的原理与内在实现\n- 深入 ```React``` 技术栈的原理与内在实现\n- 深入 ```TypeScript、Flutter``` 技术栈\n- 学习英语，目标词汇量达到 **2000+**\n- 保持运动，常跑步, 争取跑到**600公里**\n- 坚持技术积累，写博客\n- 多阅读(重要)，不多，就**10本**吧\n- 掌握**摄影**技术\n- 学习做菜\n- 多做持续、延迟满足和有复利效应的事情\n- 做一个有**有趣**的人！\n哦，还有两个：\n\n- 暴富！暴富！暴富！在线等那种！\n- 等国家给我发一个女朋友，在线等那种！\n\n嗯，最后两个目标才是重点，很重要！非常重要！特别重要！\n\n![img](http://img.golderbrother.cn/img11.webp)\n\n虽说有些目标说出来了，反而实现不了，所以有些目标不要立的好，心里知道就好。\n\n嗯，是的啊，我的目标是立来打脸的，所以坐看明年打脸 🤩。\n\n![img](http://img.golderbrother.cn/img12-1.gif)\n\n## 总结\n\n二十多岁的年纪，虽是一无所有的年纪，但也是人生最美好的年纪，是当前人生中烦恼最少的年纪。\n\n越长大，烦恼肯定越多，特别是成家立室之后，烦恼更多。\n\n也没几年可以洒了啊，当珍惜当下。\n\n总的来说：2019 年虽有遗憾，但过得充实，过得自在。\n\n我们都生活在阴沟里，但仍有人仰望星空。\n\n对未来还很有信心，我相信我可以。\n\n愿世界美好，与你环环相扣。\n\n时光正好，未来还有无限可能!\n\n白日梦如下：\n\n![img](http://img.golderbrother.cn/img13.gif)\n\n不管如何，2019已过去，2020继续加油呀！","like_users":[],"create_time":{"$date":"2019-12-31T15:35:27.130Z"},"update_time":{"$date":"2019-12-31T15:35:27.130Z"},"id":29,"__v":0}
{"_id":{"$oid":"5fd5827c1416910030d4d80e"},"meta":{"views":1,"likes":0,"comments":0},"keyword":["2020 - 2021 年 Web 前端最新导航 - 前端学习资源分享\u0026前端面试资源汇总"],"desc":"2020 - 2021 年 Web 前端最新导航 - 前端学习资源分享\u0026前端面试资源汇总","numbers":"7993","img_url":"https://upload-images.jianshu.io/upload_images/12890819-bd1f7e81ecad084f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","type":1,"state":1,"origin":0,"tags":[],"comments":[],"category":[{"$oid":"5dd6004b00f3ab003065e3fe"}],"title":"2020 - 2021 年 Web 前端最新导航 - 前端学习资源分享\u0026前端面试资源汇总","author":"golderBrother","content":"国庆这几天，我收集了大量可以显著提升开发效率的前端导航链接。\n\n这些导航链接对我很有帮助，希望对你也是如此。\n\n这些好用的导航链接都已经部署到这个网站 [https://www.kwgg2020.com](https://www.kwgg2020.com/) 上了，在这里食用更美味哦。\n\n\u003e 笔者博客地址：https://github.com/biaochenxuying/blog\n\n## JavaScript\n\n- [JavaScript 教程](https://wangdoc.com/javascript/)\n- [ES6 入门教程](https://es6.ruanyifeng.com/)\n- [JavaScript 30](https://javascript30.com/) 使用原生 JavaScript 在 30 天内完成 30 个项目\n- [Codewars](https://www.codewars.com/) 和其他人一起完成真实的代码挑战，提升你的技术\n- [JavaScript 教程](https://zh.javascript.info/) 现代 JavaScript 教程\n- [优秀的JS代码规范](https://github.com/ryanmcdermott/clean-code-javascript)\n- [开发的宝藏项目](https://github.com/dexteryy/spellbook-of-modern-webdev)\n- TypeScript 教程：https://github.com/xcatliu/typescript-tutorial\n- Node.js学习 https://blog.poetries.top/node-learning-notes/\n\n## CSS\n\n- [css的各种效果实现](https://lhammer.cn/You-need-to-know-css/#/zh-cn/) css的各种效果实现（尤其是动画效果）\n- [CSS Inspiration](https://github.com/chokcoco/CSS-Inspiration) 在这里找到写 CSS 的灵感\n- [CSS 常用样式](https://github.com/QiShaoXuan/css_tricks) 总结一些常用的 CSS 样式\n- [Animate.css](https://animate.style/) 开箱即用的跨浏览器 CSS 动画效果\n- [animista](http://animista.net/) 按需定制 CSS 动画效果\n- [SpinKit](https://tobiasahlin.com/spinkit/) 汇集了实现各种加载效果的 CSS 代码片段\n- [CSS Minifier](https://cssminifier.com/) 在线 CSS 代码极简化/压缩工具\n- https://sass.bootcss.com/documentation Sass 是成熟、稳定、强大的 CSS 扩展语言\n- https://less.bootcss.com/ 一种将css赋予了动态语言特性的动态样式语言\n- https://stylus-lang.com/ 富有表现力、动态、健壮的CSS\n\n## 算法\n\n- JavaScript 算法与数据结构：https://github.com/trekhleb/javascript-algorithms\n- leetcode解题之路：https://github.com/azl397985856/leetcode\n- 五分钟学算法：https://github.com/MisterBooo/LeetCodeAnimation\n\n- LeetCode题目的思路 https://github.com/MisterBooo/LeetCodeAnimation 用动画的形式呈现解LeetCode题目的思路。\n\n- 极客时间 App 的《数据结构与算法之美》\n- GitHub 上 170K+ Star 的前端学习的数据结构与算法项目 https://github.com/biaochenxuying/blog/issues/43\n- JavaScript 数据结构与算法之美 - 十大经典排序汇总: https://github.com/biaochenxuying/blog/issues/42\n- 算法可视化工具 https://github.com/algorithm-visualizer/algorithm-visualizer 算法可视化工具是一个交互式的在线平台，可以从代码中可视化算法。\n\n- 算法可视化来源 https://visualgo.net/en\n- 观察算法的工作方式 https://github.com/skidding/illustrated-algorithms 变量和操作的可视化表示增强了控制流和实际源代码。\n\n## 前端面试\n\n- 前端面试常考问题整理，按模块知识点分类：https://blog.poetries.top/FE-Interview-Questions/\n- 前端开发面试题: https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions\n- web前端面试宝典：https://github.com/h5bp/Front-end-Developer-Interview-Questions/\n- 掘金前端面试题合集：https://github.com/shfshanyue/blog/blob/master/post/juejin-interview.md\n- 前端面试图谱：https://yuchengkai.cn/docs/zh/\n- GitHub 上 100K+ Star 的前端面试开源项目汇总 https://github.com/biaochenxuying/blog/issues/47\n\n## 技术社区\n\n- GitHub：https://github.com/ 高质量的内容创作和分享平台\n- stackoverflow：https://stackoverflow.com/ 一个回答技术问题的网站\n- 掘金：https://juejin.im/ 目前来看，国内的很多优质前端文章，都在掘金上。\n- 博客园：https://www.cnblogs.com/ 一个很纯粹的技术博客平台。\n- 知乎：https://www.zhihu.com/ 很多做技术的同学也开始玩知乎了，阿里的不少前端大牛在知乎上就非常活跃。\n- CSDN：https://www.csdn.net/ 广告太多，但奈何你这么老牌。\n- segmentfault：https://segmentfault.com/ 比较低调的技术博客平台。\n- v2ex：https://www.v2ex.com/ 一个关于分享和探索的地方\n- http://cnodejs.org/ Node.js专业中文社区\n- https://www.smashingmagazine.com/ 一个web技术类的博客杂志站点\n- https://www.jstips.co/ 每天推出一个JS技巧的网站\n- W3cplus：https://www.w3cplus.com/ 是一个致力于推广国内前端行业的技术博客\n- 印记中文 - https://docschina.org/ 印记中文是最权威是技术中文文档社区\n- 收集优质的中文前端博客：https://github.com/FrankFang/best-chinese-front-end-blogs\n\n## 博客团队\n\n- 腾讯AlloyTeam：http://www.alloyteam.com/\n- 腾讯社交用户体验ISUX：https://isux.tencent.com/\n- 淘宝FED | 淘宝前端团队：http://taobaofed.org/\n- 阿里巴巴国际UED：http://www.aliued.com/\n- 京东 | 凹凸实验室：https://aotu.io/\n- 饿了么前端:https://zhuanlan.zhihu.com/ElemeFE\n- 百度前端研发部FEX：http://fex.baidu.com/\n- 360 | 奇舞团：https://75team.com/\n- 美团技术团队: https://tech.meituan.com/\n\n## GitHub 统计\n\n- GitHub 中文排行榜、高分优秀中文项目：https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts\n- GitHub 全球排名：https://gitstar-ranking.com/ 这个排名很权威。如果你的项目超过 10k star，就能上榜，跻身全球 GitHub 项目前1000名。\n\n## 构建\n\n- NPM：https://www.npmjs.com/\n- Yarn：https://yarnpkg.com/zh-Hans/\n- Webpack：https://webpack.js.org/\n- Gulp：https://www.gulpjs.com.cn/\n- Babel：https://babeljs.io/\n- ESLint：https://cn.eslint.org/ 可组装的JavaScript和JSX检查工具。\n- PostCSS：https://www.postcss.com.cn/ 用 JavaScript 工具和插件转换 CSS 代码的工具\n\n## 部署\n\n- [GitHub Pages](https://pages.github.com/) GitHub 提供的免费静态网站托管服务\n- [Netlify](https://www.netlify.com/) 30 秒内部署你的网站\n- [Vercel](https://vercel.com/) 快速部署你的网站\n- [Surge](https://surge.sh/) 只需一个命令就可以发布你的网站\n- [Heroku](https://www.heroku.com/) 在云端构建、运行你的应用\n\n## 静态站点搭建工具\n\n- Hexo：https://hexo.io/zh-cn/\n- VuePress：https://www.vuepress.cn/\n- GitBook：https://www.gitbook.com/\n\n## 前端代码规范\n\n- 腾讯的 http://tgideas.qq.com/doc/index.html\n- 京东的 https://guide.aotu.io/index.html\n\n- Bootstrap编码规范：https://codeguide.bootcss.com/\n- es6编程风格：http://es6.ruanyifeng.com/#docs/style\n- Airbnb Javascript Style Guide：https://github.com/airbnb/javascript\n- [ESLint](https://eslint.org/) 检测、修正 JavaScript 代码的问题\n- [Prettier](https://prettier.io/) 格式化 JavaScript 代码\n\n## 调试抓包\n\n- whistle：https://wproxy.org/whistle/ 代理抓包工具，很好很强大。\n- Fiddler：https://www.telerik.com/fiddler 代理抓包工具。\n- Easy Mock：[https://www.easy-mock.com](https://www.easy-mock.com/)\n\n## 开发工具\n\n- VS Code：https://code.visualstudio.com/\n- Sublime Text：https://www.sublimetext.com/\n- WebStorm：https://www.jetbrains.com/webstorm/\n- Atom：https://atom.io/\n\n## 在线工具\n\n- CodePen - https://codepen.io/ 在线代码测试工具\n\n- Can I use - https://caniuse.com/ Web前端兼容性列表\n- TinyPNG - https://tinypng.com/ PNG/JPG 图片在线压缩利器\n- CNZZ站点统计 - https://www.umeng.com/ 国内常用的站点统计工具\n\n## 前端大会\n\n- Vue.js开发者大会 https://fequan.com/ Vue.js开发者大会中国\n- 中国JS开发者大会 https://jsconfchina.com/ 一场专注于JavaScript和Node.js技术的国际性大会\n- 中国CSS开发者大会 https://css.w3ctech.com/ 提高css开发姿势的大会\n- D2前端技术论坛 http://d2forum.alibaba-inc.com/ 阿里巴巴举办，分享技术的乐趣，探讨行业的发展\n\n## 图标\n\n- Font Awesome：http://www.fontawesome.com.cn/ 网站开发最流行的图标集\n- [Feather](https://feathericons.com/) 简洁美观的开源图标\n- [Ionicons](https://ionicons.com/) 精心绘制的开源图标\n- [Simple Icons](https://simpleicons.org/) 常见品牌的 SVG 图标\n- [Material Design Icons](https://material.io/resources/icons/) 轻快、精美的符号图标，包括常见操作和事项\n- [Tabler Icons](https://tablericons.com/) 681 枚可定制的开源 SVG 图标\n\n## 色彩\n\n- [Material Design Colors](https://www.materialui.co/colors) Material Design 色彩\n- [Flat UI Colors 2](https://flatuicolors.com/) 14 组配色、280 种颜色\n- [Color Hunt](https://colorhunt.co/) 分享色彩搭配的自由开放平台，包括成千上万人工选取的配色，可以从中获取配色的灵感\n- [Color Space](https://mycolor.space/) 配色方案、CSS 颜色渐变生成工具\n- [uiGradients](http://www.uigradients.com/) 美观的颜色渐变\n- [Colors and Fonts](https://colorsandfonts.com/) 色彩和字体工具\n- [Coolors](https://coolors.co/) 配色方案生成工具\n\n## 插画\n\n- [Undraw](https://undraw.co/illustrations) 持续更新的精美的 SV\u0008G 插画集\n- [manypixels](https://gallery.manypixels.co/) 免费插画集\n- [IRA Design](https://iradesign.io/gallery/illustrations) 通过调配渐变色、搭配手绘组件定制插画\n- [Free Illustrations by Lukasz Adam](https://lukaszadam.com/illustrations) 免费 SVG 插画\n- [Blobmaker](https://www.blobmaker.app/) 在线 SVG 形状生成器\n- [Get Waves](https://getwaves.io/) 在线 SVG 波形生成器\n\n## 图片\n\n- [Unsplash](https://unsplash.com/) 可供免费使用的图片\n- [Pexels](https://www.pexels.com/) 精美的免费图片和视频\n- [Burst](https://burst.shopify.com/) 免费高分辨率图片，可用于网站和商业用途\n- [ISO Republic](https://isorepublic.com/) 使用 CC0 许可的免费高分辨率图片和视频\n- [Pixabay](https://pixabay.com/) 令人惊叹的免费（公共领域）图片和视频站点\n- [StockSnap.io](https://stocksnap.io/) 精美的免费图片，同样使用 CC0 许可\n- [Photopea](https://www.photopea.com/) 在线图片编辑工具，支持大量高级功能\n- [Online Image Compressor](https://imagecompressor.com/) 在线图片压缩工具，一次可以压缩多达 20 张图片\n- [Bulk Resize Photos](https://bulkresizephotos.com/en) 最快的在线图片缩放工具（图片缩放和压缩在本地完成，无需上传到服务器）\n\n## 其他\n\n- 单元测试：https://github.com/goldbergyoni/javascript-testing-best-practices\n- [web.dev](https://web.dev/measure/) 评测网站性能（基于 Lighthouse）\n- [Shape Divider](https://www.shapedivider.app/) 定制各种形状的网站分区 SVG 的工具\n- [GTmetrix](https://gtmetrix.com/) 网页性能分析工具\n- [Can I Use](https://caniuse.com/) 前端技术的浏览器支持情况\n- [Carbon](https://carbon.now.sh/) 代码转图片工具\n- [Wappalyzer](https://www.wappalyzer.com/) 检测某个网站使用的技术栈\n\n## 设计工具\n\n- **墨刀**：原型设计工具。网址：https://modao.cc/\n- **蓝湖**：一款产品文档和设计图的在线协作平台。网址：[https://lanhuapp.com](https://lanhuapp.com/)\n- **PxCook（像素大厨）**：高效易用的自动标注工具。软件下载链接：https://www.fancynode.com.cn/pxcook","like_users":[],"create_time":{"$date":"2020-12-13T02:54:52.761Z"},"update_time":{"$date":"2020-12-13T02:54:52.761Z"},"id":30,"__v":0}
{"_id":{"$oid":"5fd5831d1416910030d4d80f"},"meta":{"views":2,"likes":0,"comments":0},"keyword":["共克时艰！150+ 本技术类常用电子书开源了，免费下载，包括 前端、后端、数据结构与算法、计算机基础、设计模式、数据库等书籍"],"desc":"共克时艰！150+ 本技术类常用电子书开源了，免费下载，包括 前端、后端、数据结构与算法、计算机基础、设计模式、数据库等书籍","numbers":"3802","img_url":"https://upload-images.jianshu.io/upload_images/12890819-3a7d6ee6564f9407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240","type":1,"state":1,"origin":0,"tags":[{"$oid":"5dd6004100f3ab003065e3fd"}],"comments":[],"category":[{"$oid":"5dd6004b00f3ab003065e3fe"}],"title":"共克时艰！150+ 本技术类常用电子书开源了，免费下载，包括 前端、后端、数据结构与算法、计算机基础、设计模式、数据库等书籍","author":"golderBrother","content":"\u003e **读一本好书，就是在和高尚的人谈话**。 ——歌德\n\n\u003e **喜欢读书的人在死之前，活过 1000 次，不读书的人只活过一次**。 -- 乔治 R.R. 马丁\n\n最近因为这个新型冠状病毒，大家在家里有没有学习 ？是不是发霉了呢，或者像如下这状态 ？\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-d9036d3ed5fe04ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-83c73a1bd7d0a6e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我管你是不是呢！\n\n不过我找到了一个帮助你打发时间的方法：学习！看电子书！还是多达 150+ 本等着你！\n\n项目地址：https://github.com/biaochenxuying/awesome-books\n\n## 简介\n\n技术类精华电子书整理，并且附带下载链接，包括 前端、后端、数据结构与算法、计算机基础、设计模式等书籍。\n\n计算机类的书籍那么贵，作为一个几个小时看完一本书且机不离身的程序员，天天买纸质书是不可能的了，所以对电子书的需求量还是挺多的。\n\n为了方便广大的小伙伴也能方便找到对应的电子书，我花费洪荒之力收集了 150+ 本精华电子书。\n\n并且为了解决百度云链接容易失效的问题，我把电子书全部下载打包上传到 GitHub 了，都有哪些电子书呢？\n\n请往下看。\n\n## 目录\n\n### 网络\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-8d475384a50263cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 算法\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-79b2e0a925d267b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 前端\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-b94c9fe1f3ede407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-4beee6fd72341e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-10c10bebb92dcbdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-f3ee1a8749618d7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### Java\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-7aa2ff2cd34936a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 数据库\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-5e233976831658ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 运维\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-2011b4d565dba937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 操作系统\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-63c652404994128c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 机器学习\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-e6b62aeb7c201849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 软件工程\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-ee3d1dfc0c815792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 编程语言\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-c38b971a63652910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 架构设计\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-9966534d621d4265.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 编译原理\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-417ca23ed2e65c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 软件测试\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-efb10a52033a6db3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### C++\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-c72ff60964d5da47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 其他好书\n\n![img](https://upload-images.jianshu.io/upload_images/12890819-75f3398cee006bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 下载\n\n```\ngit clone https://github.com/biaochenxuying/awesome-books.git\n```\n\n**整个项目大小为 \\**4GB** 左右，多达 150 本精华电子书，下载请谨慎！**\n\n我上传时都用了几天的时间，还经常断了，要重新上传，所以下载本项目的内容是很慢的。\n\n建议一本本的下载，或者先保存到百度网盘，再下载。\n\n关注公众号：**全栈修炼**，回复 **电子书** 即可获得全部的电子书的下载链接。\n\n网盘的电子书也是来自别人的整理，我这里提供下载的链接。\n\n**不知道这个项目能存在到什么时候，所以要下载的要赶紧！**\n\n**共克时艰！**\n\n## 免责声明\n\n书籍全部来源于网络其他人的整理，仅用于个人学习，请勿用于商业获利，造成后果自负！！！\n\n如有侵权，马上联系我，我立马删除对应对应电子书及百度网盘的链接。\n\n参考项目：https://github.com/guanpengchn/awesome-books","like_users":[],"create_time":{"$date":"2020-12-13T02:57:33.929Z"},"update_time":{"$date":"2020-12-13T02:57:33.930Z"},"id":31,"__v":0}
